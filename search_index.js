var documenterSearchIndex = {"docs":
[{"location":"itensors/#ITensors-support","page":"ITensors support","title":"ITensors support","text":"","category":"section"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"This package also supports convertion with the Site and OpSum objects from ITensors library and management of DMRG sweeping process. To use these functions, include","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"using ITensors","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"at the heading of the Julia script.","category":"page"},{"location":"itensors/#Format-conversion","page":"ITensors support","title":"Format conversion","text":"","category":"section"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"The Sites objects in ITensors can be converted to a QNDiags and Confs with the QNs extracted. ","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"QNDiagFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}})\nConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, sec_qn :: QN)","category":"page"},{"location":"itensors/#Main.FuzzifiED.QNDiagFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}}","page":"ITensors support","title":"Main.FuzzifiED.QNDiagFromSites","text":"function QNDiagFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}) :: Vector{QNDiag}\n\nConverts a Sites object in the ITensors package to a set of QNDiags. \n\nArguments\n\nsites :: Vector{Index{Vector{Pair{QN, Int64}}}} is a Sites object. Only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Main.FuzzifiED.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}","page":"ITensors support","title":"Main.FuzzifiED.ConfsFromSites","text":"function ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, sec_qn :: QN) :: Confs\nfunction ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, cf_ref :: Vector{Int64}) :: Confs\n\nConverts a Sites object in the ITensors package to the Confs object\n\nArguments\n\nsites :: Vector{Index{Vector{Pair{QN, Int64}}}} is a Sites object. Only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4. \nsec_qn :: QN is a QN object that specifies the the quantum number of the selected configuration. Alternatively, cf_ref :: Vector{Int64}) is a reference configuration composed of 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"Conversely, the  Sites objects in ITensors can also be generated from a set of diagonal quantum numbers ","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"SitesFromQNDiag(qnd :: Vector{QNDiag})","category":"page"},{"location":"itensors/#Main.FuzzifiED.SitesFromQNDiag-Tuple{Vector{QNDiag}}","page":"ITensors support","title":"Main.FuzzifiED.SitesFromQNDiag","text":"function SitesFromQNDiag(qnd :: Vector{QNDiag})\n\nreturns the ITensors Sites object from a set of QNDiags. \n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"If the number of quantum numbers are too many, it can be truncated by ","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"TruncateQNDiag(qnd :: Vector{QNDiag} ; trunc_lth :: Int64 = 3, trunc_wt :: Vector{Int64} = [ 10 ^ (i - trunc_lth) for i = trunc_lth : length(qnd)]) ","category":"page"},{"location":"itensors/#Main.FuzzifiED.TruncateQNDiag-Tuple{Vector{QNDiag}}","page":"ITensors support","title":"Main.FuzzifiED.TruncateQNDiag","text":"TruncateQNDiag(qnd :: Vector{QNDiag} ; trunc_lth :: Int64, trunc_wt :: Vector{Int64}) :: Vector{QNDiag}\n\ntruncates the list of N_U QNDiags from to a number N_U acceptable by ITensors. The new quantum numbers are \n\nbeginaligned\n    Q_1=Q_1 Q_2=Q_2  Q_N_U-1=Q_N_U-1\n    Q_N_U=λ_N_UQ_N_U+λ_N_U+1Q_N_U+1++λ_N_UQ_N_U\nendaligned\n\nArguments\n\nqnd :: Vector{QNDiag} stores the set of QNDiags. \ntrunc_lth :: Int64 stores the truncated numbers of QNDiags. Facultative, 3 by default. \ntrunc_wt :: Vecotr{Int64} stores the N_U-N_U+1 coefficients λ. Facultative, 1101001000 by default. \n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"The OpSum objects in ITensors can be converted with the collection of Term's","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"TermsFromOpSum(opsum :: Sum{Scaled{ComplexF64, Prod{Op}}})\nOpSumFromTerms(tms :: Vector{Term})","category":"page"},{"location":"itensors/#Main.FuzzifiED.TermsFromOpSum-Tuple{Sum{Scaled{ComplexF64, Prod{Op}}}}","page":"ITensors support","title":"Main.FuzzifiED.TermsFromOpSum","text":"function TermsFromOpSum(opsum :: Sum{Scaled{ComplexF64, Prod{Op}}}) :: Vector{Term}\n\nConverts a OpSum object in ITensors to a series of terms. Note that the only operators supported are \"C\", \"Cdag\" \"N\" and \"I\".\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Main.FuzzifiED.OpSumFromTerms-Tuple{Vector{Term}}","page":"ITensors support","title":"Main.FuzzifiED.OpSumFromTerms","text":"function OpSumFromTerms(tms :: Vector{Term}) :: Sum{Scaled{ComplexF64, Prod{Op}}}\n\nConverts a series of terms to OpSum object in ITensors.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Easy-sweep","page":"ITensors support","title":"Easy sweep","text":"","category":"section"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"This tool kit facilitates the management of DMRG process. It automatically records the intermediate results and recover these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. These functions require the package ITensorMPOConstruction, which can be installed by ","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"julia> using Pkg; Pkg.add(url=\"https://github.com/ITensor/ITensorMPOConstruction.jl.git\")","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String = \"./\", dim_list :: Vector{Int64} = [1000,2000,3000,4000,5000,6000], proj :: Vector{String} = String[], e_tol1 :: Float64 = 1E-6, e_tol :: Float64 = 1E-7, cutoff :: Vector{Float64} = [1E-9], maxdim0 :: Vector{Int64} = [10,20,50,100,200,500], noise0 :: Vector{Float64} = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], noise :: Vector{Float64} = [1E-6,2E-7,5E-8,1E-8,0], nsweeps :: Int64 = 10, weight :: Float64 = 100.0, observer :: AbstractObserver = EasySweepObserver(e_tol1))\nSweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String = \"./\", cutoff :: Vector{Float64} = [1E-9], maxdim :: Vector{Int64} = [dim1], nsweeps :: Int64 = 10, noise :: Vector{Float64} = [1E-6,1E-7,0], proj :: Vector{String} = String[], e_tol :: Float64 = 1E-6, weight :: Float64 = 100.0, observer :: AbstractObserver = EasySweepObserver(e_tol))\nGetMPOSites(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}}, qnd :: Vector{QNDiag} ; path :: String = \"./\", mpo_method :: Function = MPO)\nGetMPO(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}}, sites :: Vector{<:Index} ; path :: String = \"./\", mpo_method :: Function = MPO)","category":"page"},{"location":"itensors/#Main.FuzzifiED.EasySweep-Tuple{String, MPO, MPS}","page":"ITensors support","title":"Main.FuzzifiED.EasySweep","text":"function EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String, dim_list :: Vector{Int64}, proj :: Vector{String}, e_tol1 :: Float64, e_tol :: Float64, cutoff :: Vector{Float64}, maxdim0 :: Vector{Float64}, noise0 :: Vector{Float64}, noise :: Vector{Int64}, nsweeps :: Int64, weight :: Float64, observer :: AbstractObserver) :: Tuple{Float64, MPS}\n\nFunction\n\nThis function automatically performs several rounds of DMRG sweeps with increasing bond dimensions. It first checks the file st_$(id).h5 in a specified repository. If the key st_fin exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process. For each round, it will try to access the results from the key st_d$(dim_i) in st_$(id).h5, where dim_i is either 0 representing the initial round, or an element of array dim_list. If the key exist, it will read the result ; otherwise it will perform the sweeps using SweepOne. For the initial round, it will take the initial state from st00, the maximal bond dimensions from maxdim0, noise from noise0 and record the results in the key E_d0 and st_d0 in st_$(id).h5. For each of the following round, it will take the result from the previous round as the initial state and perform nsweeps sweeps with the bond dimension dim_list[i]. Each round will be stopped if the energy difference is less than e_tol1. The entire process will be stopped if the energy difference between two rounds is less than e_tol or the bond dimension of the result is less than 0.9 times the maximal bond dimension. The projected states will be accessed from the files specified by proj. It will try to access first the states with the same bond dimension as the projected states. If such states do not exist, it will then access the final state. The resulting energy will be written into the key E_fin in the file st_$(id).h5, and the MPS written into st_fin. The function returns a tuple of energy and the final MPS. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\nhmt :: MPO is an MPO specifying the Hamiltonian.\nst00 :: MPS is an MPS specifying the initial state. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \ndim_list :: Vector{Int64} :: Int64 is a list that specifies the maximal bond dimensions of each round of sweeps starting from the second round. Facultative, [1000,2000,3000,4000,5000,6000] by default\nproj :: Vector{String} specifies the name of the states that will be projected. Facultative, empty by default. \ne_tol1 :: Float64 specifies the energy tolerence as a criteria to end the round of sweeps for each round of sweeps. Facultative, 1E-6 by default. \ne_tol :: Float64 specifies the energy tolerence as a criteria to end the entire process. Facultative, 1E-7 by default. \ncutoff :: Vector{Float64} is the cutoff that will be sent into DMRG. Facultative, [1.E-9] by default. \nmaxdim0 :: Vector{Int64} specifies the maximal bond dimensions of the first round of sweeps. Facultative, [10,20,50,100,200,500] by default. \nnoise0 :: Vector{Float64} specifies the noise of each sweep in the initial round and will be sent into DMRG. Facultative, [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7] by default. \nnoise :: Vector{Float64} specifies the noise of each sweep from the second round and will be sent into DMRG. Facultative, [1E-6,1E-7,0] by default. \nnsweeps :: Int64 specifies the number of sweeps in each round from the second rounds. Facultative, 10 by default. \nweight :: Float64 specifies the weight of projected states and will be sent into DMRG. Facultative, 100.0 by default.\nobserver :: AbstractObserver specifies the measurement and cutoff condition for each sweep starting from the second round. Facultative, by default the observer will print the energy and cutoff once the energy difference is less than e_tol at each sweep. \n\n\n\n\n\n","category":"method"},{"location":"itensors/#Main.FuzzifiED.SweepOne-Tuple{String, MPO, MPS, Int64}","page":"ITensors support","title":"Main.FuzzifiED.SweepOne","text":"function SweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String, cutoff :: Vector{Float64}, maxdim :: Vector{Int64}, nsweeps :: Int64, noise :: Vector{Float64}, proj :: Vector{String}, e_tol :: Float64, weight :: Float64, observer :: AbstractObserver) :: Tuple{Float64, MPS}\n\nFunction\n\nThis function performs one round of nsweeps sweeps. It first checks the file st_$(id).h5 in a specified repository. If the key st_d$(dim1) exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process with the maximal bond dimension specified by maxdim if it exists, or dim1. The projected states will be read from the key st_d$(dim1) if it exists or st_fin in the file st_$(fi).h5 in the same repository for each string fi in the array proj. The sweeps will be ended if the energy difference is less than etol or whatever criteria is given in observer. The resulting energy will be written into the key E_d$(dim1) in the file st_$(id).h5, and the MPS written into st_d$(dim1). The function returns a tuple of energy and the final MPS. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\nhmt :: MPO is an MPO specifying the Hamiltonian.\nst0 :: MPS is an MPS specifying the initial state. \ndim1 :: Int64 is a bond dimension that will be used to identify the result. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \ncutoff :: Vector{Float64} is the cutoff that will be sent into DMRG. Facultative, [1.E-9] by default. \nmaxdim :: Vector{Int64} specifies the maximal bond dimension of each sweep. Facultative, [dim1] by default. \nnsweeps :: Int64 specifies the number of sweeps in the round. Facultative, 10 by default. \nnoise :: Vector{Float64} specifies the noise of each sweep and will be sent into DMRG. Facultative, [1E-6,1E-7,0] by default. \nproj :: Vector{String} specifies the name of the states that will be projected. Facultative, empty by default. \ne_tol :: Float64 specifies the energy tolerence as a criteria to end the sweeps. Facultative, 1E-6 by default. \nweight :: Float64 specifies the weight of projected states and will be sent into DMRG. Facultative, 100.0 by default.\nobserver :: AbstractObserver specifies the measurement and cutoff condition for each sweep. Facultative, by default the observer will print the energy and cutoff once the energy difference is less than e_tol at each sweep. \n\n\n\n\n\n","category":"method"},{"location":"itensors/#Main.FuzzifiED.GetMPOSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{QNDiag}}","page":"ITensors support","title":"Main.FuzzifiED.GetMPOSites","text":"function GetMPOSites(id :: String, tms, qnd :: Vector{QNDiag} ; path :: String, qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, mpo_method :: Function) :: Tuple{MPO, Vector{<:Index}}\n\nFunction\n\nThis function returns the MPO and sites for a given operator and a Hilbert space with given quantum numbers. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and sites and return the MPO and Sites. Otherwise it will first generates the sites with the quantum numbers given in qnu_o, qnu_name and modul (these objects are often results of a function named Get*Qnu). Then it will generate the MPO with the terms of the operator given in tms. The MPO and sites will be written into the file op_$(id).h5 in the fields mpo and sites. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Vector{Term} or tms :: Sum{Scaled{ComplexF64, Prod{Op}}} is either an array of terms or a OpSum objects that specifies the expression of the operator. \nqnd :: Vector{QNDiag} is a list of diagonal quantum numbers. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultative, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. \n\n\n\n\n\n","category":"method"},{"location":"itensors/#Main.FuzzifiED.GetMPO-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{<:Index}}","page":"ITensors support","title":"Main.FuzzifiED.GetMPO","text":"function GetMPO(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}} ; path :: String, mpo_method :: Function) :: MPO\n\nFunction\n\nThis function returns the MPO for a given operator and a given set of sites. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and return the MPO it has read. Otherwise it will generate the MPO with the terms of the operator given in tms. The MPO and Sites will be written into the file op_$(id).h5 in the fields mpo. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Vector{Term} or tms :: Sum{Scaled{ComplexF64, Prod{Op}}} is either an array of terms or a OpSum objects that specifies the expression of the operator. \nsites :: Vector{<:Index} specifies the sites that the operator is acting on. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultative, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#Archieved-interfaces","page":"Archieved interfaces","title":"Archieved interfaces","text":"","category":"section"},{"location":"archieve/","page":"Archieved interfaces","title":"Archieved interfaces","text":"The following functions are used in the historical versions and might be obsolete in the future versions.","category":"page"},{"location":"archieve/#Core","page":"Archieved interfaces","title":"Core","text":"","category":"section"},{"location":"archieve/","page":"Archieved interfaces","title":"Archieved interfaces","text":"Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Any} ; nor :: Int64 = div(no, 2))\nBasis(cfs :: Confs, qnz_s :: Vector{ComplexF64} ; cyc :: Vector{Int64}, perm_o :: Vector{Any}, ph_o :: Vector{Any}, fac_o :: Vector{Any})\nGetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, qnu_s_lst :: Vector{Any}, qnz_s_lst :: Vector{Any} ; qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ \"QN\" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)], cyc :: Vector{Int64}, perm_o :: Vector{Any}, ph_o :: Vector{Any}, fac_o :: Vector{Any}, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2)))","category":"page"},{"location":"archieve/#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}","page":"Archieved interfaces","title":"Main.FuzzifiED.Confs","text":"function Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Vector{Int64}} ; nor :: Int64 = div(no, 2), modul :: Vector{Int64}, num_th :: Int64, disp_std :: Bool) :: Confs\n\nWe have improved the interface for this function. Please consider using in the future\n\nConfs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag}) :: Confs\n\ngenerates the configurations that has the diagonal quantum numbers given by qnu_s of certain conserved quantities specified by qnu_o :: Vector{Vector{Int64}}\n\nQ_i=_o=1^N_oq_ion_o\n\nor\n\nQ_i=_o=1^N_oq_ion_o mathrmmod p_i\n\nwhere i=1N_U is the index of quantum number, o is the index of orbital, n_o=c^_oc_o, and q_o is a set of coefficients that must be non negative integer valued. (A list of q_o with both positive and negative entries can be adapted by shifting every elements by a same value)\n\nArguments\n\nno :: Int64 is the number of orbital*flavour N_o ;\nqnu_s :: Vector{Int64} is the set of Q_i for the selected configurations ;\nqnu_o :: Vector{Vector{Int64}} is the set of q_io for each quantum number and for each orbital. It should contain N_U elements and each element should be a vector of length N_o. \nnor :: Int64 is the number of less significant bits used to generate the Lin table. Facultative, N_o2 by default.\nmodul :: Vector{Int64} is the modulus of each quantum number. Setting it to 1 means there is no modulus. Facultative, all 1 by default. \nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\ncfs :: Confs is a Confs object\n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.Basis-Tuple{Confs, Vector{ComplexF64}}","page":"Archieved interfaces","title":"Main.FuzzifiED.Basis","text":"function Basis(cfs :: Confs, qnz_s :: Vector{ComplexF64} ; cyc :: Vector{Int64}, perm_o :: Vector{Vector{Int64}}, ph_o :: Vector{Vector{Int64}}, fac_o :: Vector{Vector{ComplexF64}} ; num_th :: Int64, disp_std :: Bool) :: Basis\n\nWe have improved the interface for this function. Please consider using in the future\n\nBasis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd}) :: Basis\n\ngenerates the basis that respects the off-diagonal ℤ_n quantum numbers (QNZ) from the diagonal QN–preserving configurations. The discrete ℤ_n symmetries are in the form of \n\n𝒵 c_o α_o^* c^(p_o)_π_o  c_o^ α_o c^(1-p_o)_π_o\n\nwhere we use a notation c^(1)=c^ and c^0=c for convenience, π_o is a permutation of 1N_o, α_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the orbital. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal QNs. \n\nArguments\n\ncfs :: Confs is the diagonal QN–preserving configurations ;\nqnz_s :: Vector{ComplexF64} is a vector of length the same as the number of discrete symmetries that records the eigenvalue of each transformation ;\ncyc :: Vector{Int64} records the cycle of each transformation. For ℤ_n symmetry, record n ;\nperm_o :: Vector{Vector{Int64}} records the permutation π_o. It has N_Z elements and each of its elements is a vector of length N_o. \nph_o :: Vector{Vector{Int64}} records p_o to determine whether or not to perform a particle-hole transformation. It has N_Z elements and each of its elements is a vector of length N_o. \nfac_o :: Vector{Vector{ComplexF64}} records the factor α_o in the transformation. Each of its elements is a vector of length N_o. \nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nbs :: Basis is the resulting Basis object\n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.GetEntSpec-Tuple{Vector{<:Number}, Basis, Vector{Any}, Vector{Any}}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetEntSpec","text":"function GetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, qnu_s_lst :: Vector{Vector{Vector{Int64}}}, qnz_s_lst :: Vector{Vector{Vector{ComplexF64}}} ; qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, cyc :: Vector{Int64}, perm_o :: Vector{Vector{Int64}}, ph_o :: Vector{Vector{Int64}}, fac_o :: Vector{Vector{ComplexF64}}, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2))) :: Dict{@NamedTuple{qnu_sa, qnz_sa, qnu_sb, qnz_sb}, Vector{Float64}}\n\nWe have improved the interface for this function. Please consider using in the future\n\nGetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{<:Number}}} ; qnd_a :: Vector{QNDiag} qnf_a :: Vector{QNOffd}, amp_oa :: Vector{<:Number})\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: Basis is the total basis. \nqnu_s_lst :: Vector{Vector{Vector{Int64}}} gives the list of QNU sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the QNUs for subsystem A, and the second specifies the QNU for subsystem B. \nqnz_s_lst :: Vector{Vector{Vector{ComplexF64}}} gives the list of QNZ sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the QNZs for subsystem A, and the second specifies the QNZs for subsystem B. \nqnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String} and modul :: Vector{Int64} specifies the diagonal quantum numbers of the subsystems A and B. \ncyc :: Vector{Int64}, perm_o :: Vector{Vector{Int64}}, ph_o :: Vector{Vector{Int64}} and fac_o :: Vector{Vector{ComplexF64}} specifies the off-diagonal quantum numbers of the subsystems A and B. \namp_oa :: Vector{ComplexF64} and amp_ob :: Vector{ComplexF64} are complex lists of length no that specify the amplitute of each orbital in the subsystems A and B. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to ℱ_mA in PRB 85, 125308 (2012) with an extra phase factor. \n\nOutput\n\nA dictionary whose keys are named tuples that specify the sector containing entries qnu_sa, qnz_sq, qnu_sb, qnz_sb and values are lists of eigenvalues of the density matrix in those sectors. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#ITensor-support","page":"Archieved interfaces","title":"ITensor support","text":"","category":"section"},{"location":"archieve/","page":"Archieved interfaces","title":"Archieved interfaces","text":"TruncateQnu(; qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ \"QN\" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)], trunc_lth :: Int64 = 3, trunc_wt :: Vector{Int64} = [ 2 ^ (i - trunc_lth) for i = trunc_lth : length(qnu_o)]) \nSitesFromQnu(; qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ \"QN\" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)])\nGetMPOSites(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}} ; path :: String = \"./\", qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ \"QN\" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)], mpo_method :: Function = MPO)","category":"page"},{"location":"archieve/#Main.FuzzifiED.TruncateQnu-Tuple{}","page":"Archieved interfaces","title":"Main.FuzzifiED.TruncateQnu","text":"TruncateQnu(; qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, trunc_lth :: Int64, trunc_wt :: Vector{Int64})\n\nWe have improved the interface for this function. Please consider using in the future TruncateQNDiag\n\nTruncateQNDiag(qnd ; trunc_lth, trunc_wt)\n\ntruncates the list of N_U QNU's from to a number N_U acceptable by ITensors. The new quantum numbers are \n\nbeginaligned\n    Q_1=Q_1 Q_2=Q_2  Q_N_U-1=Q_N_U-1\n    Q_N_U=λ_N_UQ_N_U+λ_N_U+1Q_N_U+1++λ_N_UQ_N_U\nendaligned\n\nArguments\n\nqnu_o :: Vector{Vector{Int64}} stores the charge of each orbital under each conserved quantity. See Confs for detail. \nqnu_name :: Vector{String} stores the name of each quantum number. Facultative, QN1, QN2, ... by default. \nmodul :: Vector{Int64} stores the modulus of each quantum number. Store 1 if no modulus. Facultative, all 1 by default. \ntrunc_lth :: Int64 stores the truncated numbers of QNU. Facultative, 3 by default. \ntrunc_wt :: Vecotr{Int64} stores the N_U-N_U+1 coefficients λ. Facultative, 1248 by default. \n\nOutput\n\nA named tuple with three elements that can be directly fed into SitesFromQnu\n\nqnu_o :: Vector{Vector{Int64}} stores the charge of each orbital under each conserved quantity. See Confs for detail.\nqnu_name :: Vector{String} stores the name of each quantum number.\nmodul :: Vector{Int64} stores the modulus of each quantum number, 1 if no modulus. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.SitesFromQnu-Tuple{}","page":"Archieved interfaces","title":"Main.FuzzifiED.SitesFromQnu","text":"function SitesFromQnu(; qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64})\n\nWe have improved the interface for the function. Please consider using in the future SitesFromQNDiag\n\nSitesFromQNDiag(qnd)\n\nreturns the ITensors Sites object from the information of quantum numbers \n\nArguments\n\nqnu_o :: Vector{Vector{Int64}} stores the charge of each orbital under each conserved quantity. See Confs for detail. \nqnu_name :: Vector{String} stores the name of each quantum number. Facultative, QN1, QN2, ... by default. \nmodul :: Vector{Int64} stores the modulus of each quantum number. Store 1 if no modulus. Facultative, all 1 by default. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.GetMPOSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetMPOSites","text":"function GetMPOSites(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}} ; path :: String, qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, mpo_method :: Function) :: Tuple{MPO, Vector{<:Index}}\n\nWe have improved the interface for the function. Please consider using in the future\n\nGetMPOSites(id, tms, qnd)\n\nFunction\n\nThis function returns the MPO and sites for a given operator and a Hilbert space with given quantum numbers. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and sites and return the MPO and Sites. Otherwise it will first generates the sites with the quantum numbers given in qnu_o, qnu_name and modul (these objects are often results of a function named Get*Qnu). Then it will generate the MPO with the terms of the operator given in tms. The MPO and sites will be written into the file op_$(id).h5 in the fields mpo and sites. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Vector{Term} or tms :: Sum{Scaled{ComplexF64, Prod{Op}}} is either an array of terms or a OpSum objects that specifies the expression of the operator. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \nqnu_o :: Vector{Vector{Int64}} is a list where each element specifies a quantum number. Each element is a list that specifies the charges of each orbital under the quantum number. Obligatory. \nqnu_name :: Vector{String} specifies the name of each quantum number. Facultative, QN1, QN2, ... by default. \nmodule :: Vector{Int64} specifies the modulus of each quantum number. Facultative, all 1 by default.\nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultative, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#Built-in-models","page":"Archieved interfaces","title":"Built-in models","text":"","category":"section"},{"location":"archieve/","page":"Archieved interfaces","title":"Archieved interfaces","text":"GetLzQnu(nm :: Int64, nf :: Int64)\nGetLzConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0)\nGetLzZnQnu(nm :: Int64, nf :: Int64)\nGetLzZnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0, zn :: Int64 = 0)\nGetIsingBasis(cfs :: Confs ; qn_p :: Int64 = 0, qn_z :: Int64 = 0, qn_r :: Int64 = 0)\nGetSnBasis(cfs :: Confs, nf :: Int64 ; qn_r :: Int64 = 0, perm :: Vector = [], qn_z :: Vector{<:Number} = Number[]) \nGetIsingIntTerms(nm :: Int64 ; ps_pot :: Vector = [1.])\nGetXPolTerms(nm :: Int64)\nGetZPolTerms(nm :: Int64)","category":"page"},{"location":"archieve/#Main.FuzzifiED.GetLzQnu-Tuple{Int64, Int64}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetLzQnu","text":"function GetLzQnu(nm :: Int64, nf :: Int64) :: @NamedTuple{qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}}\n\nWe have improved the interface for the function. Please consider using in the future the built-in QNDiags\n\n[ GetNeQNDiag(nm * nf), GetLz2QNDiag(nm, nf) ]\n\nreturns the diagonal quantum numbers, i.e., particle number N_e and angular momentum L_z+sN_e\n\nbeginaligned\n    N_e=_o n_o\n    L_z+sN_e=_mf(m+s)n_o\nendaligned\n\nArguments\n\nnm :: Int64 is the number of orbitals ; \nnf :: Int64 is the number of flavours ; \n\nOutput\n\nA named tuple with three elements that can be directly fed into SitesFromQnu\n\nqnu_o :: Vector{Vector{Int64}} stores the charge of each orbital under each conserved quantity. See Confs for detail.\nqnu_name :: Vector{String} stores the name of each quantum number.\nmodul :: Vector{Int64} stores the modulus of each quantum number, 1 if no modulus. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.GetLzConfs-Tuple{Int64, Int64, Int64}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetLzConfs","text":"function GetLzConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 ; num_th :: Int64, disp_std :: Bool) :: Confs\n\nWe have improved the interface for the function. Please consider using in the future the built-in QNDiags\n\nConfs(nm * nf, [ne, Int(lz * 2), zn], [ \n    GetNeQNDiag(nm * nf), \n    GetLz2QNDiag(nm, nf)\n])\n\nReturn the configurations with conserved particle number N_e and angular momentum L_z.\n\nArguments\n\nnm :: Int64 is the number of orbitals 2s+1.\nnf :: Int64 is the number of flavours ; \nne :: Int64 is the number of electrons.\nlz :: Float64 is the angular momentum. Facultative, 0 by default. \nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.GetLzZnQnu-Tuple{Int64, Int64}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetLzZnQnu","text":"function GetLzZnQnu(nm :: Int64, nf :: Int64) :: @NamedTuple{qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}}\n\nWe have improved the interface for the function. Please consider using in the future the built-in QNDiags\n\n[ GetNeQNDiag(nm * nf), GetLz2QNDiag(nm, nf), GetZnfChargeQNDiag(nm, nf) ]\n\nreturns the diagonal quantum numbers, i.e., particle number N_e, angular momentum L_z+sN_e and flavour charge Z_N_f\n\nbeginaligned\n    N_e=_o n_o\n    L_z+sN_e=_mf(m+s)n_mf\n    Z_N_f=_mf=0^N_f-1fn_mf mathrmmod N_f\nendaligned\n\nArguments\n\nnm :: Int64 is the number of orbitals ; \nnf :: Int64 is the number of flavours ; \n\nOutput\n\nA named tuple with three elements that can be directly fed into SitesFromQnu\n\nqnu_o :: Vector{Vector{Int64}} stores the charge of each orbital under each conserved quantity. See Confs for detail.\nqnu_name :: Vector{String} stores the name of each quantum number.\nmodul :: Vector{Int64} stores the modulus of each quantum number, 1 if no modulus. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.GetLzZnConfs-Tuple{Int64, Int64, Int64}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetLzZnConfs","text":"function GetLzZnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64, zn :: Int64 = 0 ; num_th :: Int64, disp_std :: Bool) :: Confs\n\nWe have improved the interface for the function. Please consider using in the future the built-in QNDiags\n\nConfs(nm * nf, [ne, Int(lz * 2), zn], [ \n    GetNeQNDiag(nm * nf), \n    GetLz2QNDiag(nm, nf), \n    GetZnfChargeQNDiag(nm, nf) \n])\n\nReturn the configurations with conserved particle number N_e, angular momentum L_z and flavour charge Z_N_f.\n\nArguments\n\nnm :: Int64 is the number of orbitals 2s+1.\nnf :: Int64 is the number of flavours ; \nne :: Int64 is the number of electrons.\nlz :: Float64 is the angular momentum. Facultative, 0 by default. \nzn :: Float64 is the flavour charge. Facultative, 0 by default. \nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.GetIsingBasis-Tuple{Confs}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetIsingBasis","text":"function GetIsingBasis(cfs :: Confs ; qn_p :: Int64 = 0, qn_z :: Int64 = 0, qn_r :: Int64 = 0, num_th :: Int64, disp_std :: Bool) :: Basis\n\nWe have improved the interface for the function. Please consider using in the future the built-in QNOffds\n\nbs = Basis(cfs, [qn_p, qn_z, qn_r], [\n    GetParityQNOffd(nm, 2, [2, 1], [1, -1]), \n    GetFlavPermQNOffd(nm, 2, [2, 1]),\n    GetRotyQNOffd(nm, 2)\n])\n\nReturn the basis with conserved parity mathscrP, flavour symmetry 𝒵 and π-rotation along y-axis mathscrR from the configurations already generated. Quantum numbers set to zero signify that they are not conserved. \n\nArguments\n\ncfs :: Confs is the configurations generated by GetLzConfs or GetLzZnConfs.\nqn_p :: Int64 is quantum number for parity transformation. Facultative, 0 by default.\nqn_z :: Int64 is the particle quantum number for ℤ_2-flavour transformation. Facultative, 0 by default.\nqn_r :: Int64 is the quantum number for  π rotation along y-axis compared with the ground state. Facultative, 0 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.GetSnBasis-Tuple{Confs, Int64}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetSnBasis","text":"function GetSnBasis(cfs :: Confs, nf :: Int64 ; qn_r :: Int64 = 0, perm :: Vector, qn_z :: Vector{<:Number}) :: Basis\n\nWe have improved the interface for the function. Please consider using in the future the built-in QNOffds\n\nbs = Basis(cfs, [qn_r, qn_z...], [\n    GetRotyQNOffd(nm, nf)\n    GetFlavPermQNOffd(nm, nf, [ perm1 ], cyc1),\n    GetFlavPermQNOffd(nm, nf, [ perm2 ], cyc2)...\n])\n\nReturn the basis where the π-rotation along y-axis mathscrR and certain permutationss of flavour are implemented. Quantum numbers set to zero signify that they are not conserved. \n\nArguments\n\ncfs :: Confs is the configurations generated by GetLzConfs or GetLzZnConfs.\nnf :: Int64 is the number of flavours\nqn_r :: Int64 is the quantum number for  π rotation along y-axis compared with the ground state. Facultative, 0 by default.\nperm :: Vector{Vector{Int64}} is a list where each element specifies a permutation of flavour indices (from 1 to N_f) in the format of a cycle. Facultative, empty by default.\nqn_z :: Vector{<:Number} is a list where each element specifies the quantum number under the flavour permutation. Facultative, empty by default. \nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.GetIsingIntTerms-Tuple{Int64}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetIsingIntTerms","text":"function GetIsingIntTerms(nm :: Int64 ; ps_pot :: Vector) :: Vector{Term}\n\nWe have improved the interface for the function. Please consider using the function GetDenIntTerms in the future\n\n    GetDenIntTerms(nm, 2 ; ps_pot = 2 .* ps_pot, mat_a = diagm([1, 0]), mat_b = diagm([0, 1]))\n\nReturns the terms for the ising interaction \n\n_m_1m_2m_3m_42U_m_1m_2m_3m_4c^_m_1uparrowc^_m_2downarrowc_m_3downarrowc_m_4uparrow\n\nfrom the pseudopotentials. \n\nArguments\n\nnm :: Int64 is the number of orbitals 2s+1.\nps_pot :: Vector{Number} is the pseudopotential of Ising interaction.\n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.GetXPolTerms-Tuple{Int64}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetXPolTerms","text":"function GetXPolTerms(nm :: Int64)\n\nWe have improved the interface for the function. Please consider using the function GetPolTerms in the future\n\n    GetPolTerms(nm, 2, [ 0 1 ; 1 0 ])\n\nReturns the terms for the density operator n^x_l=0m=0\n\nArguments\n\nnm :: Int64 is the number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"archieve/#Main.FuzzifiED.GetZPolTerms-Tuple{Int64}","page":"Archieved interfaces","title":"Main.FuzzifiED.GetZPolTerms","text":"function GetZPolTerms(nm :: Int64)\n\nWe have improved the interface for the function. Please consider using the function GetPolTerms in the future\n\n    GetPolTerms(nm, 2, [ 1 0 ; 0 -1 ])\n\nReturns the terms for the density operator n^z_l=0m=0\n\nArguments\n\nnm :: Int64 is the number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"core/#Core-functions","page":"Core functions","title":"Core functions","text":"","category":"section"},{"location":"core/#Environment-parameters","page":"Core functions","title":"Environment parameters","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The following environment parameters defines how FuzzifiED works, viz. whether it outputs logs, how many threads it uses and where it reads its libraries. In general, you can keep it at default. ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"SilentStd\nNumThreads\nLibpath\nElementType","category":"page"},{"location":"core/#Main.FuzzifiED.SilentStd","page":"Core functions","title":"Main.FuzzifiED.SilentStd","text":"SilentStd :: Bool = false\n\na flag to determine whether logs of the FuzzifiED functions should be turned off. False by default. If you want to evaluate without log, put FuzzifiED.SilentStd = true. This parameter can be defined for each process separately. \n\n\n\n\n\n","category":"constant"},{"location":"core/#Main.FuzzifiED.NumThreads","page":"Core functions","title":"Main.FuzzifiED.NumThreads","text":"NumThreads :: Int = Threads.nthreads()\n\nan integer to define how many threads OpenMP uses. By default, it is the same as the number of threads in Julia. If you use Jupyter notebooks, which by default uses one core only, you may need to define this by hand, e.g., FuzzifiED.NumThreads = 8. This parameter can be defined for each process separately. \n\n\n\n\n\n","category":"constant"},{"location":"core/#Main.FuzzifiED.Libpath","page":"Core functions","title":"Main.FuzzifiED.Libpath","text":"Libpath :: String = FuzzifiED_jll.LibpathFuzzifiED\n\ndefine where the Fortran library are compiled. You do not need to modify that by yourself. However, if you compile the Fortran codes by yourself, you need to point this to your compiled library. \n\n\n\n\n\n","category":"constant"},{"location":"core/#Main.FuzzifiED.ElementType","page":"Core functions","title":"Main.FuzzifiED.ElementType","text":"ElementType :: DataType = ComplexF64\n\nset the default type of the operator elements, either ComplexF64 or Float64. ComplexF64 by default. \n\n\n\n\n\n","category":"type"},{"location":"core/#Quantum-numbers","page":"Core functions","title":"Quantum numbers","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"FuzzifiED implements diagonal and off-diagonal quantum numbers. They are defined as","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"QNDiag\nQNOffd","category":"page"},{"location":"core/#Main.FuzzifiED.QNDiag","page":"Core functions","title":"Main.FuzzifiED.QNDiag","text":"mutable struct QNDiag\n\nrecords the information of a diagonal mathrmU(1) or ℤ_p quantum number in the form of a symmetry charge\n\nQ=_o=1^N_oq_on_o\n\nor\n\nQ=_o=1^N_oq_on_o mathrmmod p\n\nwhere i=1N_U is the index of quantum number, o is the index of orbital, n_o=c^_oc_o, and q_o is a set of coefficients that must be integer valued.\n\nFields\n\nname :: String is the name of the diagonal quantum number \ncharge :: Vector{Int64} is the symmetry charge q_o of each orbital\nmodul :: Vector{Int64} is the modulus p, set to 1 for mathrmU(1) QNDiags. \n\nInitialisation\n\nIt can be initialised by the following method\n\nQNDiag([name :: String, ]charge :: Vector{Int64}[, modul :: Int64]) :: QNDiag\n\nThe arguments name and modul is facultative. By default name is set to \"QN\" and modul is set to 1. \n\n\n\n\n\n","category":"type"},{"location":"core/#Main.FuzzifiED.QNOffd","page":"Core functions","title":"Main.FuzzifiED.QNOffd","text":"mutable struct QNOffd\n\nrecords the information of an off-diagonal ℤ_p quantum number in the form of a discrete transformation\n\n𝒵 c_o α_o^* c^(p_o)_π_o  c_o^ α_o c^(1-p_o)_π_o\n\nwhere we use a notation c^(1)=c^ and c^0=c for convenience, π_o is a permutation of 1N_o, α_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the orbital. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal QNs. \n\nArguments\n\nperm :: Vector{Int64} is a length-N_o vector that records the permutation π_o.\nph :: Vector{Int64} is a length-N_o vector that records p_o to determine whether or not to perform a particle-hole transformation\nfac :: Vector{ComplexF64} is a length-N_o vector that records the factor α_o in the transformation.\ncyc :: Int64 is the cycle p. \n\nInitialisation\n\nIt can be initialised by the following method\n\nQNOffd(perm :: Vector{Int64}[, ph :: Vector{Int64}][, fac :: Vector{ComplexF64}][, cyc :: Int64]) :: QNOffd\nQNOffd(perm :: Vector{Int64}, ph_q :: Bool[, fac :: Vector{ComplexF64}]) :: QNOffd\n\nThe arguments ph, fac and cyc are facultative. By default ph is set all 0, fac is set to all 1 and cyc is set to 2. If ph_q is a bool and true, then ph is set to all 1. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The QNDiag can be added or multiplied by a number ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"+(qnd1 :: QNDiag, qnd2 :: QNDiag)\n*(fac :: Int64, qnd :: QNDiag)","category":"page"},{"location":"core/#Base.:+-Tuple{QNDiag, QNDiag}","page":"Core functions","title":"Base.:+","text":"function +(qnd1 :: QNDiag, qnd2 :: QNDiag) :: QNDiag \nfunction -(qnd1 :: QNDiag, qnd2 :: QNDiag) :: QNDiag\n\nreturns the sum or substraction of two QNDiags, whose name is the samea as qnd1, charge is the same as qnd1 ± qnd2, and modulus is the GCD of qnd1 and qnd2. If qnd1 and qnd2 are both ℤ_p quantum numbers and their modulus are coprime, a trivial QNDiag will be returned. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Int64, QNDiag}","page":"Core functions","title":"Base.:*","text":"function *(fac :: Int64, qnd :: QNDiag) :: QNDiag \nfunction *(qnd :: QNDiag, fac :: Int64) :: QNDiag \nfunction ÷(qnd :: QNDiag, fac :: Int64) :: QNDiag \nfunction -(qnd :: QNDiag) :: QNDiag\n\nreturns the QNDiag multiplied or divided by an integer factor, where the charge is multiplied or integer-divided by the factor. For ℤ_p quantum numbers, their modulus will be multiplied or integer-divided by the absolute value. If qnd.modul ÷ abs(fac) ≤ 1, a trivial QNDiag will be returned.  \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The QNOffd can be composed","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(qnf1 :: QNOffd, qnf2 :: QNOffd)","category":"page"},{"location":"core/#Base.:*-Tuple{QNOffd, QNOffd}","page":"Core functions","title":"Base.:*","text":"function *(qnf1 :: QNOffd, qnf2 :: QNOffd) :: QNOffd\n\nreturns the composition of two QNOffd transformations. The cycle is set to be the LCM of two QNOffds\n\n\n\n\n\n","category":"method"},{"location":"core/#Configurations","page":"Core functions","title":"Configurations","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Confs","category":"page"},{"location":"core/#Main.FuzzifiED.Confs","page":"Core functions","title":"Main.FuzzifiED.Confs","text":"mutable struct Confs\n\nThis type stores all the configurations that respects the diagonal quantum numbers (QNDiag) and also a table to inversely look up the index from the configuration. \n\nFields\n\nno :: Int64 is the number of orbital*flavour.\nncf :: Int64 is the number of configurations.\nconf :: Vector{Int64} is an array of length ncf containing all the configurations. Each configuration is expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th orbital in the i-th configuration is occupied ; if the bit is 0, then the orbital is empty. \nnor :: Int64, lid :: Vector{Int64} and rid :: Vector{Int64} contain the information of Lin table that is used to inversely look up the index i from the configuration. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated from the QNDiags.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag} ; nor :: Int64 = div(no, 2), num_th :: Int64 = NumThreads, disp_std :: Bool = !SilentStd)","category":"page"},{"location":"core/#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{QNDiag}}","page":"Core functions","title":"Main.FuzzifiED.Confs","text":"function Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag} ; nor :: Int64 = div(no, 2), modul :: Vector{Int64}, num_th :: Int64, disp_std :: Bool) :: Confs\n\ngenerates the configurations from the list of QNDiags. \n\nArguments\n\nno :: Int64 is the number of orbital*flavour N_o.\nsecd :: Vector{Int64} is the set of Q_i for the selected configurations in the sector.\nqnd :: Vector{QNDiag} is the set of QNDiags. \nnor :: Int64 is the number of less significant bits used to generate the Lin table. Facultative, N_o2 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\ncfs :: Confs is a Confs object.\n\nNote\n\nIf your qnd has negative entries, QNDiags must contain the number of electrons.\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The inverse look-back for a configuration can be done by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetConfId(cfs :: Confs, cf :: Int64)","category":"page"},{"location":"core/#Main.FuzzifiED.GetConfId-Tuple{Confs, Int64}","page":"Core functions","title":"Main.FuzzifiED.GetConfId","text":"GetConfId(cfs :: Confs, cf :: Int64) :: Int64\n\ninversely look up the index from the configuration\n\nArguments\n\ncfs :: Confs stores the configurations.\ncf :: Int64 stores the configuration to be looked-up expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th orbital in the i-th configuration is occupied ; if the bit is 0, then the orbital is empty. \n\nOutput\n\nid :: Int64 is the id of the configuration such that cfs.conf[id] == cf\n\n\n\n\n\n","category":"method"},{"location":"core/#Basis","page":"Core functions","title":"Basis","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Basis","category":"page"},{"location":"core/#Main.FuzzifiED.Basis","page":"Core functions","title":"Main.FuzzifiED.Basis","text":"mutable struct Basis\n\nThis type stores the information of the basis that respects both diagonal and off-diagonal quantum numbers. The states in the basis is in the form \n\nI=λ_i_I1i_I1+λ_i_I2i_I2++λ_i_Im_Ii_Im_I\n\nwhere i is a direct product state, i.e., the configurations i_Ik are grouped into a state I. \n\nFields\n\ncfs :: Confs stores the configurations that respect the QNDiags ;\ndim :: Int64 is the dimension of the basis ;\nszz :: Int64 records the maximum size max m_g of groups;\ncfgr :: Vector{Int64} is a vector of length cfs.ncf and records which group I each configuration i belong to ;\ncffac :: Vector{ComplexF64} is a vector of length cfs.ncf and records the coefficients λ_i of each configuration ;\ngrel :: Matrix{Int64} is a szz*dim matrix that records the configurations in each group i_Ik (k = 1m_I)\ngrsz :: Vector{Int64} is a vector of length dim that records the size m_I of each group.\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd} ; num_th = NumThreads, disp_std = !SilentStd)\nBasis(cfs :: Confs)","category":"page"},{"location":"core/#Main.FuzzifiED.Basis-Tuple{Confs, Vector{ComplexF64}, Vector{QNOffd}}","page":"Core functions","title":"Main.FuzzifiED.Basis","text":"function Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd} ; num_th :: Int64, disp_std :: Bool) :: Basis\n\ngenerates the basis that respects the off-diagonal ℤ_p quantum numbers (QNOffd)\n\nArguments\n\ncfs :: Confs is the diagonal QN–preserving configurations ;\nsecf :: Vector{ComplexF64} is a vector of length the same as the number of discrete symmetries that records the eigenvalue of each transformation in the sector ;\nqnf :: Vector{QNOffd} is a vector of off-diagonal quantum numbers. \nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nbs :: Basis is the resulting Basis object\n\n\n\n\n\n","category":"method"},{"location":"core/#Main.FuzzifiED.Basis-Tuple{Confs}","page":"Core functions","title":"Main.FuzzifiED.Basis","text":"function Basis(cfs :: Confs) :: Basis\n\nGenerate a basis from the configurations without off-diagonal ℤ_n symmetries.\n\nArguments\n\ncfs :: Confs is the diagonal QN–preserving configurations ;\n\nOutput\n\nbs :: Basis is the resulting Basis object\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The look-back of the weight of a configuration in a state can be done by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetConfWeight(bs :: Basis, st :: Union{Vector{ComplexF64}, Vector{Float64}}, cf :: Int64)","category":"page"},{"location":"core/#Main.FuzzifiED.GetConfWeight-Tuple{Basis, Union{Vector{ComplexF64}, Vector{Float64}}, Int64}","page":"Core functions","title":"Main.FuzzifiED.GetConfWeight","text":"GetConfWeight(bs :: Basis, st :: Vector{<:Number}, cf :: Int64) :: ComplexF64\n\nlooks up a the weight of a configuration in a state. \n\nArguments\n\nbs :: Basis is the basis of the state ; \nst :: Vector{ComplexF64} or st :: Vector{Float64} is a vector of length bs.dim that stores the state ; \ncf :: Int64 stores the configuration to be looked-up expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th orbital in the i-th configuration is occupied ; if the bit is 0, then the orbital is empty. \n\nOutput\n\nThe weight of the configuration in the state \n\n\n\n\n\n","category":"method"},{"location":"core/#Term","page":"Core functions","title":"Term","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Term","category":"page"},{"location":"core/#Main.FuzzifiED.Term","page":"Core functions","title":"Main.FuzzifiED.Term","text":"mutable struct Term\n\nA Term object records a term that looks like Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l in an operator\n\nFields\n\ncoeff :: ComplexF64 records the coefficient U\ncstr :: Vector{Int64} is a length-2l vector (p_1o_1p_2o_2 p_lo_l) recording the operator string\n\nMethod\n\nIt can be generated by the function\n\nfunction Term(coeff :: ComplexF64, cstr :: Vector{Int64}) :: ComplexF64\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of terms with a number, the sum and product of terms, adjoint and particle-hole transformation are defined","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(fac :: Number, tms :: Vector{Term})\n+(tms1 :: Vector{Term}, tms2 :: Vector{Term})\n*(tms1 :: Vector{Term}, tms2 :: Vector{Term})\nadjoint(tms :: Vector{Term})\nParticleHole(tms :: Vector{Term})","category":"page"},{"location":"core/#Base.:*-Tuple{Number, Vector{Term}}","page":"Core functions","title":"Base.:*","text":"function *(fac :: Number, tms :: Vector{Term}) :: Vector{Term}\nfunction -(tms :: Vector{Term}) :: Vector{Term}\nfunction *(tms :: Vector{Term}, fac :: Number) :: Vector{Term}\nfunction /(tms :: Vector{Term}, fac :: Number) :: Vector{Term}\n\nReturn the product of a collection of terms with a number. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:+-Tuple{Vector{Term}, Vector{Term}}","page":"Core functions","title":"Base.:+","text":"function +(tms1 :: Vector{Term}, tms2 :: Vector{Term}) :: Vector{Term}\nfunction -(tms1 :: Vector{Term}, tms2 :: Vector{Term}) :: Vector{Term}\n\nReturn the naive sum of two series of terms by taking their union. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Vector{Term}, Vector{Term}}","page":"Core functions","title":"Base.:*","text":"function *(tms1 :: Vector{Term}, tms2 :: Vector{Term}) :: Vector{Term}\nfunction ^(tms :: Vector{Term}, pow :: Int64) :: Vector{Term}\n\nReturn the naive product of two series of terms or the power of one terms. The number of terms equals the product of the number of terms in tms1 and tms2. For each term in tms1 Uc^(p_1)_o_1 and tms2 Uc^(p_1)_o_1, a new term is formed by taking UUc^(p_1)_o_1 c^(p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.adjoint-Tuple{Vector{Term}}","page":"Core functions","title":"Base.adjoint","text":"function adjoint(tm :: Term) :: Term\nfunction adjoint(tms :: Vector{Term}) :: Vector{Term}\n\nReturn the Hermitian conjugate of a series of terms. For each term Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l, the adjoint is barUc^(1-p_l)_o_l c^(1-p_2)_o_2c^(1-p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"core/#Main.FuzzifiED.ParticleHole-Tuple{Vector{Term}}","page":"Core functions","title":"Main.FuzzifiED.ParticleHole","text":"function ParticleHole(tm :: Term) :: Term\nfunction ParticleHole(tms :: Vector{Term}) :: Vector{Term}\n\nReturn the particle-hole transformation of a series of terms. For each term Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l, the transformation results in Uc^(1-p_1)_o_1c^(1-p_2)_o_2c^(1-p_l)_o_l\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The terms can be simplified by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"NormalOrder(tm :: Term)\nSimplifyTerms(tms :: Vector{Term})","category":"page"},{"location":"core/#Main.FuzzifiED.NormalOrder-Tuple{Term}","page":"Core functions","title":"Main.FuzzifiED.NormalOrder","text":"function NormalOrder(tm :: Term) :: Vector{Term}\n\nrearrange a term such that \n\nthe creation operators must be commuted in front of the annihilation operator \nthe orbital index of the creation operators are in ascending order and the annihilation operators in descending order. \n\nreturn a list of terms whose result is equal to the original term. \n\n\n\n\n\n","category":"method"},{"location":"core/#Main.FuzzifiED.SimplifyTerms-Tuple{Vector{Term}}","page":"Core functions","title":"Main.FuzzifiED.SimplifyTerms","text":"function SimplifyTerms(tms :: Vector{Term}) :: Vector{Term}\n\nsimplifies the sum of terms such that \n\neach term is normal ordered,\nlike terms are combined, and terms with zero coefficients are removed.\n\n\n\n\n\n","category":"method"},{"location":"core/#Operator","page":"Core functions","title":"Operator","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Operator","category":"page"},{"location":"core/#Main.FuzzifiED.Operator","page":"Core functions","title":"Main.FuzzifiED.Operator","text":"mutable struct Operator\n\nAn Operator object records the sum of terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: Basis is the basis of the initial state ;\nbsf :: Basis is the basis of the final state ;\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; \nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0 ;\nntm :: Int64 is the number of terms ;\nnc :: Int64 is the maximum number of operators in an operator string\ncstrs :: Matrix{Int64} is a matrix recording the operator string of each term. Each column corresponds to a term and is padded to the maximum length with -1's.\ncoeffs :: Vector{ComplexF64} corresponds to the coefficients in each term.\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Operator(bsd :: Basis, bsf :: Basis, terms :: Vector{Term} ; red_q :: Int64 = 0, sym_q :: Int64 = 0)","category":"page"},{"location":"core/#Main.FuzzifiED.Operator-Tuple{Basis, Basis, Vector{Term}}","page":"Core functions","title":"Main.FuzzifiED.Operator","text":"function Operator(bsd :: Basis[, bsf :: Basis], terms :: Vector{Term} ; red_q :: Int64, sym_q :: Int64, num_th :: Int64, disp_std :: Bool) :: Operator\n\ngenerates an operator object from a series of terms. \n\nArguments\n\nbsd :: Basis is the basis of the initial state ;\nbsf :: Basis is the basis of the final state. Facultative, the same as bsd by default. \nterms :: Vector{Term} records the terms ; \nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0. Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(op :: Operator, st_d :: Vector{ComplexF64})\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64})","category":"page"},{"location":"core/#Base.:*-Tuple{Operator, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"function *(op :: Operator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: Vector{ComplexF64}\nfunction *(op :: Operator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Vector{Float64}\n\nMeasure the action of an operator on a state. st_d must be of length op.bsd.dim. Returns a vector of length op.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, Operator, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"function *(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: ComplexF64\nfunction *(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, op :: Operator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Float64\n\nMeasuring the inner product between two states and an operator. st_d must be of length op.bsd.dim and st_fp must be of length op.bsf.dim, and st_fp must be an adjoint. \n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Sparse-matrix","page":"Core functions","title":"Sparse matrix","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"OpMat{T}","category":"page"},{"location":"core/#Main.FuzzifiED.OpMat","page":"Core functions","title":"Main.FuzzifiED.OpMat","text":"mutable struct OpMat{ComplexF64}\nmutable struct OpMat{Float64}\n\nThis type stores a sparse matrix in the same form as SparseMatrixCSC in SparseArrays. If the matrix is Hermitian or symmetric, only the lower triangle is stored. \n\nFields\n\ndimd :: Int64 and dimf :: Int64 are the number of columns and rows of the matrix ;\nsymq :: Int64 records whether or not the matrix is Hermitian or symmetric ;\nnel :: Int64 records the number of elements ;\ncolptr :: Vector{Int64}, rowid :: Vector{Int64} and elval :: Vector{ComplexF64} records the elements of the sparse matrix as in the SparseMatrixCSC elements of Julia. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"OpMat(op :: Operator ; type :: DataType = ElementType)","category":"page"},{"location":"core/#Main.FuzzifiED.OpMat-Tuple{Operator}","page":"Core functions","title":"Main.FuzzifiED.OpMat","text":"function OpMat[{type}](op :: Operator ; num_th :: Int64, disp_std :: Bool) :: OpMat{type}\n\nGenerates the sparse matrix from the operator. The parameter type is either Float64 or ComplexF64 ; it is facultative, given by ElementType by default. \n\nArguments\n\nop :: Operator is the operator ;\ntype :: DataType specifies the type of the matrix. It can either be ComplexF64 or Float64. Facultative, the same as ElementType by default\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The lowest eigenstates of the sparse matrix can be calculated by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64 = 1E-8, ncv :: Int64 = max(2 * nst, nst + 10))","category":"page"},{"location":"core/#Main.FuzzifiED.GetEigensystem-Tuple{OpMat{ComplexF64}, Int64}","page":"Core functions","title":"Main.FuzzifiED.GetEigensystem","text":"function GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64, ncv :: Int64 ; num_th :: Int64, disp_std :: Bool) :: Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}\nfunction GetEigensystem(mat :: OpMat{Float64}, nst :: Int64 ; tol :: Float64, ncv :: Int64 ; num_th :: Int64, disp_std :: Bool) :: Tuple{Vector{Float64}, Matrix{Float64}}\n\ncalls the Arpack package to calculate the lowest eigenstates of sparse matrix. \n\nArguments\n\nmat :: OpMat{ComplexF64} is the matrix ;\nnst :: Int64 is the number of eigenstates to be calculated ;\ntol :: Float64 is the tolerence for the Arpack process. The default value is 1E-8 ;\nncv :: Int64 is an auxiliary parameter needed in the Arpack process. The default value is max(2 * nst, nst + 10)\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimd*nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})","category":"page"},{"location":"core/#Base.:*-Tuple{OpMat{ComplexF64}, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"function *(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64} ; num_th :: Int64) :: Vector{ComplexF64}\nfunction *(mat :: OpMat{Float64}, st_d :: Vector{Float64} ; num_th :: Int64) :: Vector{Float64}\n\nMeasure the action of a sparse matrix on a state. st_d must be of length mat.dimd. Returns a vector of length mat.dimf that represents the final state. \n\nFacultative argument\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, OpMat{ComplexF64}, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"function *(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64} ; num_th :: Int64) :: ComplexF64\nfunction *(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, mat :: OpMat{Float64}, st_d :: Vector{Float64} ; num_th :: Int64) :: Float64\n\nMeasuring the inner product between two states and a sparse matrix. st_d must be of length mat.dimd and st_fp must be of length mat.dimf, and st_fp must be an adjoint. \n\nFacultative argument\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Note that sometimes it is needed to transform a state from one basis to another. This can be done by constructing an identity operator. ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"stf = Operator(bsd, bsf, [Term(1., [-1, -1])]) * std","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The OpMat object can be converted into a full matrix or converted with the SparseMatrixCSC object in the SparseArrays package. This will allow, e.g., full diagonalisation using the linear algebra package of julia. ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"SparseMatrixCSCFromOpMat(mat :: OpMat)\nMatrixFromOpMat(mat :: OpMat)\nOpMat(matcsc :: SparseMatrixCSC)","category":"page"},{"location":"core/#Main.FuzzifiED.SparseMatrixCSCFromOpMat-Tuple{OpMat}","page":"Core functions","title":"Main.FuzzifiED.SparseMatrixCSCFromOpMat","text":"SparseMatrixCSCFromOpMat(mat :: OpMat{ComplexF64}) :: SparseMatrixCSC{Int64,ComplexF64}\nSparseMatrixCSCFromOpMat(mat :: OpMat{Float64}) :: SparseMatrixCSC{Int64,Float64}\n\nconverts the OpMat objects to a SparseMatrixCSC object in the SparseArrays package.\n\n\n\n\n\n","category":"method"},{"location":"core/#Main.FuzzifiED.MatrixFromOpMat-Tuple{OpMat}","page":"Core functions","title":"Main.FuzzifiED.MatrixFromOpMat","text":"MatrixFromOpMat(mat :: OpMat{ComplexF64}) :: Matrix{ComplexF64}\nMatrixFromOpMat(mat :: OpMat{Float64}) :: Matrix{Int64,Float64}\n\nconverts the OpMat objects to a full matrix.\n\n\n\n\n\n","category":"method"},{"location":"core/#Main.FuzzifiED.OpMat-Tuple{SparseMatrixCSC}","page":"Core functions","title":"Main.FuzzifiED.OpMat","text":"OpMat(matcsc :: SparseMatrixCSC{Int64,ComplexF64}) :: OpMat{ComplexF64}\nOpMat(matcsc :: SparseMatrixCSC{Int64,Float64}) :: OpMat{Float64}\n\nconverts the SparseMatrixCSC object in the SparseArrays package to an OpMat objects.\n\n\n\n\n\n","category":"method"},{"location":"core/#Entanglement","page":"Core functions","title":"Entanglement","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"StateDecompMat(st :: Vector{<:Number}, bs0 :: Basis, bsa :: Basis, bsb :: Basis, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number})\nGetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{Int64}}} ; qnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} = qnf_a, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2)))","category":"page"},{"location":"core/#Main.FuzzifiED.StateDecompMat-Tuple{Vector{<:Number}, Basis, Basis, Basis, Vector{<:Number}, Vector{<:Number}}","page":"Core functions","title":"Main.FuzzifiED.StateDecompMat","text":"function StateDecompMat(st :: Vector{<:Number}, bs0 :: Basis, bsa :: Basis, bsb :: Basis, amp_oa :: Vector{ComplexF64}, amp_ob :: Vector{ComplexF64}) :: Matrix{ComplexF64}\n\nDecompose a state ψ=v_II into a direct-product basis of two subsystems ψ=M_JII_AJ_B\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: Basis is the total basis. \nbsa :: Basis is the basis for the subsystem A.\nbsb :: Basis is the basis for the subsystem B. \namp_oa :: Vector{ComplexF64} is a complex list of length no that specifies the amplitute of each orbital in the subsystem A. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to ℱ_mA in PRB 85, 125308 (2012) with an extra phase factor. \namp_ob :: Vector{ComplexF64} is a complex list of length no that specifies the amplitute of each orbital in the subsystem B. \n\nOutput\n\nA complex matrix of dimension bsb.dim * bsa.dim that corresponds to the state in the decomposed basis ψ=M_JII_AJ_B. This is equivalent to R_μν^Ap in PRB 85, 125308 (2012). After calculating all the sectors, the reduced density matrix will be ρ_B=mathbfMmathbfM^\n\n\n\n\n\n","category":"method"},{"location":"core/#Main.FuzzifiED.GetEntSpec-Tuple{Vector{<:Number}, Basis, Vector{Vector{Vector{Int64}}}, Vector{Vector{Vector{Int64}}}}","page":"Core functions","title":"Main.FuzzifiED.GetEntSpec","text":"function GetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{<:Number}}} ; qnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} = qnf_a, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2))) :: Dict{@NamedTuple{secd_a, secf_a, secd_b, secf_b}, Vector{Float64}}\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: Basis is the total basis. \nsecd_lst :: Vector{Vector{Vector{Int64}}} gives the list of QNDiag sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nsecf_lst :: Vector{Vector{Vector{ComplexF64}}} gives the list of QNOffd sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nqnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} specifies the diagonal and off-diagonal quantum numbers of the subsystems A and B. qnd_b and qnf_b are facultative and the same as qnd_a and qnf_a by default. \namp_oa :: Vector{ComplexF64} and amp_ob :: Vector{ComplexF64} are complex lists of length no that specify the amplitute of each orbital in the subsystems A and B. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to ℱ_mA in PRB 85, 125308 (2012) with an extra phase factor. \n\nOutput\n\nA dictionary whose keys are named tuples that specify the sector containing entries secd_a, secf_a, secd_b, secf_b and values are lists of eigenvalues of the density matrix in those sectors. \n\n\n\n\n\n","category":"method"},{"location":"core/#File-operations","page":"Core functions","title":"File operations","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"FuzzifiED supports writing the types Confs, Basis, Vector{Term}, Operator, OpMat{ComplexF64} and OpMat{Float64} into and reading them from groups and subgroups in HDF5 format. ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"using HDF5 \nopen(file_name, \"cw\")\n# include the file name as a string \n# Modes : \"cw\" for write and \"r\" for read\n...\nclose(f)","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"To write, include in the middle ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"write(f, group_name :: String, cfs :: Confs)\nwrite(f, group_name :: String, bs  :: Basis)\nwrite(f, group_name :: String, tms :: Vector{Term})\nwrite(f, group_name :: String, op  :: Operator)\nwrite(f, group_name :: String, mat :: OpMat{ComplexF64})\nwrite(f, group_name :: String, mat :: OpMat{Float64})","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"To read, include in the middle ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"cfs = read(f, group_name :: String, Confs)\nbs  = read(f, group_name :: String, Basis)\ntms = read(f, group_name :: String, Vector{Term})\nop  = read(f, group_name :: String, Operator)\nmat = read(f, group_name :: String, OpMat{ComplexF64})\nmat = read(f, group_name :: String, OpMat{Float64})","category":"page"},{"location":"models/#Built-in-models","page":"Built-in models","title":"Built-in models","text":"","category":"section"},{"location":"models/#Diagonal-quantum-numbers-on-fuzzy-sphere","page":"Built-in models","title":"Diagonal quantum numbers on fuzzy sphere","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following diagonal quantum numbers (symmetry charges) on fuzzy sphere are built in in FuzzifiED.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetNeQNDiag(no :: Int64)\nGetLz2QNDiag(nm :: Int64, nf :: Int64)\nGetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Union{Dict{Int64, Int64}, Vector{Int64}}, id :: Int64 = 1, modul :: Int64 = 1)\nGetZnfChargeQNDiag(nm :: Int64, nf :: Int64)\nGetPinOrbQNDiag(no :: Int64, pin_o :: Vector{Int64}, id :: Int64 = 1) ","category":"page"},{"location":"models/#Main.FuzzifiED.GetNeQNDiag-Tuple{Int64}","page":"Built-in models","title":"Main.FuzzifiED.GetNeQNDiag","text":"function GetNeQNDiag(no :: Int64) :: QNDiag\n\nReturn the QNDiag of the number of electrons, implemented as \n\n    QNDiag(\"Ne\", fill(1, no))\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetLz2QNDiag-Tuple{Int64, Int64}","page":"Built-in models","title":"Main.FuzzifiED.GetLz2QNDiag","text":"function GetLz2QNDiag(nm :: Int64, nf :: Int64) :: QNDiag\n\nReturn the QNDiag of the number of twice the angular momentum 2L_z, implemented as \n\n    QNDiag(\"Lz\", collect(0 : nm * nf - 1) .÷ nf .* 2 .- (nm - 1))\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetFlavQNDiag","page":"Built-in models","title":"Main.FuzzifiED.GetFlavQNDiag","text":"function GetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Dict{Int64, Int64}[, id :: Int64 = 1, modul :: Int64 = 1]) :: QNDiag \nfunction GetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Vector{Int64}[, id :: Int64 = 1, modul :: Int64 = 1]) :: QNDiag\n\nReturn the QNDiag of linear combination of number of electrons in each flavour, \n\n    Q = _fq_fn_f\n\nthe factor q_f can either be given by a length-N_f vector or a dictionary containing non-zero terms. E.g., for Q=n_f=1-n_f=3 in a 4-flavour system, qf = [1, 0, -1, 0] or qf = Dict(1 => 1, 3 => -3). id is an index to be put in the name to distinguish. For qf given as vector, the function is implemented as \n\nQNDiag(\"Sz$id\", qf[collect(0 : nm * nf - 1) .% nf .+ 1], modul)\n\n\n\n\n\n","category":"function"},{"location":"models/#Main.FuzzifiED.GetZnfChargeQNDiag-Tuple{Int64, Int64}","page":"Built-in models","title":"Main.FuzzifiED.GetZnfChargeQNDiag","text":"function GetZnfChargeQNDiag(nm :: Int64, nf :: Int64) :: QNDiag\n\nReturn the QNDiag of a ℤ_N_f-charge, \n\n    Q = _f=0^N_f-1fn_f mathrmmod N_f\n\nimplemented as \n\n    QNDiag(\"Q_Z$nf\", collect(0 : nm * nf - 1) .% nf, nf)\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetPinOrbQNDiag","page":"Built-in models","title":"Main.FuzzifiED.GetPinOrbQNDiag","text":"function GetPinOrbQNDiag(no :: Int64, pin_o :: Vector{Int64}[, id :: Int64 = 1]) :: QNDiag\n\nReturn the QNDiag of the number of electrons in the subset pin_o, implemented as\n\n    QNDiag(\"Npin$i\", [ o in pin_o ? 1 : 0 for o = 1 : no])\n\nThis QNDiag is useful in pinning defects, where certain subset of orbitals need to be set empty or filled. To empty the orbitals, set this QNDiag to 0 ; to fill the orbitals, set this QNDiag to length(pin_o). id is an index to be put in the name to distinguish. \n\n\n\n\n\n","category":"function"},{"location":"models/#Off-diagonal-quantum-numbers-on-fuzzy-sphere","page":"Built-in models","title":"Off-diagonal quantum numbers on fuzzy sphere","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following off-diagonal quantum numbers (transformations) on fuzzy sphere are built in in FuzzifiED.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetParityQNOffd(nm :: Int64, nf :: Int64, permf :: Union{Dict{Int64, Int64}, Vector{Vector{Int64}}, Vector{Int64}} = Dict{Int64, Int64}(), fac :: Union{Dict{Int64, <: Number}, Vector{<: Number}} = Dict{Int64, ComplexF64}()) \nGetFlavPermQNOffd(nm :: Int64, nf :: Int64, permf :: Union{Dict{Int64, Int64}, Vector{Vector{Int64}}, Vector{Int64}}, fac :: Union{Dict{Int64, <: Number}, Vector{<: Number}} = Dict{Int64, ComplexF64}())\nGetRotyQNOffd(nm :: Int64, nf :: Int64)","category":"page"},{"location":"models/#Main.FuzzifiED.GetParityQNOffd","page":"Built-in models","title":"Main.FuzzifiED.GetParityQNOffd","text":"function GetParityQNOffd(nm :: Int64, nf :: Int64[, permf, fac])\n\nReturn the particle-hole transformation \n\n    𝒫 c^_mfα_fc_mπ_f\n\nArguments\n\nnm :: Int64 and nf :: Int64 are the number of orbitals and the flavours.\npermf :: Dict{Int64, Int64}, permf :: Vector{Vector{Int64}} or Vector{Int64} gives the flavour permutation π_f. It is either a vector of the cycles, a vector of the target flavours, or a dictionary of the changed elements. E.g., a permutation 142533415662 can be expressed as [4,5,3,1,6,2], [[1,4],[2,5,6]] or Dict(1=>4,2=>5,4=>1,5=>6,6=>2). Facultative, identity by default. \nfac :: Dict{Int64, <: Number} or Vector{<: Number} gives the factor α_f. It is either a vector of all vectors, or a dictionary of all non-unity elements. Facultative, all unity by default. \n\n\n\n\n\n","category":"function"},{"location":"models/#Main.FuzzifiED.GetFlavPermQNOffd","page":"Built-in models","title":"Main.FuzzifiED.GetFlavPermQNOffd","text":"function GetFlavPermQNOffd(nm :: Int64, nf :: Int64, permf , fac][, cyc])\n\nReturn the flavour permutaiton transformation \n\n    𝒵 c^_mfα_fc^_mπ_f\n\nArguments\n\nnm :: Int64 and nf :: Int64 are the number of orbitals and the flavours.\npermf :: Dict{Int64, Int64}, permf :: Vector{Vector{Int64}} or Vector{Int64} gives the flavour permutation π_f. It is either a vector of the cycles, a vector of the target flavours, or a dictionary of the changed elements. E.g., a permutation 142533415662 can be expressed as [4,5,3,1,6,2], [[1,4],[2,5,6]] or Dict(1=>4,2=>5,4=>1,5=>6,6=>2). Facultative, identity by default. \nfac :: Dict{Int64, <: Number} or Vector{<: Number} gives the factor α_f. It is either a vector of all vectors, or a dictionary of all non-unity elements. Facultative, all unity by default. \ncyc :: Int64 is the period of the permutation. \n\n\n\n\n\n","category":"function"},{"location":"models/#Main.FuzzifiED.GetRotyQNOffd-Tuple{Int64, Int64}","page":"Built-in models","title":"Main.FuzzifiED.GetRotyQNOffd","text":"function GetRotyQNOffd(nm :: Int64, nf :: Int64)\n\nReturn the π-rotation along the y-axis. \n\n    ℛ_y c^_mf(-)^m+sc^_-mf\n\n\n\n\n\n","category":"method"},{"location":"models/#Operators-on-fuzzy-sphere","page":"Built-in models","title":"Operators on fuzzy sphere","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetIntMatrix(nm :: Int64, ps_pot :: Vector{Number})\nGetDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf), mat_b :: Matrix{<:Number} = Matrix(mat_a'))\nGetDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mats_a :: Vector{<:AbstractMatrix{<:Number}}, mats_b :: Vector{<:AbstractMatrix{<:Number}} = [Matrix(mat_a') for mat_a in mats_a])\nGetPairIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}, mat_b :: Matrix{<:Number} = Matrix(mat_a'))\nGetPolTerms(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})\nGetL2Terms(nm :: Int64, nf :: Int64)\nGetC2Terms(nm :: Int64, nf :: Int64, mat_gen :: Vector{<:AbstractMatrix{<:Number}})","category":"page"},{"location":"models/#Main.FuzzifiED.GetIntMatrix-Tuple{Int64, Vector{Number}}","page":"Built-in models","title":"Main.FuzzifiED.GetIntMatrix","text":"function GetIntMatrix(nm :: Int64, ps_pot :: Vector{Number}) :: Array{ComplexF64, 3}\n\nArgument\n\nnm :: Int64 is the number of orbitals\nps_pot :: Vector{Number} is the vector of non-zero pseudopotentials \n\nOutput\n\nA nm*nm*nm array giving the interaction matrix U_m_1m_2m_3-m_1-m_2-m_3\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetDenIntTerms","page":"Built-in models","title":"Main.FuzzifiED.GetDenIntTerms","text":"GetDenIntTerms(nm :: Int64, nf :: Int64[, ps_pot :: Vector{<:Number}][, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}]][ ; m_kept :: Vector{Int64}]) :: Vector{Term}\n\nReturn the normal-ordered density-density term in the Hamiltonian \n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_4M^B_f_2f_3c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultative, [1.0] by default. \nmat_a :: Matrix{<:Number} is a nf*nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nf*nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#Main.FuzzifiED.GetDenIntTerms-2","page":"Built-in models","title":"Main.FuzzifiED.GetDenIntTerms","text":"GetDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Vector{<:AbstractMatrix{<:Number}}[, mat_b :: Vector{<:AbstractMatrix{<:Number}}][ ; m_kept :: Vector{Int64}]) :: Vector{Term}\n\nReturn the sum of a series of normal-ordered density-density term in the Hamiltonian \n\n_m_if_iαU_m_1m_2m_3m_4(M^A_α)_f_1f_4(M^B_α)_f_2f_3c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultative, [1.0] by default.\nmat_a :: Vector{<:AbstractMatrix{<:Number}} is a vector of nf*nf matrix specifying (M^A_α)_ff. Facultative, I_N_f by default. \nmat_b :: Vector{<:AbstractMatrix{<:Number}} is a vector of nf*nf matrix specifying (M^B_α)_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#Main.FuzzifiED.GetPairIntTerms","page":"Built-in models","title":"Main.FuzzifiED.GetPairIntTerms","text":"GetPairIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}][ ; m_kept :: Vector{Int64}]) :: Vector{Term}\n\nReturn the normal-ordered pair-pair interaction term in the Hamiltonian \n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_2M^B_f_3f_4c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. \nmat_a :: Matrix{<:Number} is a nf*nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nf*nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#Main.FuzzifiED.GetPolTerms-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"Main.FuzzifiED.GetPolTerms","text":"GetPolTerms(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}][ ; fld_m :: Vector{<:Number}]) :: Vector{Term}\n\nReturn the polarisation term in the Hamiltonian \n\n_mffc^_mfM_ffc_mf\n\nArguments\n\nnm :: Int64 is the number of orbitals ;\nnf :: Int64 is the number of flavours ; \nmat :: Matrix{<:Number} is a nf*nf matrix specifying M_ff. Facultative, I_N_f by default. \nfld_m :: Vector{<:Number} gives an orbital dependent polarisation\n\n_mffh_mc^_mfM_ffc_mf\n\nFacultative. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetL2Terms-Tuple{Int64, Int64}","page":"Built-in models","title":"Main.FuzzifiED.GetL2Terms","text":"function GetL2Terms(nm :: Int64, nf :: Int64) :: Vector{Term}\n\nReturn the terms for the total angular momentum.\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetC2Terms-Tuple{Int64, Int64, Vector{<:AbstractMatrix{<:Number}}}","page":"Built-in models","title":"Main.FuzzifiED.GetC2Terms","text":"function GetC2Terms(nm :: Int64, nf :: Int64, mat_gen :: Vector{<:AbstractMatrix{<:Number}}) :: Vector{Term}\n\nReturn the terms for the quadratic Casimir of the flavour symmetry\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nmat_gen :: Vector{Matrix{Number}}) is a list of the matrices that gives the generators. It will automatically be normalised such that its square traces to unity. \n\n\n\n\n\n","category":"method"},{"location":"models/#Spherical-observables","page":"Built-in models","title":"Spherical observables","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"FuzzifiED supports local observables on sphere that can be decomposed into angular components Phi(Omega)=sum_lmPhi_lmY^(s)_lm","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"SphereObs","category":"page"},{"location":"models/#Main.FuzzifiED.SphereObs","page":"Built-in models","title":"Main.FuzzifiED.SphereObs","text":"mutable struct SphereObs\n\nstores the information of a local observable (or local operator) Phi that can be decomposed into angular components.\n\n    Phi(Omega)=_lmPhi_lmY^(s)_lm\n\nFields\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Vector{Term} that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the observable is stored.\ncomps :: Dict{Tuple{Int64, Int64}, Vector{Term}} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"type"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"It can be initialised with the following methods ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function)\nSphereObs(s2 :: Int64, l2m :: Int64, cmps :: Dict{Tuple{Int64, Int64}, Vector{Term}})","category":"page"},{"location":"models/#Main.FuzzifiED.SphereObs-Tuple{Int64, Int64, Function}","page":"Built-in models","title":"Main.FuzzifiED.SphereObs","text":"function SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SphereObs\n\ninitialises the observable from 2s, 2l_max and the function (lm)Phi_lm\n\nArguments\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Vector{Term} that sends the component specified by a tuple of integers (2l2m) where sleq sleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.SphereObs-Tuple{Int64, Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}","page":"Built-in models","title":"Main.FuzzifiED.SphereObs","text":"function SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SphereObs\n\ninitialises the observable from 2s, 2l_max and a list of Phi_lm specified by a dictionary. \n\nArguments\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \ncomps :: Dict{Tuple{Int64, Int64}, Vector{Term}} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following methods explicitly calculates and stores each component","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"StoreComps!(obs :: SphereObs)\nStoreComps(obs :: SphereObs)","category":"page"},{"location":"models/#Main.FuzzifiED.StoreComps!-Tuple{SphereObs}","page":"Built-in models","title":"Main.FuzzifiED.StoreComps!","text":"function StoreComps!(obs :: SphereObs) :: Nothing\n\ncalculates and stores each component of the observable obs and replace the function in obs by the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.StoreComps-Tuple{SphereObs}","page":"Built-in models","title":"Main.FuzzifiED.StoreComps","text":"function StoreComps(obs :: SphereObs) :: SphereObs\n\ncalculates and stores each component of the observable obs and return a new observable with the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The multiplication, addition, conjugate and Laplacian operation of an observable is supported ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"*(fac :: Number, obs :: SphereObs) \n+(obs1 :: SphereObs, obs2 :: SphereObs) \nadjoint(obs :: SphereObs)\n*(obs1 :: SphereObs, obs2 :: SphereObs)\nLaplacian(obs :: SphereObs)","category":"page"},{"location":"models/#Base.:*-Tuple{Number, SphereObs}","page":"Built-in models","title":"Base.:*","text":"function *(fac :: Number, obs :: SphereObs) :: SphereObs\nfunction *(obs :: SphereObs, fac :: Number) :: SphereObs\nfunction /(obs :: SphereObs, fac :: Number) :: SphereObs\nfunction -(obs :: SphereObs) :: SphereObs\n\nenables the multiplication of an observable with a number.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:+-Tuple{SphereObs, SphereObs}","page":"Built-in models","title":"Base.:+","text":"function +(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\nfunction -(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n\nenables the addition of two observables.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.adjoint-Tuple{SphereObs}","page":"Built-in models","title":"Base.adjoint","text":"function adjoint(obs :: SphereObs) :: SphereObs\n\nenables the Hermitian conjugate of a spherical observable.\n\nbeginaligned\n    Φ^(Ω)=_lm(Φ_lm)^barY^(s)_lm(Ω)=_lm(Φ_lm)^(-1)^s+mY^(-s)_l-m(Ω)\n    (Φ^)_lm=(-1)^s-m(Φ_l-m)^\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:*-Tuple{SphereObs, SphereObs}","page":"Built-in models","title":"Base.:*","text":"function *(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n\nenables the multiplication of two observable by making use of the composition of two monopole harmonics into one. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.Laplacian-Tuple{SphereObs}","page":"Built-in models","title":"Main.FuzzifiED.Laplacian","text":"function Laplacian(obs :: SphereObs) :: SphereObs\n\nTakes the Laplacian of an observable\n\n    (^2Φ)_lm=-l(l+1)Φ_lm\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The observables can be evaluated either at an angular component or at a real-space point.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetComponent(obs :: SphereObs, l :: Number, m :: Number)\nGetPointValue(obs :: SphereObs, θ :: Float64, ϕ :: Float64)","category":"page"},{"location":"models/#Main.FuzzifiED.GetComponent-Tuple{SphereObs, Number, Number}","page":"Built-in models","title":"Main.FuzzifiED.GetComponent","text":"function GetComponent(obs :: SphereObs, l :: Number, m :: Number) :: Vector{Term}\n\nreturns an angular component Φ_lm of an observable in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetPointValue-Tuple{SphereObs, Float64, Float64}","page":"Built-in models","title":"Main.FuzzifiED.GetPointValue","text":"function GetPointValue(obs :: SphereObs, θ :: Float64, ϕ :: Float64) :: Vector{Term}\n\nevaluates an observable at one point Φ(θϕ) in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"Three types of operators, viz. electrons and density operators, and pairing operators are built-in.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"Electron(nm :: Int64, nf :: Int64, f :: Int64)\nDensity(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})\nPairing(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})","category":"page"},{"location":"models/#Main.FuzzifiED.Electron-Tuple{Int64, Int64, Int64}","page":"Built-in models","title":"Main.FuzzifiED.Electron","text":"function Electron(nm :: Int64, nf :: Int64, f :: Int64) :: SphereObs\n\nreturns the electron annihilation operator ψ_f\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nf :: Int64 is the index of the orbital to be taken.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.Density-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"Main.FuzzifiED.Density","text":"function Density(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}]) :: SphereObs\n\nreturns the density operator n=_ffψ^_fM_ffψ_f\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff. Facultative, identity matrix mathbbI by default.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.Pairing-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"Main.FuzzifiED.Pairing","text":"function Pairing(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: SphereObs\n\nreturns the pair operator Δ=_ffψ_fM_ffψ_f\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff.\n\n\n\n\n\n","category":"method"},{"location":"models/#Angular-modes","page":"Built-in models","title":"Angular modes","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"An angular modes object is similar to spherical observables except that it superposes in the rule of Clebsch-Gordan coefficients and does not have the notion of locality.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"AngModes","category":"page"},{"location":"models/#Main.FuzzifiED.AngModes","page":"Built-in models","title":"Main.FuzzifiED.AngModes","text":"mutable struct AngModes\n\nis an object that stores angular momentum components of an operator on the sphere Φ_lm and superposes in the rule of Clebsch-Gordan coefficients. The usage is similar to the spherical observables, except that SphereObs superposes in the rule of spherical harmonics and has the notion of locality\n\nFields\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Vector{Term} that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the modes object is stored.\ncomps :: Dict{Tuple{Int64, Int64}, Vector{Term}} stores each component of the modes object in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"type"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"It can be initialised with the following methods ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"AngModes(l2m :: Int64, get_comp :: Function)\nAngModes(l2m :: Int64, cmps :: Dict{Tuple{Int64, Int64}, Vector{Term}})","category":"page"},{"location":"models/#Main.FuzzifiED.AngModes-Tuple{Int64, Function}","page":"Built-in models","title":"Main.FuzzifiED.AngModes","text":"function AngModes(l2m :: Int64, get_comp :: Function) :: AngModes\n\ninitialises the modes object from 2s, 2l_max and the function (lm)Phi_lm\n\nArguments\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Vector{Term} that sends the component specified by a tuple of integers (2l2m) where sleq sleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.AngModes-Tuple{Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}","page":"Built-in models","title":"Main.FuzzifiED.AngModes","text":"function AngModes(l2m :: Int64, get_comp :: Function) :: AngModes\n\ninitialises the modes object from 2s, 2l_max and a list of Phi_lm specified by a dictionary. \n\nArguments\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \ncomps :: Dict{Tuple{Int64, Int64}, Vector{Term}} stores each component of the modes object in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following methods explicitly calculates and stores each component","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"StoreComps!(amd :: AngModes)\nStoreComps(amd :: AngModes)","category":"page"},{"location":"models/#Main.FuzzifiED.StoreComps!-Tuple{AngModes}","page":"Built-in models","title":"Main.FuzzifiED.StoreComps!","text":"function StoreComps!(amd :: AngModes) :: Nothing\n\ncalculates and stores each component of the modes object amd and replace the function in amd by the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.StoreComps-Tuple{AngModes}","page":"Built-in models","title":"Main.FuzzifiED.StoreComps","text":"function StoreComps(amd :: AngModes) :: AngModes\n\ncalculates and stores each component of the modes object amd and return a new modes object with the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The multiplication, addition and conjugate of an observable is supported ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"*(fac :: Number, amd :: AngModes) \n+(obs1 :: AngModes, obs2 :: AngModes) \nadjoint(amd :: AngModes)\n*(obs1 :: AngModes, obs2 :: AngModes)","category":"page"},{"location":"models/#Base.:*-Tuple{Number, AngModes}","page":"Built-in models","title":"Base.:*","text":"function *(fac :: Number, amd :: AngModes) :: AngModes\nfunction *(amd :: AngModes, fac :: Number) :: AngModes\nfunction /(amd :: AngModes, fac :: Number) :: AngModes\nfunction -(amd :: AngModes) :: AngModes\n\nenables the multiplication of a mode with a number.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:+-Tuple{AngModes, AngModes}","page":"Built-in models","title":"Base.:+","text":"function +(obs1 :: AngModes, obs2 :: AngModes) :: AngModes\nfunction -(obs1 :: AngModes, obs2 :: AngModes) :: AngModes\n\nenables the addition of two modes.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.adjoint-Tuple{AngModes}","page":"Built-in models","title":"Base.adjoint","text":"function adjoint(amd :: AngModes) :: AngModes\n\nenables the Hermitian conjugate of a spherical mode.\n\nbeginaligned\n    (Φ^)_lm=(-1)^l+m(Φ_l-m)^\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:*-Tuple{AngModes, AngModes}","page":"Built-in models","title":"Base.:*","text":"function *(obs1 :: AngModes, obs2 :: AngModes) :: AngModes\n\nenables the multiplication of two modes in the rule of CG coefficients. \n\n    Φ_lm=_l_1l_2m_1m_2δ_mm_1+m_2l_1m_1l_2m_2lmΦ_l_1m_1Φ_l_2m_2\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"One can take out either one or a set of components","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetComponent(amd :: AngModes, l :: Number, m :: Number)\nFilterL2(amd :: AngModes, l :: Number) \nFilterComponent(amd :: AngModes, flt) ","category":"page"},{"location":"models/#Main.FuzzifiED.GetComponent-Tuple{AngModes, Number, Number}","page":"Built-in models","title":"Main.FuzzifiED.GetComponent","text":"function GetComponent(amd :: AngModes, l :: Number, m :: Number) :: Vector{Term}\n\nreturns an angular component Φ_lm of a modes object in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.FilterL2-Tuple{AngModes, Number}","page":"Built-in models","title":"Main.FuzzifiED.FilterL2","text":"function FilterL2(amd :: AngModes, l :: Number) :: AngModes\n\nreturns an angular modes object with modes of a certain total angular momentum filtered out.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.FilterComponent-Tuple{AngModes, Any}","page":"Built-in models","title":"Main.FuzzifiED.FilterComponent","text":"function FilterComponent(amd :: AngModes, flt) :: AngModes\n\nreturns an angular modes object with certain modes filtered out.\n\nArguments\n\namd  AngModes is the original angular modes\nflt is the filter function whose input is the pair (lm) and output is a logical that indicates whether this mode is chosen. E.g., if one wants to filter out the modes with angular momentum l0, one should put (l, m) -> l == l0.\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"Three types of operators, viz. electrons and density operators, and pairing operators are built-in.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"ElecMod(nm :: Int64, nf :: Int64, f :: Int64)\nPairMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})\nDenMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})","category":"page"},{"location":"models/#Main.FuzzifiED.ElecMod-Tuple{Int64, Int64, Int64}","page":"Built-in models","title":"Main.FuzzifiED.ElecMod","text":"function ElecMod(nm :: Int64, nf :: Int64, f :: Int64) :: AngModes\n\nreturns the modes of electron annihilation operator c_m, with angular momentum s=(N_m-1)2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nf :: Int64 is the index of the orbital to be taken.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.PairMod-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"Main.FuzzifiED.PairMod","text":"function PairMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: AngModes\n\nreturns the modes of two electrons superposed in the rule of CG coefficients. \n\n    Δ_lm=_m_1m_2δ_mm_1+m_2sm_1sm_2lmc_am_1M_abc_bm_2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.DenMod-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"Main.FuzzifiED.DenMod","text":"function DenMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: AngModes\n\nreturns the modes of electron creation and annihilation superposed in the rule of CG coefficients. \n\n    n_lm=_m_1m_2δ_m-m_1+m_2(-1)^s+m_1s(-m_1)sm_2lmc^_m_1c_m_2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff. Facultative, identity matrix mathbbI by default.\n\n\n\n\n\n","category":"method"},{"location":"releases/#Release-notes","page":"Releases","title":"Release notes","text":"","category":"section"},{"location":"releases/#September-2024","page":"Releases","title":"September 2024","text":"","category":"section"},{"location":"releases/#11-September,-2024-(Version-0.9.0)","page":"Releases","title":"11 September, 2024 (Version 0.9.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add feature of angular modes observables.\nFix typos and bugs.","category":"page"},{"location":"releases/#July-2024","page":"Releases","title":"July 2024","text":"","category":"section"},{"location":"releases/#28-July,-2024-(Version-0.8.2)","page":"Releases","title":"28 July, 2024 (Version 0.8.2)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Fix bugs in GetDenIntTerms and multiplication in SphereObs. ","category":"page"},{"location":"releases/#26-July,-2024-(Version-0.8.0)","page":"Releases","title":"26 July, 2024 (Version 0.8.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Improve the performance of SimplifyTerms. \nAdd file operation. ","category":"page"},{"location":"releases/#24-July,-2024-(Version-0.7.2)","page":"Releases","title":"24 July, 2024 (Version 0.7.2)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add example and support for surface CFTs. \nAdd example of Ising cusp.","category":"page"},{"location":"releases/#June-2024","page":"Releases","title":"June 2024","text":"","category":"section"},{"location":"releases/#11-June,-2024-(Version-0.7.1)","page":"Releases","title":"11 June, 2024 (Version 0.7.1)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add some new interfaces for built-in operators. \nAdd new examples. \nFix bugs","category":"page"},{"location":"releases/#9-June,-2024-(Version-0.7.0)","page":"Releases","title":"9 June, 2024 (Version 0.7.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Revise the implementation of diagonal and off-diagonal quantum number. ","category":"page"},{"location":"releases/#8-June,-2024-(Version-0.6.3)","page":"Releases","title":"8 June, 2024 (Version 0.6.3)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for calculating entanglement spectrum. \nAdd global parameters to control the number of threads, the output and the path of the dynamic library. \nFix bugs. ","category":"page"},{"location":"releases/#5-June,-2024-(Version-0.6.0)","page":"Releases","title":"5 June, 2024 (Version 0.6.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for full diagonalisation. \nFix bugs and typos.\nReady for formal release !","category":"page"},{"location":"releases/#3-June,-2024-(Version-0.5.8)","page":"Releases","title":"3 June, 2024 (Version 0.5.8)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Change the binary dependence to Julia Binary Builder. ","category":"page"},{"location":"releases/#May-2024","page":"Releases","title":"May 2024","text":"","category":"section"},{"location":"releases/#30-May,-2024-(Version-0.5.0)","page":"Releases","title":"30 May, 2024 (Version 0.5.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Enable simplification of terms.\nAdd general observables and built-in electrons and density operators. \nReorganise the realisations of built-in models.\nCancel ITensorMPOConstruction dependence. ","category":"page"},{"location":"releases/#29-May,-2024-(Version-0.4.3)","page":"Releases","title":"29 May, 2024 (Version 0.4.3)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add QNU truncation for ITensors use.\nChange the Fortran code to be robust against QNU breaking terms\nAdd built-in density-density interaction. \nAdd built-in 3-state Potts model.\nAdd built-in Ising model with magnetic line defect. ","category":"page"},{"location":"releases/#28-May,-2024-(Version-0.4.0)","page":"Releases","title":"28 May, 2024 (Version 0.4.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for DMRG.\nAdd convertion from diagonal QNs to sites. \nAdd the support of mathbbZ_n diagonal quantum numbers in Confs.\nMerge the submodules to the main package. \nAdd Ising model in X basis.  \nAdd functions in built-in models to export diagonal QNs. ","category":"page"},{"location":"releases/#27-May,-2024-(Version-0.3.0)","page":"Releases","title":"27 May, 2024 (Version 0.3.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add the support for Hamiltonians with real elements. \nAdd conversion with SparseMatrixCSC. \nAdd the conversion from terms to OpSum.\nAdd the look-up of configurations. \nFor the built-in Ising model, add density operator.\nAdd built-in mathrmSp(N) model. ","category":"page"},{"location":"releases/#26-May,-2024-(Version-0.2.0)","page":"Releases","title":"26 May, 2024 (Version 0.2.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add operations of terms.\nAdd built-in Ising model. ","category":"page"},{"location":"#FuzzifiED.jl","page":"Home","title":"FuzzifiED.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package FuzzifiED is designed to do exact diagonalisation (ED) calculation on the fuzzy sphere, and also facilitates the DMRG calculations by ITensors. It can also be used for generic fermion models. Using this package, you can reproduce almost all the ED results in fuzzy sphere works ; for detail, see « The fuzzified world ».","category":"page"},{"location":"","page":"Home","title":"Home","text":"If this package is helpful in your research, we would appreciate it if you mention in the acknowledgement. If you have any questions, please contact Zheng Zhou (周正) at zzhou@pitp.ca.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, please first enter Julia by entering in the command line julia, and then enter the commands","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg ;\nPkg.add(url=\"https://github.com/mankai-chow/FuzzifiED_jll.jl.git\") ;\nPkg.add(url=\"https://github.com/mankai-chow/FuzzifiED.jl.git\") ;","category":"page"},{"location":"","page":"Home","title":"Home","text":"Include at the start of your Julia script","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FuzzifiED","category":"page"},{"location":"#Tips","page":"Home","title":"Tips","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download Julia at this link. \nTo Apple Silicon (Mac M1, M2, etc.) users : The support for AArch64 architecture is not guarenteed. You may want to use Julia for x86 (Intel or Rosetta) instead of macOS (Apple Silicon).\nJupyter Notebook is highly recommended as it allows you to run Julia (and Python) just like running a Mathematica notebook. N.b., you may need to install the package IJulia by hand to use Jupyter notebook ; in Jupyter notebooks, you may need to define how many threads OpenMP uses by hand in FuzzifiED.NumThreads \nWe are currently trying to train our own GPT « Getting FuzzifiED », but the performance is not ideal. Please help us out. \nThe package is under active development, so certain interfaces may get changed, superceded or obsolete. We are sorry for any possible inconvenience. ","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"example.md\",\n    \"core.md\",\n    \"itensors.md\",\n    \"models.md\",\n    \"archieve.md\"\n]\nDepth = 2","category":"page"},{"location":"#What-is-new-(0.9.0)","page":"Home","title":"What is new (0.9.0)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Add angular modes observables.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a more detailed summary of the background, please visit « The fuzzified world »","category":"page"},{"location":"","page":"Home","title":"Home","text":"Uncovering Conformal Symmetry in the 3D Ising Transition: State-Operator Correspondence from a Quantum Fuzzy Sphere Regularization, Wei Zhu, Chao Han, Emilie Huffman, Johannes S. Hofmann, and Yin-Chen He, Phys. Rev. X 13, 021009 (2023).\nOperator Product Expansion Coefficients of the 3D Ising Criticality via Quantum Fuzzy Sphere, Liangdong Hu, Yin-Chen He, and Wei Zhu, Phys. Rev. Lett 131, 031601 (2023).\nConformal four-point correlators of the 3D Ising transition via the quantum fuzzy sphere, Chao Han, Liangdong Hu, Wei Zhu, and Yin-Chen He, Phys. Rev. B 108, 235123 (2023).\nThe mathrmSO(5) Deconfined Phase Transition under the Fuzzy Sphere Microscope: Approximate Conformal Symmetry, Pseudo-Criticality, and Operator Spectrum, Zheng Zhou, Liangdong Hu, Wei Zhu, and Yin-Chen He, Phys. Rev. X 14, 021044 (2024).\nSolving Conformal Defects in 3D Conformal Field Theory using Fuzzy Sphere Regularization, Liangdong Hu, Yin-Chen He, and Wei Zhu, Nat. Commun. 15, 3659 (2024).\nQuantum Monte Carlo Simulation of the 3D Ising Transition on the Fuzzy Sphere, October 2023. Quantum Monte Carlo Simulation of the 3D Ising Transition on the Fuzzy Sphere, Johannes S. Hofmann, Florian Goth, Wei Zhu, Yin-Chen He, and Emilie Huffman, arXiv : 2310.19880.\nConformal Operator Content of the Wilson-Fisher Transition on Fuzzy Sphere Bilayers, Chao Han, Liangdong Hu, and W. Zhu, arXiv : 2312.04047.\nThe g-function and Defect Changing Operators from Wavefunction Overlap on a Fuzzy Sphere, Zheng Zhou, Davide Gaiotto, Yin-Chen He, Yijian Zou, SciPost Phys. 17, 021 (2024).\nEntropic F-function of 3D Ising conformal field theory via the fuzzy sphere regularization, Liangdong Hu, W. Zhu, and Yin-Chen He, arXiv : 2401.17362.\nImpurities with a cusp: general theory and 3d Ising, Gabriel Cuomo, Yin-Chen He, Zohar Komargodski, arXiv : 2406.10186. \nStudying the 3d Ising surface CFTs on the fuzzy sphere, Zheng Zhou, and Yijian Zou, arXiv : 2407.15914.\nIsing BCFTs from the fuzzy hemisphere, Mykola Dedushenko, arXiv : 2407.15948.\nConstructing the Infrared Conformal Generators on the Fuzzy Sphere, Giulia Fardelli, A. Liam Fitzpatrick and Emanuel Katz, arXiv : 2409.02998.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"core.md\",\n    \"itensors.md\",\n    \"models.md\",\n    \"archieve.md\"\n]","category":"page"},{"location":"example/#FuzzifiED-explained-in-an-example","page":"Example","title":"FuzzifiED explained in an example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"In this example, we will illustrate how to use FuzzifiED to calculate the spectrum of Ising model on fuzzy sphere and how to calculate the OPE coefficient lambda_sigmasigmaepsilon by measuring the expectation value of the density operator n^z. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The examples can be found in the directory examples. Two versions of this example is provided. The first uses the built-in functions for quantum numbers and operators to calculate the observables and is stored in tutorial_ising.jl. The second does not use the built-in example and is stored in tutorial_ising_primitive.jl. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In addition, an example of how FuzzifiED can facilitate DMRG calculation is given. The example contains two versions. The first uses MPO and dmrg functions of the ITensors package and is stored in tutorial_ising_dmrg.jl. The second uses the EasySweep function in the package which further wraps the dmrg function to facilitate the management of sweeps and is stored in tutorial_ising_dmrg_easysweep.jl. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We also append in the end a list of given examples at the end of the page.","category":"page"},{"location":"example/#Exact-diagonalisation-with-FuzzifiED","page":"Example","title":"Exact diagonalisation with FuzzifiED","text":"","category":"section"},{"location":"example/#Implement-the-diagonal-quantum-numbers-and-generate-the-configurations","page":"Example","title":"Implement the diagonal quantum numbers and generate the configurations","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"FuzzifiED supports mathrmU(1) diagonal quantum numbers (QNDiag) ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Q_i=sum_o=1^N_oq_ion_o","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"or mathbbZ_n diagonal quantum numbers with period P_i","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Q_i=sum_o=1^N_oq_ion_o mathrmmod P_i","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where i=1dotsN_U is the index of diagonal quantum numbers, o is the index of orbital, n_o=c^dagger_oc_o, and q_o is a set of coefficients that must be integer-valued. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"There are two diagonal quantum numbers in the Ising model, viz. the particle number and the angular momentum","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"beginaligned\nQ_1=N_e q_1msigma=1\nQ_2=2L_zq_2msigma=2m\nendaligned","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where the orbital index o contains both m and sigma. In the code, we store the orbitals with the same m together, viz. we store the spin-up orbitals in odd o=13dots2N_m-1 and the spin-down orbitals in even o=24dots2N_m. We look at the L_z=0 half-filled sector. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"These two diagonal quantum numbers are built in with functions GetNeQNDiag and GetLz2QNDiag and the configurations can be generated with function Confs. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Inputing the basic setups\nnm = 12\nqnd = [ \n    GetNeQNDiag(2 * nm), \n    GetLz2QNDiag(nm, 2) \n]\ncfs = Confs(2 * nm, [nm, 0], qnd)","category":"page"},{"location":"example/#Primitive-version","page":"Example","title":"Primitive version","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Alternatively, you can put in the diagonal quantum numbers QNDiag by hand by specifying the symmetry charges q_o of the orbitals, and facultatively the name and the modulus","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"nf = 2\nnm = 8\nno = nf * nm\ns = .5 * (nm - 1)\nne = div(no, 2)\n# Record the QNDiag\nqnd = [ \n    # Number of electrons Ne\n    QNDiag(fill(1, no)), \n    # Twice angular momentum 2Lz\n    QNDiag([ (o - 1) ÷ nf * 2 - (nm - 1) for o = 1 : no ])\n]\ncfs = Confs(no, [ne, 0], qnd)","category":"page"},{"location":"example/#Implement-the-off-diagonal-\\mathbb{Z}_p-symmetries-and-initialise-the-basis","page":"Example","title":"Implement the off-diagonal mathbbZ_p symmetries and initialise the basis","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"FuzzifiED supports off diagonal discrete mathbbZ_p symmetries in the form of ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"mathscrZ c_oto alpha_o^* c^(p_o)_pi_oquad c_o^daggerto alpha_o c^(1-p_o)_pi_o","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where we use a notation c^(1)=c^dagger and c^0=c for convenience, where pi_o is a permutation of 1dots N_o, alpha_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the orbital. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal quantum numbers. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"After implementing these symmetries, a state in the new basis should look like ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Irangle=lambda_i_I1i_I1rangle+lambda_i_I2i_I2rangle+cdots+lambda_i_Im_Ii_Im_Irangle","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where the irangle's are configurations in the Confs generated in the last section. The Irangle is a linear combination, and can be regarded as a grouping of m_I configurations.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The function used to implement the discrete symmetries is Basis. There are three mathbbZ_2 transformations in the Ising model, viz. the particle-hole transformation mathscrP, the pi-rotation along the y-axis mathscrR_y and the flavour (Ising) symmetry mathscrZ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"beginaligned\n    mathscrPc^dagger_sigma mtosigma c_-sigmam\n    mathscrZc^dagger_sigma mto c^dagger_-sigmam\n    mathscrR_yc^dagger_sigma mto c^dagger_sigma-m\nendaligned","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"These three symmetries are built in with functions GetParityQNOffd, GetFlavPermQNOffd and GetRotyQNOffd. Thus, if we want to look at the all-positive sector","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"qnf = [ \n    GetParityQNOffd(nm, 2, [2, 1], [-1, 1]), \n    GetFlavPermQNOffd(nm, 2, [2, 1]), \n    GetRotyQNOffd(nm, 2) \n]\nbs = Basis(cfs, [1, 1, 1], qnf)\n# The second argument gives the eigenvalues under the transformations, for Z_2 put 1,-1 ; for Z_n put exp(2im*pi*q/p)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"If no discrete symmetry is needed, one can simply put instead bs = Basis(conf)","category":"page"},{"location":"example/#Primitive-version-2","page":"Example","title":"Primitive version","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Alternatively, you can put in the diagonal quantum numbers QNOffd by hand by specifying the permutations pi_o of the orbitals, and facultatively the particle-hole transformation p_o, the factor alpha_o and the cycle. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Record a QNOffd by orbital permutation (and facultatives particle-hole, factor, cycle)\nqnf = [ \n    # Parity (Particle-hole)\n    QNOffd([ isodd(o) ? o + 1 : o - 1 for o = 1 : no], true, ComplexF64[ isodd(o) ? -1 : 1 for o = 1 : no]),\n    # Flavour symmetry\n    QNOffd([ isodd(o) ? o + 1 : o - 1 for o = 1 : no]),\n    # Y-axis pi-rotation\n    QNOffd([ isodd(o) ? no - o : no + 2 - o for o = 1 : no], ComplexF64(-1) .^ (collect(0 : nm * nf - 1) .÷ nf))\n]\nbs = Basis(cfs, [1, 1, 1], qnf) ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Please refer to the documenation if you want to implement mathbbZ_n2 symmetries. ","category":"page"},{"location":"example/#Record-the-Hamiltonian-terms","page":"Example","title":"Record the Hamiltonian terms","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The operators in the form of the sum of product of c and c^dagger's are supported ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Phi=sum_t=1^N_tU_tc^(p_t1)_o_t1c^(p_t2)_o_t2dots c^(p_tl)_o_tl","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where c^(0)=c and c^(1)=c^dagger. Here the operator string sum is recorded together with the basis of the initial state and the basis of the final state. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The Hamiltonian for the fuzzy sphere Ising model","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"H=sum_m_1m_2m_3m_4U_m_1m_2m_3m_4delta_m_1+m_2m_3+m_4c^dagger_m_1uparrowc^dagger_m_2downarrowc_m_3downarrowc_m_4uparrow-hsum_m(c^dagger_muparrowc_mdownarrow+mathrmhc)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"can be recorded as the sum of a density-density interaction and a polarisation term, which are built-in with the functions GetDenIntTerms and GetPolTerms. We then use Operator function to record it together with its basis. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"const σ1 = [  1  0 ;  0  0 ]\nconst σ2 = [  0  0 ;  0  1 ]\nconst σx = [  0  1 ;  1  0 ]\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, 2 .* [4.75, 1.], σ1, σ2) - \n    3.16 * GetPolTerms(nm, 2, σx) )\nhmt = Operator(bs, tms_hmt)","category":"page"},{"location":"example/#Primitive-version-3","page":"Example","title":"Primitive version","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"using WignerSymbols\n# Input the parameters of the Hamiltonian\nps_pot = [ 4.75, 1. ] * 2.\nh = 3.16\ntms_hmt = Vector{Term}(undef, 0)\n# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3\nfor m1 = 0 : nm - 1\n    f1 = 0\n    o1 = m1 * nf + f1 + 1\n    m1r = m1 - s\n    for m2 = 0 : nm - 1\n        f2 = 1\n        o2 = m2 * nf + f2 + 1\n        m2r = m2 - s\n        for m3 = 0 : nm - 1\n            f3 = 1\n            o3 = m3 * nf + f3 + 1\n            m3r = m3 - s\n            m4 = m1 + m2 - m3 \n            if (m4 < 0 || m4 >= nm) continue end\n            f4 = 0\n            o4 = m4 * nf + f4 + 1\n            m4r = m4 - s\n            # Calculate the matrix element val from pseudopotentials\n            val = ComplexF64(0)\n            for l in eachindex(ps_pot)\n                if (abs(m1r + m2r) > nm - l || abs(m3r + m4r) > nm - l) break end \n                val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, m1r, m2r, -m1r - m2r) * wigner3j(s, s, nm - l, m4r, m3r, -m3r - m4r)\n            end \n            # Record the interaction term val, \"Cdag\", o1, \"Cdag\", o2, \"C\", o3, \"C\", o4\n            push!(tms_hmt, Term(val, [1, o1, 1, o2, 0, o3, 0, o4]))\n        end\n    end\n    o1x = o1 + 1\n    # Record the transverse field term\n    push!(tms_hmt, Term(-h, [1, o1, 0, o1x]))\n    push!(tms_hmt, Term(-h, [1, o1x, 0, o1]))\nend\n# Generate the Hamiltonian operator\nhmt = Operator(bs, tms_hmt)","category":"page"},{"location":"example/#Generate-the-sparse-matrix-and-diagonalise","page":"Example","title":"Generate the sparse matrix and diagonalise","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"After specifying the Hamiltonian, we then use Operator to record also the basis and use OpMat to generate a sparse matrix from the operator. To get the 10 lowest eigenstates and their energies","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"hmt = Operator(bs, tms_hmt)\nhmt_mat = OpMat(hmt)\nenrg, st = GetEigensystem(hmt_mat, 10)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Matrices with real elements can be generated by specifying OpMat{Float64}(hmt) or setting FuzzifiED.ElementType = Float64. ","category":"page"},{"location":"example/#Write-the-sparse-matrix-into-HDF5-file","page":"Example","title":"Write the sparse matrix into HDF5 file","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"It is sometimes needed to write the sparse matrix into file to avoid extra effort to generate it again in another calculation. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using HDF5 \nf = h5open(\"data.h5\", \"cw\")\nwrite(f, \"hmt_mat\", hmt_mat)\nclose(f)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To read from the file","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"f = h5open(\"data.h5\", \"r\") \nhmt_mat = read(f, \"hmt_mat\", OpMat{ComplexF64})\nclose(f)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Apart from OpMat, the supported types for writing include Confs, Basis, Vector{Term}, Operator, OpMat{ComplexF64} and OpMat{Float64}. ","category":"page"},{"location":"example/#Measuring-the-angular-momentum","page":"Example","title":"Measuring the angular momentum","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"We can measure the inner product of a final state, an operator or its matrix and an initial state or the action of an operator or its matrix on a state by directly using the * operator. The total angular momentum L^2 is built-in with function GetL2Terms. The following code measures the angular momentum of each eigenstate and verify whether Trangle is an eigenstate of L^2 by measuring ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"L^2Trangle=L^2Tranglequadfraclangle TL^2Trangle^2langle TTranglelangle L^2TL^2Trangle","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = Operator(bs, tms_l2)\nl2_mat = OpMat(l2)\nl2_val = [ st[:, i]' * l2_mat * st[:, i] for i in eachindex(enrg)]\n@show l2_val\n\nst_T = st[:, 3]\nst_L2T = l2_mat * st[:, 3]\n@show abs(st_L2T' * st_T) ^ 2 / ((st_T' * st_T) * (st_L2T' * st_L2T))","category":"page"},{"location":"example/#Primitive-version-4","page":"Example","title":"Primitive version","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"By definition","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"beginaligned\nL^2=L^+L^-+(L^z)^2-L^z\nL^z=sum_sigma mmc^dagger_mc_m\nL^pm=sum_sigma msqrt(smp m)(spm m+1)c^dagger_mpm 1c_m\nendaligned","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The construction of the operator can be simplified by the addition, multiplication, Hermitian conjugate and simplification of terms. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"tms_lz = \n    [ begin m = div(o - 1, nf)\n        Term(m - s, [1, o, 0, o])\n    end for o = 1 : no ]\ntms_lp = \n    [ begin m = div(o - 1, nf)\n        Term(sqrt(m * (nm - m)), [1, o, 0, o - nf])\n    end for o = nf + 1 : no ]\ntms_lm = tms_lp' \ntms_l2 = SimplifyTerms(tms_lz * tms_lz - tms_lz + tms_lp * tms_lm)","category":"page"},{"location":"example/#Go-through-all-the-sectors","page":"Example","title":"Go through all the sectors","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"One can repeat the calculation for all the sectors and records the results","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"result = []\nfor P in [1, -1], Z in [1, -1], R in [1, -1]\n    bs = Basis(cfs, [P, Z, R], qnf)\n    hmt = Operator(bs, tms_hmt)\n    hmt_mat = OpMat(hmt)\n    enrg, st = GetEigensystem(hmt_mat, 10)\n\n    l2 = Operator(bs, tms_l2)\n    l2_mat = OpMat(l2)\n    l2_val = [ st[:, i]' * l2_mat * st[:, i] for i in eachindex(enrg)]\n\n    for i in eachindex(enrg)\n        push!(result, round.([enrg[i], l2_val[i], P, Z], digits = 6))\n    end\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We then sort the eigenstates, find the energy of ground state and stress tensor, and calibrate the scaling dimensions. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"sort!(result, by = st -> real(st[1]))\nenrg_0 = result[1][1]\nenrg_T = filter(st -> st[2] ≊ 6 && st[3] ≊ 1 && st[4] ≊ 1, result)[1][1]\nresult_dim = [ [ 3 * (st[1] - enrg_0) / (enrg_T - enrg_0) ; st] for st in result ]\nfor P in (1, -1), Z in (1, -1)\n    display(permutedims(hcat(\n        filter(st -> st[4] ≊ P && st[5] ≊ Z, result_dim)...\n    )))\nend","category":"page"},{"location":"example/#Measuring-the-density-operator","page":"Example","title":"Measuring the density operator","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Similar process can be used to calculate the OPE coefficient by measuring the density operator, by definition ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"lambda_sigmasigmaepsilon=fraclanglesigman^z_00epsilonranglelanglesigman^z_00mathbbIranglequad n^z_00=frac1N_msum_sigma msigma c^dagger_sigma mc_sigma m","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To do that, we need to first repeat the calculation in the mathbbZ_2-odd sector","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"bs1 = Basis(cfs, [1, -1, 1], qnf)\nhmt = Operator(bs1, bs1, tms_hmt ; red_q = 1, sym_q = 1) \nhmt_mat = OpMat(hmt)\nenrg1, st1 = GetEigensystem(hmt_mat, 10)\nst_I = st[:, 1] \nst_e = st[:, 2] \nst_s = st1[:, 1]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The SphereObs type stores the information of a local observable on the sphere. In particular, the electron and density operators are built-in. The addition and multiplication of observables are enabled. It can be evaluated at a certain point GetPointValue or angular component with GetComponent. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"obs_nz = Density(nm, 2, [ 1 0 ; 0 -1 ])\ntms_nz = SimplifyTerms(GetComponent(obs_nz, 0.0, 0.0))\nnz = Operator(bs, bs1, tms_nz ; red_q = 1) \n@show abs((st_s' * nz * st_e) / (st_s' * nz * st_I))","category":"page"},{"location":"example/#Primitive-version-5","page":"Example","title":"Primitive version","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Alternatively, one can write out the terms of density operator explicitly.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Record the density operator n^z\ntms_nz = [ Term(isodd(o) ? 1 / nm : -1 / nm, [1, o, 0, o]) for o = 1 : no]\n# The nz operator sends a state in bs (+) to bs1 (-)\nnz = Operator(bs, bs1, tms_nz ; red_q = 1)\n# Measuring the finite size OPE\n@show abs((st_s' * nz * st_e) / (st_s' * nz * st_I))","category":"page"},{"location":"example/#DMRG-calculations-with-FuzzifiED","page":"Example","title":"DMRG calculations with FuzzifiED","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"In this example, we calculate the ground state MPS of the fuzzy sphere Ising model by DMRG in ITensors, and use the same objects to do ED calculation and compare the result. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We first set-up the calculation by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using FuzzifiED\nusing ITensors\nconst σx = [  0  1 ;  1  0 ]\nconst σz = [  1  0 ;  0 -1 ]\n\nnm = 12\nnf = 2\nno = nm * nf","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The first object we need is the sites. FuzzifiED overloads the fermion type and supports direct generation of the sites from the diagonal quantum numbers by the function SitesFromQNDiag. The Ising model is expressed in the basis of XX-Z so that the flavour symmetry is diagonal. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"sites = SitesFromQNDiag([\n    GetNeQNDiag(nm * nf), \n    GetLz2QNDiag(nm, nf),\n    GetZnfChargeQNDiag(nm, nf)\n])","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We then generate the terms of the Hamiltonian using the built-in functions, convert it to OpSum type in by the OpSumFromTerms, and convert it to MPO using the MPO function in ITensors","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"ps_pot = [4.75, 1.] ./ 2\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, ps_pot) - \n    GetDenIntTerms(nm, 2, ps_pot, σx) - \n    3.16 * GetPolTerms(nm, nf, σz)\n)\n@time mpo_hmt = MPO(OpSumFromTerms(tms_hmt), sites)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We then use the all-up state as the initial state. In FuzzifiED, the occupied and empty sites are expressed by 0 and 1, while they are expressed by \"0\" and \"1\" in ITensors, so a conversion to string is needed. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]\nst0 = MPS(sites, string.(cf0))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"After that, the Hamiltonian MPO and the initial state MPS can be used for input for DMRG calculation. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Eg, stg = dmrg(mpo_hmt, st0 ; nsweeps = 10, maxdim = [10,20,50,100,200,500], noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], cutoff = [1E-8])\n@show Eg","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We then convert these objects for the ED calculate. The configurations can be generated from Sites and a reference configuration by the function ConfsFromSites. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cfs = ConfsFromSites(sites, cf0)\nbs = Basis(cfs)\nhmt = Operator(bs, tms_hmt)\nhmt_mat = OpMat(hmt)\nenrg, st = GetEigensystem(hmt_mat, 10)\n@show enrg","category":"page"},{"location":"example/#Use-EasySweep-to-manage-DMRG-sweeps","page":"Example","title":"Use EasySweep to manage DMRG sweeps","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"EasySweep facilitates the management of DMRG process by automatically recording the intermediate results and recovering these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. Before the calculation, we need to define a method to generate MPO from OpSum and Sites. We suggest using MPO_new from package ITensorMPOConstruction, which can be installed through ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"julia> Pkg.add(url=\"https://github.com/ITensor/ITensorMPOConstruction.jl.git\"); ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using ITensorMPOConstruction\nfunction MyMPO(os, sites)\n    operatorNames = [ \"I\", \"C\", \"Cdag\", \"N\" ]\n    opCacheVec = [ [OpInfo(ITensors.Op(name, n), sites[n]) for name in operatorNames] for n in eachindex(sites)  ]\n    return MPO_new(os, sites ; basisOpCacheVec = opCacheVec)\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We also need to specify a path where the results are stored. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"path = \"nm_$(nm)/\"\nmkpath(path)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The Hamiltonian MPO and the sites can be either generated or read from file by the function GetMPOSites. The input is the quantum numbers and the terms or OpSum ; the output is the MPO and the sites","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"ps_pot = [4.75, 1.] ./ 2\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, ps_pot) - \n    GetDenIntTerms(nm, 2, ps_pot, σx) - \n    3.16 * GetPolTerms(nm, 2, σz)\n)\nqnd = [ \n    GetNeQNDiag(no), \n    GetLz2QNDiag(nm, nf), \n    GetZnfChargeQNDiag(nm, nf) \n]\nhmt, sites = GetMPOSites(\"hmt\", tms_hmt, qnd ; path, mpo_method = MyMPO)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"After generating the initial state MPS, the DMRG calculation of the states mathbbI and epsilon can be done by the EasySweep function.  ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]\nst0 = MPS(sites, string.(cf0))\nEg, stg = EasySweep(\"g\", hmt, st0 ; path)\nEe, ste = EasySweep(\"e\", hmt, st0 ; path, proj = [\"g\"])","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The total angular momentum can be measured by generating the MPO of L^2 and measure the inner product ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = GetMPO(\"l2\", tms_l2, sites ; path)\n@show inner(stg', l2, stg)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The mathbbZ_2-odd sigma state can be calculated similarly.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cf1 = cf0\ncf1[1] = 0\ncf1[2] = 1\nst1 = MPS(sites, string.(cf1))\nEs, sts = EasySweep(\"s\", hmt, st1 ; path)","category":"page"},{"location":"example/#List-of-examples","page":"Example","title":"List of examples","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The examples of FuzzifiED can be found in the repository examples. Apart from the tutorials that we have introduced above ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"tutorial_ising.jl does the ED calculation of Ising model through the built-in models. \ntutorial_ising_primitive.jl does the ED calculation of Ising model through the primitive functions.\ntutorial_ising_dmrg.jl does the DMRG calculation of Ising model through the dmrg function in ITensors.\ntutorial_ising_dmrg_easysweep.jl does the DMRG calculation of Ising model through the EasySweep function which wraps ITensors.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We offer a series of other examples that reproduces various achievements of fuzzy sphere. For a more detailed summary of the background, please visit « The fuzzified world ». ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"ising_spectrum.jl calculates the spectrum of 3d Ising model on fuzzy sphere at N_m = 12. For each (PZR) sector, 20 states are calculated. This example reproduces Table I and Figure 4 in Phys. Rev. X 13, 021009 (2023).\nising_phase_diagram.jl calculates the phase diagram of fuzzy sphere Ising modelby calculating the order parameter langle M^2rangle. This example reproduces Figure 3 in Phys. Rev. X 13, 021009 (2023).\nising_ope.jl calculates various OPE coefficients at N_m = 12 by taking overlaps between CFT states and density operators and composite. This example reproduces Figure 2 and Table I in Phys. Rev. Lett 131, 031601 (2023). \nising_correlator.jl calculates the σσ two-point function on sphere and the σσσσ four-point function on sphere, 0 and . This example reproduces Figures 1c and 2a in Phys. Rev. B 108, 235123 (2023)\nising_optimisation.jl defines a cost function as the square sum of the deviations of descendants and stress tensor to evaluate the conformal symmetry for Ising model and minimises this cost function to find the best parameter.\nising_full_spectrum.jl calculates the full spectrum of 3d Ising model on fuzzy sphere at N_m = 10 for sector (PZR) = (111).\nising_space_entangle.jl calculates the entanglement entropy of the Ising ground state along the real space cut of θ = 0500π and 0499π respectively, and use these two data to extract finite size F-function without sustracting the IQHE contribution. This example reproduces Figures 3 in arXiv : 2401.17362.\nising_orbital_entangle.jl calculates the entanglement entropy of the Ising ground state along the orbital space cut at m = 0, and also the entanglement spectrum in the half-filled l_z = 0 1 and  both mathbbZ_2 sectors.\ndefect_spectrum.jl calculates the spectrum of magnetic line defect in 3d Ising model in l_z = 0 P = 1 and l_z = 1 sectors, calibrated by bulk T. This example reproduces Table I in Nat. Commun. 15, 3659 (2024).\ndefect_correlator.jl calculates the 1-pt function σ and 2-pt function σhatϕ of magnetic line defect in 3d Ising model. The normalisation of the correlators require extra bulk data. This example reproduces Figure 4 in Nat. Commun. 15, 3659 (2024).\ndefect_changing.jl calculates the spectrum of the defect creation and changing operators of the magnetic line defect in 3d Ising model. This example reproduces Table 2 and Figure 5 in SciPost Phys. 17, 021 (2024).\ndefect_overlap.jl calculates the g-function of magnetic line defect in 3d Ising model using the ovelaps between the bulk, defect ground state and the lowest defect-creation state. This example reproduces Figure 6 in SciPost Phys. 17, 021 (2024).\ncusp_dim.jl calculates the scaling dimension of the cusp of the magnetic line defect in 3d Ising model as a function of the angle θ. This example reproduces Table 2, upper panel in arXiv : 2406.10186.\nsurface_ordinary_spectrum.jl calculates the spectrum of ordinary surface CFT in 3d Ising model calibrated by surface displacement operator D in the orbital boundary scheme. This example reproduces Figures 3 and 4 in arXiv:2407.15914. \nsurface_normal_spectrum.jl calculates the spectrum of normal surface CFT in 3d Ising model calibrated by surface displacement operator D in the orbital boundary scheme. This example reproduces Figure 5 in arXiv:2407.15914. \no3_wf_spectrum.jl calculates the spectrum of mathrmO(3) Wilson-Fisher CFT using the bilayer Heisenberg model. This example reproduces Table I and Figure 2 in arXiv : 2312.04047.\nso5_spectrum.jl calculates the spectrum of SO(5) DQCP on fuzzy sphere. This example reproduces Table II in Phys. Rev. X 14, 021044 (2024).","category":"page"}]
}
