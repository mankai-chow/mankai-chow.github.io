var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Configurations","page":"Reference","title":"Configurations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Confs\nConfs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Any} ; nor :: Int64 = div(no, 2))\nConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, qn_s :: QN)\nConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, cf_ref :: Vector{Int64})","category":"page"},{"location":"reference/#Main.FuzzifiED.Confs","page":"Reference","title":"Main.FuzzifiED.Confs","text":"Confs\n\nstores all the configurations that respects the U(1) conserved quantities. \n\nFields\n\nno :: Int64 is the number of orbitals\nncf :: Int64 is the number of configurations \nconf :: Vector{Int64} is an array of length ncf containing all the configurations. Each configuration is expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th orbital in the i-th configuration is occupied ; if the bit is 0, then the orbital is empty. \nnor :: Int64, lid :: Vector{Int64} and rid :: Vector{Int64} contain the information of Lin table that is used to inversely look up the index i from the configuration. \n\n\n\n\n\n","category":"type"},{"location":"reference/#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}","page":"Reference","title":"Main.FuzzifiED.Confs","text":"Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Vector{Int64}} ; nor :: Int64) :: Confs\n\nArguments\n\nno :: Int64 is the number of orbitals N_o ;\nqnu_s :: Vector{Int64} is the set of Q_i for the selected configurations ;\nqnu_o :: Vector{Vector{Int64}} is the set of q_io for each quantum number and for each orbital. It should contain N_U elements and each element should be a vector of length N_o. \n(nor :: Int64 is the number of less significant bits used to generate the Lin table.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Main.FuzzifiED.ITensorSupport.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}","page":"Reference","title":"Main.FuzzifiED.ITensorSupport.ConfsFromSites","text":"ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, qn_s :: QN)\n\nArguments\n\nsites :: Vector{Index{Vector{Pair{QN, Int64}}}} is a Sites object, where the modulus-pm 1 quantum numbers will be taken out, and QNs with other modulus will be discarded automatically. Also note that only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4. \nqn_s :: QN is a QN object that specifies the the quantum number of the selected configuration.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Main.FuzzifiED.ITensorSupport.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, Vector{Int64}}","page":"Reference","title":"Main.FuzzifiED.ITensorSupport.ConfsFromSites","text":"ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, cf_ref :: Vector{Int64})\n\nsites :: Vector{Index{Vector{Pair{QN, Int64}}}} is a Sites object, where the modulus-pm 1 quantum numbers will be taken out, and QNs with other modulus will be discarded automatically. Also note that only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4. \ncf_ref :: Vector{Int64}) is a reference configuration composed of 0 and 1 in ITensors format.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Basis","page":"Reference","title":"Basis","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Basis\nBasis(cfs :: Confs, qnz_s :: Vector{ComplexF64}, cyc :: Vector{Int64}, perm_o :: Vector{Any}, ph_o :: Vector{Any}, fac_o :: Vector{Any})\nBasis(cfs :: Confs)","category":"page"},{"location":"reference/#Main.FuzzifiED.Basis","page":"Reference","title":"Main.FuzzifiED.Basis","text":"Basis\n\nFields\n\ncfs :: Confs is the basis with only conserved quantities generated in the last step ;\ndim :: Int64 is the dimension of the basis ;\nszz :: Int64 records the maximum size max m_g of groups;\ncfgr :: Vector{Int64} is a vector of length cfs.ncf and records which group Irangle each configuration irangle belong to ;\ncffac :: Vector{ComplexF64} is a vector of length cfs.ncf and records the coefficients lambda_i ;\ngrel :: Matrix{Int64} is a szztimesdim matrix that records the configurations in each group i_I1rangledotsi_Im_Irangle\ngrsz :: Vector{Int64} is a vector of length dim that records the size m_I of each group.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Main.FuzzifiED.Basis-Tuple{Confs, Vector{ComplexF64}, Vector{Int64}, Vector{Any}, Vector{Any}, Vector{Any}}","page":"Reference","title":"Main.FuzzifiED.Basis","text":"Basis(cfs :: Confs, qnz_s :: Vector{ComplexF64}, cyc :: Vector{Int64}, perm_o :: Vector{Vector{Int64}}, ph_o :: Vector{Vector{Int64}}, fac_o :: Vector{Vector{ComplexF64}}) :: Basis\n\nArguments\n\ncfs :: Confs is the configuration set with only conserved quantities generated in the last step ;\nqnz_s :: Vector{ComplexF64} is a vector of length the same as the number of discrete symmetries N_Z that records the eigenvalue of each transformation ;\ncyc :: Vector{Int64} records the cycle of each transformation. For mathbbZ_n symmetry, record n ;\nperm_o :: Vector{Vector{Int64}} records the permutation pi_o. It has N_Z elements and each of its elements is a vector of length N_o. \nph_o :: Vector{Vector{Int64}} records p_o to determine whether or not to perform a particle-hole transformation. It has N_Z elements and each of its elements is a vector of length N_o. \nfac_o :: Vector{Vector{ComplexF64}} records the factor p_o is determine whether or not to perform a particle-hole transformation. It has N_Z elements and each of its elements is a vector of length N_o. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Main.FuzzifiED.Basis-Tuple{Confs}","page":"Reference","title":"Main.FuzzifiED.Basis","text":"Basis(cfs :: Confs) :: Basis\n\nGenerate a basis from the configurations without applying the mathbbZ_2 symmetries\n\n\n\n\n\n","category":"method"},{"location":"reference/#Operator","page":"Reference","title":"Operator","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Term\nOperator\nOperator(bsd :: Basis, bsf :: Basis, terms :: Vector{Term} ; red_q :: Int64 = 0, sym_q :: Int64 = 0)\nOperatorFromOpSum(bsd :: Basis, bsf :: Basis, opsum :: Sum{Scaled{ComplexF64, Prod{Op}}} ; red_q :: Int64 = 0, sym_q :: Int64 = 0)\n*(op :: Operator, st_d :: Vector{ComplexF64})\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64})","category":"page"},{"location":"reference/#Main.FuzzifiED.Term","page":"Reference","title":"Main.FuzzifiED.Term","text":"Term\n\nA Term object records a term that looks like Uc^(p_1)_o_1c^(p_2)_o_2dots c^(p_l)_o_l in an operator\n\nFields\n\ncoeff :: ComplexF64 records the coefficient U\ncstr :: Vector{Int64} is a length-2l vector (p_1o_1p_2o_2dots p_lo_l) recording the operator string\n\n\n\n\n\n","category":"type"},{"location":"reference/#Main.FuzzifiED.Operator","page":"Reference","title":"Main.FuzzifiED.Operator","text":"Operator\n\nAn Operator object records the sum of terms together with information about its symmetry.\n\nFields\n\nbsd :: Basis is the basis of the initial state ;\nbsf :: Basis is the basis of the final state ;\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; \nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0 ;\nntm :: Int64 is the number of terms ;\nnc :: Int64 is the maximum number of operators in an operator string\ncstrs :: Matrix{Int64} is a matrix recording the operator string of each term. Each column corresponds to a term and is padded to the maximum length with -1's.\ncoeffs :: Vector{ComplexF64} corresponds to the coefficients in each term.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Main.FuzzifiED.Operator-Tuple{Basis, Basis, Vector{Term}}","page":"Reference","title":"Main.FuzzifiED.Operator","text":"Operator(bsd :: Basis, bsf :: Basis, cstr_vec :: Vector{Vector{Int64}}, coeffs :: Vector{ComplexF64} ; red_q :: Int64, sym_q :: Int64) :: Operator\n\nArguments\n\nbsd :: Basis is the basis of the initial state ;\nbsf :: Basis is the basis of the final state ;\nterms :: Vector{Term} records the terms ; \nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; \nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Main.FuzzifiED.ITensorSupport.OperatorFromOpSum-Tuple{Basis, Basis, Sum{Scaled{ComplexF64, Prod{Op}}}}","page":"Reference","title":"Main.FuzzifiED.ITensorSupport.OperatorFromOpSum","text":"OperatorFromOpSum(bsd :: Basis, bsf :: Basis, opsum :: Sum{Scaled{ComplexF64, Prod{Op}}} ; red_q :: Int64 = 0, sym_q :: Int64 = 0)\n\nNote that the only operators supported are \"C\", \"Cdag\" \"N\" and \"I\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{Operator, Vector{ComplexF64}}","page":"Reference","title":"Base.:*","text":"*(op :: Operator, st_d :: Vector{ComplexF64})\n\nMeasure the action of an operator on a state. st_d must be of length op.bsd.dim. Returns a vector of length op.bsf.dim that represents the final state. \n\nNote that sometimes it is needed to transform a state from one basis to another. This can be done by constructing an identity operator. \n\nstf = Operator(bsd, bsf, [[-1, -1]], [ComplexF64(1)]) * std\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, Operator, Vector{ComplexF64}}","page":"Reference","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64}) :: ComplexF64\n\nMeasuring the inner product between two states and an operator. st_d must be of length op.bsd.dim and st_fp must be of length op.bsf.dim, and st_fp must be an adjoint. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Sparse-matrix","page":"Reference","title":"Sparse matrix","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"OpMat\nOpMat(op :: Operator)\n*(mat :: OpMat, st_d :: Vector{ComplexF64})\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat, st_d :: Vector{ComplexF64})\nGetEigensystem(mat :: OpMat, nst :: Int64 ; tol :: Float64 = 1E-8)","category":"page"},{"location":"reference/#Main.FuzzifiED.OpMat","page":"Reference","title":"Main.FuzzifiED.OpMat","text":"OpMat\n\nFields\n\ndimd :: Int64 and dimf :: Int64 are the number of columns and rows of the matrix ;\nsymq :: Int64 records whether or not the matrix is Hermitian or symmetric ;\nnel :: Int64 records the number of elements ;\ncolptr :: Vector{Int64}, rowid :: Vector{Int64} and elval :: Vector{ComplexF64} records the elements of the sparse matrix as in the SparseMatrixCSC elements of Julia. \n\n\n\n\n\n","category":"type"},{"location":"reference/#Main.FuzzifiED.OpMat-Tuple{Operator}","page":"Reference","title":"Main.FuzzifiED.OpMat","text":"OpMat(op :: Operator) :: OpMat\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{OpMat, Vector{ComplexF64}}","page":"Reference","title":"Base.:*","text":"*(mat :: OpMat, st_d :: Vector{ComplexF64})\n\nMeasure the action of a sparse matrix on a state. st_d must be of length mat.dimd. Returns a vector of length mat.dimf that represents the final state. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, OpMat, Vector{ComplexF64}}","page":"Reference","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat, st_d :: Vector{ComplexF64}) :: ComplexF64\n\nMeasuring the inner product between two states and a sparse matrix. st_d must be of length mat.dimd and st_fp must be of length mat.dimf, and st_fp must be an adjoint. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Main.FuzzifiED.GetEigensystem-Tuple{OpMat, Int64}","page":"Reference","title":"Main.FuzzifiED.GetEigensystem","text":"GetEigensystem(mat :: OpMat, nst :: Int64 ; tol :: Float64 = 1E-8)\n\nOutput\n\nA length-nst array recording the eigenvalues, and \nA dimdtimesnst matrix where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"#FuzzifiED.jl","page":"Home","title":"FuzzifiED.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package FuzzifiED is designed to do exact diagonalisation (ED) calculation on the fuzzy sphere. Install the package with the commands","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(url=\"https://github.com/mankai-chow/FuzzifiED.jl.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Include at the start of your Julia script","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LinearAlgebra\nusing FuzzifiED","category":"page"},{"location":"#ITensor-support","page":"Home","title":"ITensor support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package also supports importing the Site and OpSum objects from ITensors library, to use that, include also ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ITensors \nusing FuzzifiED.ITensorSupport","category":"page"},{"location":"example/#FuzzifiED-explained-in-an-example","page":"Example","title":"FuzzifiED explained in an example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"In this example, we will illustrate how to use  FuzzifiED to calculate the spectrum of Ising model on fuzzy sphere and how to calculate the OPE coefficient lambda_sigmasigmaepsilon by measuring the expectation value of the density operator n^z. ","category":"page"},{"location":"example/#Implement-the-conserved-quantities-and-generate-the-configurations","page":"Example","title":"Implement the conserved quantities and generate the configurations","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"FuzzifiED supports conserved quantities in the form of ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Q_i=sum_o=1^N_oq_ion_o","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where i=1dotsN_U is the index of conserved quantities, o is the index of orbital, n_o=c^dagger_oc_o, and q_o is a set of coefficients that must be non negative integer valued. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The function used to implement the conserved quantities and generate all the configurations (i.e., direct product states) is Confs. There are two conserved quantities in the Ising model, viz. the particle number and the angular momentum","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"beginaligned\nQ_1=N_e q_1msigma=1\nQ_2=L_z+N_esq_2msigma=m+s\nendaligned","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where the orbital index o contains both m and sigma. In the code, we store the spin-up orbitals in o=1dotsN_m and the spin-down orbitals in o=N_m+1dots2N_m. Thus, if we want to look at the L_z=0 half-filled sector","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Inputing the basic setups\nnf = 2\nnm = 8\nno = nf * nm\ns = .5 * (nm - 1)\nne = div(no, 2)\n# Initialise the arrays\nqnu_s = Vector{Int64}(undef, 0)\nqnu_o = []\n# Record the number of electrons\npush!(qnu_o, fill(1, no)) # qnu_o[1] = [1,1,...,1]\npush!(qnu_s, ne) \n# Record the angular momentum\npush!(qnu_o, [ div(o - 1, nf) for o = 1 : no ]) # qnu_o[2] = [0,0,1,1,...,7,7] to qnu_o\npush!(qnu_s, ne * s) \n# Generate the configurations and print the number\n@time \"Initialise configurations\" cfs = Confs(no, qnu_s, qnu_o)\n@show cfs.ncf","category":"page"},{"location":"example/#ITensor-support","page":"Example","title":"ITensor support","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The quantum numbers can also be imported from the Sites objects in ITensors. This can be done using the ConfsFromSites function.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Overload the ITensors type \"Fermion\"\nfunction ITensors.space( :: SiteType\"Fermion\" ; m1 :: Int = 0)\n    return [\n        QN((\"Nf\", 0, -1), (\"Lz\",  0)) => 1\n        QN((\"Nf\", 1, -1), (\"Lz\", m1)) => 1\n    ]\nend\n# Initialise the sites\nsites = [ siteind(\"Fermion\", m1 = div(o - 1, nf)) for o :: Int = 1 : no]\nqn_s = QN((\"Nf\", ne), (\"Lz\", Int(ne * s)))\n@time \"Initialise configurations\" cfs = ConfsFromSites(sites, qn_s)\n# Alternatively, one can initialise the configuration quantum number\n# cf_ref = [o <= ne ? 1 : 0 for o = 1 : no]\n# @time \"Initialise configurations\" cfs = ConfsFromSites(sites, cf_ref)\n@show cfs.ncf","category":"page"},{"location":"example/#Implement-the-discrete-symmetries-and-initialise-the-basis","page":"Example","title":"Implement the discrete symmetries and initialise the basis","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"FuzzifiED supports discrete mathbbZ_n symmetries in the form of ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"mathscrZ c_oto alpha_o^* c^(p_o)_pi_oquad c_o^daggerto alpha_o c^(1-p_o)_pi_o","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where we use a notation c^(1)=c^dagger and c^0=c for convenience, where pi_o is a permutation of 1dots N_o, alpha_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the orbital. Note that one must guarentee that all these transformations commute with each other and also commute with the conserved quantities. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"After implementing these symmetries, a state in the new basis should look like ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Irangle=lambda_i_I1i_I1rangle+lambda_i_I2i_I2rangle+cdots+lambda_i_Im_Ii_Im_Irangle","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where the irangle's are configurations in the Confs generated in the last section. The Irangle is a linear combination, and can be regarded as a grouping of m_I configurations.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The function used to implement the discrete symmetries is Basis. There are three mathbbZ_2 transformations in the Ising model, viz. the particle-hole transformation mathscrP, the pi-rotation along the y-axis mathscrR_y and the flavour symmetry mathscrZ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"beginaligned\n    mathscrPc^dagger_sigma mtosigma c_-sigmam\n    mathscrZc^dagger_sigma mto c^dagger_-sigmam\n    mathscrR_yc^dagger_sigma mto c^dagger_sigma-m\nendaligned","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Thus, if we want to look at the all-positive sector","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cyc = [ 2, 2, 2 ] # Input three Z_2 symmetries \nqnz_s = ComplexF64[ 1, 1, 1 ] # Quantum numbers are all positive \n# Initialise the vectors\nperm_o = []\nph_o = []\nfac_o = []\n# Record the parity\npush!(perm_o, [ isodd(o) ? o + 1 : o - 1 for o = 1 : no]) # perm_o[1] = [2,1,4,3,...,16,15]\npush!(ph_o, fill(1, no)) # ph_o[1] = [1,1,...,1] meaning PH\npush!(fac_o, [ isodd(o) ? -1 : 1 for o = 1 : no]) # fac_o[1] = [1,-1,1,-1,...,1,-1]\n# Record the flavour symmetry\npush!(perm_o, [ isodd(o) ? o + 1 : o - 1 for o = 1 : no]) # perm_o[3] = [2,1,4,3,...,16,15]\npush!(ph_o, fill(0, no)) # ph_o[3] = [0,0,...,0] meaning no PH\npush!(fac_o, fill(ComplexF64(1), no)) # fac_o[3] = [1,1,...,1]\n# Record the pi-rotation\npush!(perm_o, [ isodd(o) ? no - o : no + 2 - o for o = 1 : no]) # perm_o[2] = [15,16,13,14,...,1,2]\npush!(ph_o, fill(0, no)) # ph_o[2] = [0,0,...,0] meaning no PH\npush!(fac_o, fill(ComplexF64(1), no)) # fac_o[2] = [1,1,...,1]\n# Generate the basis and print the dimension\n@time \"Initialise basis\" bs = Basis(cfs, qnz_s, cyc, perm_o, ph_o, fac_o)\n@show bs.dim ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Note that if no discrete symmetry is needed, one can simply put instead bs = Basis(conf)","category":"page"},{"location":"example/#Record-the-Hamiltonian-operator","page":"Example","title":"Record the Hamiltonian operator","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The operator here refers to the sum of product of c and c^dagger's in the form ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Phi=sum_t=1^N_tU_tc^(p_t1)_o_t1c^(p_t2)_o_t2dots c^(p_tl)_o_tl","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where c^(0)=c and c^(1)=c^dagger. Here the operator string sum is recorded together with the basis of the initial state and the basis of the final state. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This can be generated by the Operator function. The Hamiltonian for the fuzzy sphere Ising model","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"H=sum_m_1m_2m_3m_4U_m_1m_2m_3m_4delta_m_1+m_2m_3+m_4c^dagger_m_1uparrowc^dagger_m_2downarrowc_m_3downarrowc_m_4uparrow-hsum_m(c^dagger_muparrowc_mdownarrow+mathrmhc)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"can be recorded with ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using WignerSymbols\n# Input the parameters of the Hamiltonian\nps_pot = [ 4.75, 1. ] * 2.\nh = 3.16\ntms_hmt = Vector{Term}(undef, 0)\n# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3\nfor m1 = 0 : nm - 1\n    f1 = 0\n    o1 = m1 * nf + f1 + 1\n    m1r = m1 - s\n    for m2 = 0 : nm - 1\n        f2 = 1\n        o2 = m2 * nf + f2 + 1\n        m2r = m2 - s\n        for m3 = 0 : nm - 1\n            f3 = 1\n            o3 = m3 * nf + f3 + 1\n            m3r = m3 - s\n            m4 = m1 + m2 - m3 \n            if (m4 < 0 || m4 >= nm) continue end\n            f4 = 0\n            o4 = m4 * nf + f4 + 1\n            m4r = m4 - s\n            # Calculate the matrix element val from pseudopotentials\n            val = ComplexF64(0)\n            for l in 1 : length(ps_pot)\n                if (abs(m1r + m2r) > nm - l || abs(m3r + m4r) > nm - l) break end \n                val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, m1r, m2r, -m1r - m2r) * wigner3j(s, s, nm - l, m4r, m3r, -m3r - m4r)\n            end \n            # Record the interaction term val, \"Cdag\", o1, \"Cdag\", o2, \"C\", o3, \"C\", o4\n            push!(tms_hmt, Term(val, [1, o1, 1, o2, 0, o3, 0, o4]))\n        end\n    end\n    o1x = o1 + 1\n    # Record the transverse field term\n    push!(tms_hmt, Term(-h, [1, o1, 0, o1x]))\n    push!(tms_hmt, Term(-h, [1, o1x, 0, o1]))\nend\n# Generate the Hamiltonian operator\nhmt = Operator(bs, bs, tms_hmt ; red_q = 1, sym_q = 1)","category":"page"},{"location":"example/#ITensor-support-2","page":"Example","title":"ITensor support","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Alternatively, one can generate the operator using an OpSum object instead of cstr_vec and fac using the function OperatorFromOpSum.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"For the Hamiltonian of Ising model,","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"\nusing WignerSymbols\n# Input the parameters of the Hamiltonian\nps_pot = [ 4.75, 1. ] * 2.\nh = 3.16\nglobal ops_hmt = OpSum()\n# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3\nfor m1 = 0 : nm - 1\n    f1 = 0\n    o1 = m1 * nf + f1 + 1\n    m1r = m1 - s\n    for m2 = 0 : nm - 1\n        f2 = 1\n        o2 = m2 * nf + f2 + 1\n        m2r = m2 - s\n        for m3 = 0 : nm - 1\n            f3 = 1\n            o3 = m3 * nf + f3 + 1\n            m3r = m3 - s\n            m4 = m1 + m2 - m3 \n            if (m4 < 0 || m4 >= nm) continue end\n            f4 = 0\n            o4 = m4 * nf + f4 + 1\n            m4r = m4 - s\n            # Calculate the matrix element val from pseudopotentials\n            val = ComplexF64(0)\n            for l in 1 : length(ps_pot)\n                if (abs(m1r + m2r) > nm - l || abs(m3r + m4r) > nm - l) break end \n                val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, m1r, m2r, -m1r - m2r) * wigner3j(s, s, nm - l, m4r, m3r, -m3r - m4r)\n            end \n            # Record the interaction term\n            global ops_hmt += val, \"Cdag\", o1, \"Cdag\", o2, \"C\", o3, \"C\", o4\n        end\n    end\n    o1x = o1 + 1\n    # Record the transverse field term\n    global ops_hmt += -h, \"Cdag\", o1, \"C\", o1x\n    global ops_hmt += -h, \"Cdag\", o1x, \"C\", o1\nend\n# Generate the Hamiltonian operator\nhmt = OperatorFromOpSum(bs, bs, ops_hmt ; red_q = 1, sym_q = 1)","category":"page"},{"location":"example/#Generate-the-sparse-matrix-and-diagonalise","page":"Example","title":"Generate the sparse matrix and diagonalise","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"After specifying the Hamiltonian, we then use the OpMat to generate a sparse matrix from the operator. To get the 10 lowest eigenstates and their energies","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"@time \"Initialise the Hamiltonian matrix\" hmtmat = OpMat(hmt)\n@show hmtmat.nel\n@time \"Diagonalise Hamiltonian\" enrg, st = GetEigensystem(hmtmat, 10)\n@show real(enrg)","category":"page"},{"location":"example/#Measuring-the-angular-momentum","page":"Example","title":"Measuring the angular momentum","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"We can measure the inner product of a final state, an operator or its matrix and an initial state or the action of an operator or its matrix on a state by directly using the * operator. To measure the total angular momentum L^2 by definition","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"beginaligned\nL^2=L^+L^-+(L^z)^2-L^z\nL^z=sum_sigma mmc^dagger_mc_m\nL^pm=sum_sigma msqrt(smp m)(spm m+1)c^dagger_mpm 1c_m\nendaligned","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The following code measures the angular momentum of each eigenstate and verify whether Trangle is an eigenstate of L^2 by measuring ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"L^2Trangle=L^2Tranglequadfraclangle TL^2Trangle^2langle TTranglelangle L^2TL^2Trangle","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"tms_l2 = Vector{Term}(undef, 0)\nfor o1 = 1 : no \n    m1 = div(o1 - 1, nf) \n    # record the -Lz term\n    push!(tms_l2, Term(-(m1 - s), [1, o1, 0, o1]))\n    for o2 = 1 : no \n        m2 = div(o2 - 1, nf)\n        # record the Lz^2 term\n        push!(tms_l2, Term((m1 - s) * (m2 - s), [1, o2, 0, o2, 1, o1, 0, o1]))\n        if m1 == nm - 1 continue end\n        if m2 == 0 continue end \n        # record the L+L- term\n        push!(tms_l2, Term(sqrt(m2 * (nm - m2) * (m1 + 1) * (nm - m1 - 1)), [1, o1 + nf, 0, o1, 1, o2 - nf, 0, o2]))\n    end\nend\n# Initialise the L2 operator\nl2 = Operator(bs, bs, tms_l2 ; red_q = 1, sym_q = 1)\n@time \"Initialise L2\" l2_mat = OpMat(l2)\n# Calculate the inner product for each eigenstate\n@time \"Measure L2\" l2_val = [ st[:, i]' * l2_mat * st[:, i] for i = 1 : length(enrg)]\n@show real(l2_val)\n# Verify whether T is an eigenstate of L^2\nst_T = st[:, 3]\nst_L2T = l2_mat * st[:, 3]\n@show abs(st_L2T' * st_T) ^ 2 / ((st_T' * st_T) * (st_L2T' * st_L2T))","category":"page"},{"location":"example/#Measuring-the-density-operator","page":"Example","title":"Measuring the density operator","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Similar process can be used to calculate the OPE coefficient by measuring the density operator, by definition ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"lambda_sigmasigmaepsilon=fraclanglesigman^z_00epsilonranglelanglesigman^z_00mathbbIranglequad n^z_00=frac1N_msum_sigma msigma c^dagger_sigma mc_sigma m","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To do that, we need to first repeat the calculation in the mathbbZ_2-odd sector","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Repeat the calculation for the Z_2 odd sector (with subscript 1)\nqnz_s1 = ComplexF64[ 1, -1, 1 ] # Change only the discrete quantum numbers and generate the basis\n@time \"Initialise Basis Z\" bs1 = Basis(cfs, qnz_s1, cyc, perm_o, ph_o, fac_o) \n@show bs1.dim \nhmt = Operator(bs1, bs1, tms_hmt ; red_q = 1, sym_q = 1) # Generate and diagonalise Hamiltonian in the new basis\n@time \"Initialise Hamiltonian\" hmtmat = OpMat(hmt)\n@show hmtmat.nel\n@time \"Diagonalise Hamiltonian\" enrg1, st1 = GetEigensystem(hmtmat, 10)\n@show real(enrg1)\n# Record the identity, sigma and epsilon states \nst_I = st[:, 1] # ground state\nst_e = st[:, 2] # epsilon state\nst_s = st1[:, 1]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"and then generate and measure the density operator","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Record the density operator n^z\ntms_nz = Vector{Term}(undef, 0)\nfor m1 = 0 : nm - 1\n    o1u = 2 * m1 + 1\n    o1d = 2 * m1 + 2\n    push!(tms_nz, Term( 1 / nm, [1, o1u, 0, o1u]))\n    push!(tms_nz, Term(-1 / nm, [1, o1d, 0, o1d]))\nend\n# The nz operator sends a state in bs (+) to bs1 (-)\nnz = Operator(bs, bs1, tms_nz ; red_q = 1)\n# Measuring the finite size OPE\n@show abs((st_s' * nz * st_e) / (st_s' * nz * st_I))","category":"page"}]
}
