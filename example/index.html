<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example · FuzzifiED.jl</title><meta name="title" content="Example · FuzzifiED.jl"/><meta property="og:title" content="Example · FuzzifiED.jl"/><meta property="twitter:title" content="Example · FuzzifiED.jl"/><meta name="description" content="Documentation for FuzzifiED.jl."/><meta property="og:description" content="Documentation for FuzzifiED.jl."/><meta property="twitter:description" content="Documentation for FuzzifiED.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/font.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="FuzzifiED.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FuzzifiED.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Example</a><ul class="internal"><li><a class="tocitem" href="#Exact-diagonalisation-with-FuzzifiED"><span>Exact diagonalisation with FuzzifiED</span></a></li><li><a class="tocitem" href="#DMRG-calculations-with-FuzzifiED"><span>DMRG calculations with FuzzifiED</span></a></li><li><a class="tocitem" href="#List-of-examples"><span>List of examples</span></a></li></ul></li><li><a class="tocitem" href="../core/">Core functions</a></li><li><a class="tocitem" href="../itensors/">ITensors support</a></li><li><a class="tocitem" href="../models/">Built-in models</a></li><li><a class="tocitem" href="../archieve/">Archieved interfaces</a></li><li><a class="tocitem" href="../releases/">Releases</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mankai-chow/fuzzifi_ed" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mankai-chow/fuzzifi_ed/blob/main/docs/src/example.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="FuzzifiED-explained-in-an-example"><a class="docs-heading-anchor" href="#FuzzifiED-explained-in-an-example">FuzzifiED explained in an example</a><a id="FuzzifiED-explained-in-an-example-1"></a><a class="docs-heading-anchor-permalink" href="#FuzzifiED-explained-in-an-example" title="Permalink"></a></h1><p>In this example, we will illustrate how to use <code>FuzzifiED</code> to calculate the spectrum of Ising model on fuzzy sphere and how to calculate the OPE coefficient <span>$\lambda_{\sigma\sigma\epsilon}$</span> by measuring the expectation value of the density operator <span>$n^z$</span>. </p><p>The examples can be found in the directory <a href="https://github.com/mankai-chow/FuzzifiED.jl/tree/main/examples"><code>examples</code></a>. Two versions of this example is provided. The first uses the built-in functions for quantum numbers and operators to calculate the observables and is stored in <a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/tutorial_ising.jl"><code>tutorial_ising.jl</code></a>. The second does not use the built-in example and is stored in <a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/tutorial_ising_primitive.jl"><code>tutorial_ising_primitive.jl</code></a>. </p><p>In addition, an example of how <code>FuzzifiED</code> can facilitate DMRG calculation is given. Two versions of the DMRG example is provided. The first uses <code>MPO</code> and <code>dmrg</code> functions of the ITensors package and is stored in <a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/tutorial_ising_dmrg.jl"><code>tutorial_ising_dmrg.jl</code></a>. The second uses the <a href="../itensors/#Main.FuzzifiED.EasySweep-Tuple{String, MPO, MPS}"><code>EasySweep</code></a> function in the package which further wraps the <code>dmrg</code> function to facilitate the management of sweeps and is stored in <a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/tutorial_ising_dmrg_easysweep.jl"><code>tutorial_ising_dmrg_easysweep.jl</code></a>. </p><p>We also append in the end <a href="#List-of-examples">a list of given examples</a> at the end of the page.</p><h2 id="Exact-diagonalisation-with-FuzzifiED"><a class="docs-heading-anchor" href="#Exact-diagonalisation-with-FuzzifiED">Exact diagonalisation with FuzzifiED</a><a id="Exact-diagonalisation-with-FuzzifiED-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-diagonalisation-with-FuzzifiED" title="Permalink"></a></h2><h3 id="Implement-the-diagonal-quantum-numbers-and-generate-the-configurations"><a class="docs-heading-anchor" href="#Implement-the-diagonal-quantum-numbers-and-generate-the-configurations">Implement the diagonal quantum numbers and generate the configurations</a><a id="Implement-the-diagonal-quantum-numbers-and-generate-the-configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Implement-the-diagonal-quantum-numbers-and-generate-the-configurations" title="Permalink"></a></h3><p><code>FuzzifiED</code> supports <span>$\mathrm{U}(1)$</span> diagonal quantum numbers (QNDiag) </p><p class="math-container">\[Q_i=\sum_{o=1}^{N_o}q_{io}n_o\]</p><p>or <span>$\mathbb{Z}_n$</span> diagonal quantum numbers with period <span>$P_i$</span></p><p class="math-container">\[Q_i=\sum_{o=1}^{N_o}q_{io}n_o\ \mathrm{mod}\ P_i\]</p><p>where <span>$i=1,\dots,N_U$</span> is the index of diagonal quantum numbers, <span>$o$</span> is the index of orbital, <span>$n_o=c^\dagger_oc_o$</span>, and <span>$q_o$</span> is a set of coefficients that must be integer-valued. </p><p>There are two diagonal quantum numbers in the Ising model, <em>viz.</em> the particle number and the angular momentum</p><p class="math-container">\[\begin{aligned}
Q_1&amp;=N_e,&amp; q_{1,m\sigma}&amp;=1\\
Q_2&amp;=2L_z,&amp;q_{2,m\sigma}&amp;=2m
\end{aligned}\]</p><p>where the orbital index <span>$o$</span> contains both <span>$m$</span> and <span>$\sigma$</span>. In the code, we store the orbitals with the same <span>$m$</span> together, <em>viz.</em> we store the spin-up orbitals in odd <span>$o=1,3,\dots,2N_m-1$</span> and the spin-down orbitals in even <span>$o=2,4,\dots,2N_m$</span>. We look at the <span>$L_z=0$</span> half-filled sector. </p><p>These two diagonal quantum numbers are built in with functions <a href="../models/#Main.FuzzifiED.GetNeQNDiag-Tuple{Int64}"><code>GetNeQNDiag</code></a> and <a href="../models/#Main.FuzzifiED.GetLz2QNDiag-Tuple{Int64, Int64}"><code>GetLz2QNDiag</code></a> and the configurations can be generated with function <a href="../core/#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{QNDiag}}"><code>Confs</code></a>. </p><pre><code class="language-julia hljs"># Inputing the basic setups
nm = 12
qnd = [ 
    GetNeQNDiag(2 * nm), 
    GetLz2QNDiag(nm, 2) 
]
cfs = Confs(2 * nm, [nm, 0], qnd)</code></pre><h4 id="Primitive-version"><a class="docs-heading-anchor" href="#Primitive-version">Primitive version</a><a id="Primitive-version-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-version" title="Permalink"></a></h4><p>Alternatively, you can put in the diagonal quantum numbers <a href="../core/#Main.FuzzifiED.QNDiag"><code>QNDiag</code></a> by hand by specifying the symmetry charges <span>$q_o$</span> of the orbitals, and facultatively the name and the modulus</p><pre><code class="language-julia hljs">nf = 2
nm = 8
no = nf * nm
s = .5 * (nm - 1)
ne = div(no, 2)
# Record the QNDiag
qnd = [ 
    # Number of electrons Ne
    QNDiag(fill(1, no)), 
    # Twice angular momentum 2Lz
    QNDiag([ (o - 1) ÷ nf * 2 - (nm - 1) for o = 1 : no ])
]
cfs = Confs(no, [ne, 0], qnd)</code></pre><h3 id="Implement-the-off-diagonal-\\mathbb{Z}_p-symmetries-and-initialise-the-basis"><a class="docs-heading-anchor" href="#Implement-the-off-diagonal-\\mathbb{Z}_p-symmetries-and-initialise-the-basis">Implement the off-diagonal <span>$\mathbb{Z}_p$</span> symmetries and initialise the basis</a><a id="Implement-the-off-diagonal-\\mathbb{Z}_p-symmetries-and-initialise-the-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Implement-the-off-diagonal-\\mathbb{Z}_p-symmetries-and-initialise-the-basis" title="Permalink"></a></h3><p><code>FuzzifiED</code> supports off diagonal discrete <span>$\mathbb{Z}_p$</span> symmetries in the form of </p><p class="math-container">\[\mathscr{Z}:\ c_o\to \alpha_o^* c^{(p_o)}_{\pi_o},\quad c_o^\dagger\to \alpha_o c^{(1-p_o)}_{\pi_o}\]</p><p>where we use a notation <span>$c^{(1)}=c^\dagger$</span> and <span>$c^{0}=c$</span> for convenience, where <span>$\pi_o$</span> is a permutation of <span>$1,\dots N_o$</span>, <span>$\alpha_o$</span> is a coefficient, and <span>$p_o$</span> specified whether or not particle-hole transformation is performed for the orbital. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal quantum numbers. </p><p>After implementing these symmetries, a state in the new basis should look like </p><p class="math-container">\[|I\rangle=\lambda_{i_{I1}}|i_{I1}\rangle+\lambda_{i_{I2}}|i_{I2}\rangle+\cdots+\lambda_{i_{Im_I}}|i_{Im_I}\rangle\]</p><p>where the <span>$|i\rangle$</span>&#39;s are configurations in the <code>Confs</code> generated in the last section. The <span>$|I\rangle$</span> is a linear combination, and can be regarded as a grouping of <span>$m_I$</span> configurations.</p><p>The function used to implement the discrete symmetries is <a href="../core/#Basis"><code>Basis</code></a>. There are three <span>$\mathbb{Z}_2$</span> transformations in the Ising model, <em>viz.</em> the particle-hole transformation <span>$\mathscr{P}$</span>, the <span>$\pi$</span>-rotation along the <span>$y$</span>-axis <span>$\mathscr{R}_y$</span> and the flavour (Ising) symmetry <span>$\mathscr{Z}$</span></p><p class="math-container">\[\begin{aligned}
    \mathscr{P}:c^\dagger_{\sigma m}&amp;\to\sigma c_{-\sigma,m}\\
    \mathscr{Z}:c^\dagger_{\sigma m}&amp;\to c^\dagger_{-\sigma,m}\\
    \mathscr{R}_y:c^\dagger_{\sigma m}&amp;\to c^\dagger_{\sigma,-m}\\
\end{aligned}\]</p><p>These three symmetries are built in with functions <a href="../models/#Main.FuzzifiED.GetParityQNOffd"><code>GetParityQNOffd</code></a>, <a href="../models/#Main.FuzzifiED.GetFlavPermQNOffd"><code>GetFlavPermQNOffd</code></a> and <a href="../models/#Main.FuzzifiED.GetRotyQNOffd-Tuple{Int64, Int64}"><code>GetRotyQNOffd</code></a>. Thus, if we want to look at the all-positive sector</p><pre><code class="language-julia hljs">qnf = [ 
    GetParityQNOffd(nm, 2, [2, 1], [1, -1]), 
    GetFlavPermQNOffd(nm, 2, [2, 1]), 
    GetRotyQNOffd(nm, 2) 
]
bs = Basis(cfs, [1, 1, 1], qnf)
# The second argument gives the eigenvalues under the transformations, for Z_2 put 1,-1 ; for Z_n put exp(2im*pi*q/p)</code></pre><p>If no discrete symmetry is needed, one can simply put instead <code>bs = Basis(conf)</code></p><h4 id="Primitive-version-2"><a class="docs-heading-anchor" href="#Primitive-version-2">Primitive version</a><a class="docs-heading-anchor-permalink" href="#Primitive-version-2" title="Permalink"></a></h4><p>Alternatively, you can put in the diagonal quantum numbers <a href="../core/#Main.FuzzifiED.QNOffd"><code>QNOffd</code></a> by hand by specifying the permutations <span>$\pi_o$</span> of the orbitals, and facultatively the particle-hole transformation <span>$p_o$</span>, the factor <span>$\alpha_o$</span> and the cycle. </p><pre><code class="language-julia hljs"># Record a QNOffd by orbital permutation (and facultatives particle-hole, factor, cycle)
qnf = [ 
    # Parity (Particle-hole)
    QNOffd([ isodd(o) ? o + 1 : o - 1 for o = 1 : no], true, ComplexF64[ isodd(o) ? -1 : 1 for o = 1 : no]),
    # Flavour symmetry
    QNOffd([ isodd(o) ? o + 1 : o - 1 for o = 1 : no]),
    # Y-axis pi-rotation
    QNOffd([ isodd(o) ? no - o : no + 2 - o for o = 1 : no], ComplexF64(-1) .^ (collect(0 : nm * nf - 1) .÷ nf))
]
bs = Basis(cfs, [1, 1, 1], qnf) </code></pre><p>Please refer to the <a href="../core/#Main.FuzzifiED.QNDiag">documenation</a> if you want to implement <span>$\mathbb{Z}_{n&gt;2}$</span> symmetries. </p><h3 id="Record-the-Hamiltonian-terms"><a class="docs-heading-anchor" href="#Record-the-Hamiltonian-terms">Record the Hamiltonian terms</a><a id="Record-the-Hamiltonian-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Record-the-Hamiltonian-terms" title="Permalink"></a></h3><p>The operator here refers to the sum of product of <span>$c$</span> and <span>$c^\dagger$</span>&#39;s in the form </p><p class="math-container">\[\Phi=\sum_{t=1}^{N_t}U_tc^{(p_{t1})}_{o_{t1}}c^{(p_{t2})}_{o_{t2}}\dots c^{(p_{tl})}_{o_{tl}}\]</p><p>where <span>$c^{(0)}=c$</span> and <span>$c^{(1)}=c^\dagger$</span>. Here the operator string sum is recorded together with the basis of the initial state and the basis of the final state. </p><p>This can be generated by the <a href="../core/#Operator"><code>Operator</code></a> function. The Hamiltonian for the fuzzy sphere Ising model</p><p class="math-container">\[H=\sum_{m_1m_2m_3m_4}U_{m_1m_2m_3m_4}\delta_{m_1+m_2,m_3+m_4}c^\dagger_{m_1\uparrow}c^\dagger_{m_2\downarrow}c_{m_3\downarrow}c_{m_4\uparrow}-h\sum_m(c^\dagger_{m\uparrow}c_{m\downarrow}+\mathrm{h.c.})\]</p><p>can be recorded as the sum of a density-density interaction and a polarisation term, which are built-in with the functions <a href="../models/#Main.FuzzifiED.GetDenIntTerms"><code>GetDenIntTerms</code></a> and <a href="../models/#Main.FuzzifiED.GetPolTerms-Tuple{Int64, Int64, Matrix{&lt;:Number}}"><code>GetPolTerms</code></a>.</p><pre><code class="language-julia hljs">const σ1 = [  1  0 ;  0  0 ]
const σ2 = [  0  0 ;  0  1 ]
const σx = [  0  1 ;  1  0 ]
tms_hmt = SimplifyTerms(
    GetDenIntTerms(nm, 2, 2 .* [4.75, 1.], σ1, σ2) - 
    3.16 * GetPolTerms(nm, 2, σx) )</code></pre><h4 id="Primitive-version-3"><a class="docs-heading-anchor" href="#Primitive-version-3">Primitive version</a><a class="docs-heading-anchor-permalink" href="#Primitive-version-3" title="Permalink"></a></h4><pre><code class="language-julia hljs">using WignerSymbols
# Input the parameters of the Hamiltonian
ps_pot = [ 4.75, 1. ] * 2.
h = 3.16
tms_hmt = Vector{Term}(undef, 0)
# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3
for m1 = 0 : nm - 1
    f1 = 0
    o1 = m1 * nf + f1 + 1
    m1r = m1 - s
    for m2 = 0 : nm - 1
        f2 = 1
        o2 = m2 * nf + f2 + 1
        m2r = m2 - s
        for m3 = 0 : nm - 1
            f3 = 1
            o3 = m3 * nf + f3 + 1
            m3r = m3 - s
            m4 = m1 + m2 - m3 
            if (m4 &lt; 0 || m4 &gt;= nm) continue end
            f4 = 0
            o4 = m4 * nf + f4 + 1
            m4r = m4 - s
            # Calculate the matrix element val from pseudopotentials
            val = ComplexF64(0)
            for l in eachindex(ps_pot)
                if (abs(m1r + m2r) &gt; nm - l || abs(m3r + m4r) &gt; nm - l) break end 
                val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, m1r, m2r, -m1r - m2r) * wigner3j(s, s, nm - l, m4r, m3r, -m3r - m4r)
            end 
            # Record the interaction term val, &quot;Cdag&quot;, o1, &quot;Cdag&quot;, o2, &quot;C&quot;, o3, &quot;C&quot;, o4
            push!(tms_hmt, Term(val, [1, o1, 1, o2, 0, o3, 0, o4]))
        end
    end
    o1x = o1 + 1
    # Record the transverse field term
    push!(tms_hmt, Term(-h, [1, o1, 0, o1x]))
    push!(tms_hmt, Term(-h, [1, o1x, 0, o1]))
end
# Generate the Hamiltonian operator
hmt = Operator(bs, tms_hmt)</code></pre><h3 id="Generate-the-sparse-matrix-and-diagonalise"><a class="docs-heading-anchor" href="#Generate-the-sparse-matrix-and-diagonalise">Generate the sparse matrix and diagonalise</a><a id="Generate-the-sparse-matrix-and-diagonalise-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-the-sparse-matrix-and-diagonalise" title="Permalink"></a></h3><p>After specifying the Hamiltonian, we then use <a href="../core/#Main.FuzzifiED.Operator-Tuple{Basis, Basis, Vector{Term}}">Operator</a> to record also the basis and use <a href="../core/#Main.FuzzifiED.OpMat"><code>OpMat</code></a> to generate a sparse matrix from the operator. To get the 10 lowest eigenstates and their energies</p><pre><code class="language-julia hljs">hmt = Operator(bs, tms_hmt)
hmt_mat = OpMat(hmt)
enrg, st = GetEigensystem(hmt_mat, 10)</code></pre><p>Matrices with real elements can be generated with the option <code>type = Float64</code> in the <code>OpMat</code> function. </p><h3 id="Measuring-the-angular-momentum"><a class="docs-heading-anchor" href="#Measuring-the-angular-momentum">Measuring the angular momentum</a><a id="Measuring-the-angular-momentum-1"></a><a class="docs-heading-anchor-permalink" href="#Measuring-the-angular-momentum" title="Permalink"></a></h3><p>We can measure the inner product of a final state, an operator or its matrix and an initial state or the action of an operator or its matrix on a state by directly using the <a href="../core/#Base.:*-Tuple{Int64, QNDiag}"><code>*</code></a> operator. The total angular momentum <span>$L^2$</span> is built-in with function <a href="../models/#Main.FuzzifiED.GetL2Terms-Tuple{Int64, Int64}"><code>GetL2Terms</code></a>. The following code measures the angular momentum of each eigenstate and verify whether <span>$|T\rangle$</span> is an eigenstate of <span>$L^2$</span> by measuring </p><pre><code class="language-julia hljs">tms_l2 = GetL2Terms(nm, 2)
l2 = Operator(bs, tms_l2)
l2_mat = OpMat(l2 ; type = Float64)
l2_val = [ st[:, i]&#39; * l2_mat * st[:, i] for i in eachindex(enrg)]
@show l2_val

st_T = st[:, 3]
st_L2T = l2_mat * st[:, 3]
@show abs(st_L2T&#39; * st_T) ^ 2 / ((st_T&#39; * st_T) * (st_L2T&#39; * st_L2T))</code></pre><h4 id="Primitive-version-4"><a class="docs-heading-anchor" href="#Primitive-version-4">Primitive version</a><a class="docs-heading-anchor-permalink" href="#Primitive-version-4" title="Permalink"></a></h4><p>By definition</p><p class="math-container">\[\begin{aligned}
L^2&amp;=L^+L^-+(L^z)^2-L^z\\
L^z&amp;=\sum_{\sigma m}mc^\dagger_mc_m\\
L^\pm&amp;=\sum_{\sigma m}\sqrt{(s\mp m)(s\pm m+1)}c^\dagger_{m\pm 1}c_m
\end{aligned}\]</p><p>The construction of the operator can be simplified by the <a href="../core/#Base.:+-Tuple{Vector{Term}, Vector{Term}}">addition</a>, <a href="../core/#Base.:*-Tuple{Vector{Term}, Vector{Term}}">multiplication</a>, <a href="../core/#Base.adjoint-Tuple{Vector{Term}}">Hermitian conjugate</a> and <a href="../core/#Main.FuzzifiED.SimplifyTerms-Tuple{Vector{Term}}">simplification</a> of terms. The following code measures the angular momentum of each eigenstate and verify whether <span>$|T\rangle$</span> is an eigenstate of <span>$L^2$</span> by measuring </p><p class="math-container">\[|L^2T\rangle=L^2|T\rangle,\quad\frac{|\langle T|L^2T\rangle|^2}{\langle T|T\rangle\langle L^2T|L^2T\rangle}\]</p><pre><code class="language-julia hljs">tms_lz = 
    [ begin m = div(o - 1, nf)
        Term(m - s, [1, o, 0, o])
    end for o = 1 : no ]
tms_lp = 
    [ begin m = div(o - 1, nf)
        Term(sqrt(m * (nm - m)), [1, o, 0, o - nf])
    end for o = nf + 1 : no ]
tms_lm = tms_lp&#39; 
tms_l2 = SimplifyTerms(tms_lz * tms_lz - tms_lz + tms_lp * tms_lm)</code></pre><h3 id="Go-through-all-the-sectors"><a class="docs-heading-anchor" href="#Go-through-all-the-sectors">Go through all the sectors</a><a id="Go-through-all-the-sectors-1"></a><a class="docs-heading-anchor-permalink" href="#Go-through-all-the-sectors" title="Permalink"></a></h3><p>One can repeat the calculation for all the sectors and records the results</p><pre><code class="language-julia hljs">result = []
for P in [1, -1], Z in [1, -1], R in [1, -1]
    bs = Basis(cfs, [P, Z, R], qnf)
    hmt = Operator(bs, tms_hmt)
    hmt_mat = OpMat(hmt ; type = Float64)
    enrg, st = GetEigensystem(hmt_mat, 10)

    l2 = Operator(bs, tms_l2)
    l2_mat = OpMat(l2 ; type = Float64)
    l2_val = [ st[:, i]&#39; * l2_mat * st[:, i] for i in eachindex(enrg)]

    for i in eachindex(enrg)
        push!(result, round.([enrg[i], l2_val[i], P, Z], digits = 6))
    end
end</code></pre><p>We then sort the eigenstates, find the energy of ground state and stress tensor, and calibrate the scaling dimensions. </p><pre><code class="language-julia hljs">sort!(result, by = st -&gt; real(st[1]))
enrg_0 = result[1][1]
enrg_T = filter(st -&gt; st[2] ≊ 6 &amp;&amp; st[3] ≊ 1 &amp;&amp; st[4] ≊ 1, result)[1][1]
result_dim = [ [ 3 * (st[1] - enrg_0) / (enrg_T - enrg_0) ; st] for st in result ]
for P in (1, -1), Z in (1, -1)
    display(permutedims(hcat(
        filter(st -&gt; st[4] ≊ P &amp;&amp; st[5] ≊ Z, result_dim)...
    )))
end</code></pre><h3 id="Measuring-the-density-operator"><a class="docs-heading-anchor" href="#Measuring-the-density-operator">Measuring the density operator</a><a id="Measuring-the-density-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Measuring-the-density-operator" title="Permalink"></a></h3><p>Similar process can be used to calculate the OPE coefficient by measuring the density operator, by definition </p><p class="math-container">\[\lambda_{\sigma\sigma\epsilon}=\frac{\langle\sigma|n^z_{00}|\epsilon\rangle}{\langle\sigma|n^z_{00}|\mathbb{I}\rangle},\quad n^z_{00}=\frac{1}{N_m}\sum_{\sigma m}\sigma c^\dagger_{\sigma m}c_{\sigma m}\]</p><p>To do that, we need to first repeat the calculation in the <span>$\mathbb{Z}_2$</span>-odd sector</p><pre><code class="language-julia hljs">bs1 = Basis(cfs, [1, -1, 1], qnf)
hmt = Operator(bs1, bs1, tms_hmt ; red_q = 1, sym_q = 1) 
hmt_mat = OpMat(hmt ; type = Float64)
enrg1, st1 = GetEigensystem(hmt_mat, 10)
st_I = st[:, 1] 
st_e = st[:, 2] 
st_s = st1[:, 1]</code></pre><p>The <a href="../models/#Main.FuzzifiED.SphereObs"><code>SphereObs</code></a> type stores the information of a local observable on the sphere. In particular, the <a href="../models/#Main.FuzzifiED.Electron-Tuple{Int64, Int64, Int64}">electron</a> and <a href="../models/#Main.FuzzifiED.Density-Tuple{Int64, Int64, Matrix{&lt;:Number}}">density operators</a> are built-in. The addition and multiplication of observables are enabled. It can be evaluated at a certain point <a href="../models/#Main.FuzzifiED.GetPointValue-Tuple{SphereObs, Float64, Float64}">GetPointValue</a> or angular component with <a href="../models/#Main.FuzzifiED.GetComponent-Tuple{SphereObs, Number, Number}"><code>GetComponent</code></a>. </p><pre><code class="language-julia hljs">obs_nz = Density(nm, 2, [ 1 0 ; 0 -1 ])
tms_nz = SimplifyTerms(GetComponent(obs_nz, 0.0, 0.0))
nz = Operator(bs, bs1, tms_nz ; red_q = 1) 
@show abs((st_s&#39; * nz * st_e) / (st_s&#39; * nz * st_I))</code></pre><h4 id="Primitive-version-5"><a class="docs-heading-anchor" href="#Primitive-version-5">Primitive version</a><a class="docs-heading-anchor-permalink" href="#Primitive-version-5" title="Permalink"></a></h4><p>Alternatively, one can write out the terms of density operator explicitly.</p><pre><code class="language-julia hljs"># Record the density operator n^z
tms_nz = [ Term(isodd(o) ? 1 / nm : -1 / nm, [1, o, 0, o]) for o = 1 : no]
# The nz operator sends a state in bs (+) to bs1 (-)
nz = Operator(bs, bs1, tms_nz ; red_q = 1)
# Measuring the finite size OPE
@show abs((st_s&#39; * nz * st_e) / (st_s&#39; * nz * st_I))</code></pre><h2 id="DMRG-calculations-with-FuzzifiED"><a class="docs-heading-anchor" href="#DMRG-calculations-with-FuzzifiED">DMRG calculations with FuzzifiED</a><a id="DMRG-calculations-with-FuzzifiED-1"></a><a class="docs-heading-anchor-permalink" href="#DMRG-calculations-with-FuzzifiED" title="Permalink"></a></h2><p>In this example, we calculate the ground state MPS of the fuzzy sphere Ising model by DMRG in ITensors, and use the same objects to do ED calculation and compare the result. </p><p>We first set-up the calculation by</p><pre><code class="language-julia hljs">using FuzzifiED
using ITensors
const σx = [  0  1 ;  1  0 ]
const σz = [  1  0 ;  0 -1 ]

nm = 12
nf = 2
no = nm * nf</code></pre><p>The first object we need is the sites. FuzzifiED overloads the fermion type and supports direct generation of the sites from the diagonal quantum numbers by the function <a href="../itensors/#Main.FuzzifiED.SitesFromQNDiag-Tuple{Vector{QNDiag}}"><code>SitesFromQNDiag</code></a>. The Ising model is expressed in the basis of <span>$XX-Z$</span> so that the flavour symmetry is diagonal. </p><pre><code class="language-julia hljs">sites = SitesFromQNDiag([
    GetNeQNDiag(nm * nf), 
    GetLz2QNDiag(nm, nf),
    GetZnfChargeQNDiag(nm, nf)
])</code></pre><p>We then generate the terms of the Hamiltonian using the built-in functions, convert it to <code>OpSum</code> type in by the <a href="../itensors/#Main.FuzzifiED.OpSumFromTerms-Tuple{Vector{Term}}"><code>OpSumFromTerms</code></a>, and convert it to MPO using the <code>MPO</code> function in ITensors</p><pre><code class="language-julia hljs">ps_pot = [4.75, 1.] ./ 2
tms_hmt = SimplifyTerms(
    GetDenIntTerms(nm, 2, ps_pot) - 
    GetDenIntTerms(nm, 2, ps_pot, σx) - 
    3.16 * GetPolTerms(nm, nf, σz)
)
@time mpo_hmt = MPO(OpSumFromTerms(tms_hmt), sites)</code></pre><p>We then use the all-up state as the initial state. In FuzzifiED, the occupied and empty sites are expressed by 0 and 1, while they are expressed by <code>&quot;0&quot;</code> and <code>&quot;1&quot;</code> in ITensors, so a conversion to string is needed. </p><pre><code class="language-julia hljs">cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]
st0 = MPS(sites, string.(cf0))</code></pre><p>After that, the Hamiltonian MPO and the initial state MPS can be used for input for DMRG calculation. </p><pre><code class="language-julia hljs">Eg, stg = dmrg(mpo_hmt, st0 ; nsweeps = 10, maxdim = [10,20,50,100,200,500], noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], cutoff = [1E-8])
@show Eg</code></pre><p>We then convert these objects for the ED calculate. The configurations can be generated from Sites and a reference configuration by the function <a href="../itensors/#Main.FuzzifiED.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}"><code>ConfsFromSites</code></a>. </p><pre><code class="language-julia hljs">cfs = ConfsFromSites(sites, cf0)
bs = Basis(cfs)
hmt = Operator(bs, tms_hmt)
hmt_mat = OpMat(hmt ; type = Float64)
enrg, st = GetEigensystem(hmt_mat, 10)
@show enrg</code></pre><h3 id="Use-EasySweep-to-manage-DMRG-sweeps"><a class="docs-heading-anchor" href="#Use-EasySweep-to-manage-DMRG-sweeps">Use EasySweep to manage DMRG sweeps</a><a id="Use-EasySweep-to-manage-DMRG-sweeps-1"></a><a class="docs-heading-anchor-permalink" href="#Use-EasySweep-to-manage-DMRG-sweeps" title="Permalink"></a></h3><p>EasySweep facilitates the management of DMRG process by automatically recording the intermediate results and recovering these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. Before the calculation, we need to define a method to generate MPO from OpSum and Sites. We suggest using <code>MPO_new</code> from package <code>ITensorMPOConstruction</code>, which can be installed through </p><pre><code class="language-julia hljs">julia&gt; Pkg.add(url=&quot;https://github.com/ITensor/ITensorMPOConstruction.jl.git&quot;); </code></pre><pre><code class="language-julia hljs">using ITensorMPOConstruction
function MyMPO(os, sites)
    operatorNames = [ &quot;I&quot;, &quot;C&quot;, &quot;Cdag&quot;, &quot;N&quot; ]
    opCacheVec = [ [OpInfo(ITensors.Op(name, n), sites[n]) for name in operatorNames] for n in eachindex(sites)  ]
    return MPO_new(os, sites ; basisOpCacheVec = opCacheVec)
end</code></pre><p>We also need to specify a path where the results are stored. </p><pre><code class="language-julia hljs">path = &quot;nm_$(nm)/&quot;
mkpath(path)</code></pre><p>The Hamiltonian MPO and the sites can be either generated or read from file by the function <a href="../archieve/#Main.FuzzifiED.GetMPOSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}}"><code>GetMPOSites</code></a>. The input is the quantum numbers and the terms or OpSum ; the output is the MPO and the sites</p><pre><code class="language-julia hljs">ps_pot = [4.75, 1.] ./ 2
tms_hmt = SimplifyTerms(
    GetDenIntTerms(nm, 2, ps_pot) - 
    GetDenIntTerms(nm, 2, ps_pot, σx) - 
    3.16 * GetPolTerms(nm, 2, σz)
)
qnd = [ 
    GetNeQNDiag(no), 
    GetLz2QNDiag(nm, nf), 
    GetZnfChargeQNDiag(nm, nf) 
]
hmt, sites = GetMPOSites(&quot;hmt&quot;, tms_hmt, qnd ; path, mpo_method = MyMPO)</code></pre><p>After generating the initial state MPS, the DMRG calculation of the states <span>$\mathbb{I}$</span> and <span>$\epsilon$</span> can be done by the <a href="../itensors/#Main.FuzzifiED.EasySweep-Tuple{String, MPO, MPS}"><code>EasySweep</code></a> function.  </p><pre><code class="language-julia hljs">cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]
st0 = MPS(sites, string.(cf0))
Eg, stg = EasySweep(&quot;g&quot;, hmt, st0 ; path)
Ee, ste = EasySweep(&quot;e&quot;, hmt, st0 ; path, proj = [&quot;g&quot;])</code></pre><p>The total angular momentum can be measured by generating the MPO of <span>$L^2$</span> and measure the inner product </p><pre><code class="language-julia hljs">tms_l2 = GetL2Terms(nm, 2)
l2 = GetMPO(&quot;l2&quot;, tms_l2, sites ; path)
@show inner(stg&#39;, l2, stg)</code></pre><p>The <span>$\mathbb{Z}_2$</span>-odd <span>$\sigma$</span> state can be calculated similarly.</p><pre><code class="language-julia hljs">cf1 = cf0
cf1[1] = 0
cf1[2] = 1
st1 = MPS(sites, string.(cf1))
Es, sts = EasySweep(&quot;s&quot;, hmt, st1 ; path)</code></pre><h2 id="List-of-examples"><a class="docs-heading-anchor" href="#List-of-examples">List of examples</a><a id="List-of-examples-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-examples" title="Permalink"></a></h2><p>The examples of FuzzifiED can be found in the repository <a href="https://github.com/mankai-chow/FuzzifiED.jl/tree/main/examples"><code>examples</code></a>. Apart from the tutorials that we have introduced above </p><ul><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/tutorial_ising.jl"><code>tutorial_ising.jl</code></a> does the ED calculation of Ising model through the built-in models. </li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/tutorial_ising_primitive.jl"><code>tutorial_ising_primitive.jl</code></a> does the ED calculation of Ising model through the primitive functions.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/tutorial_ising_dmrg.jl"><code>tutorial_ising_dmrg.jl</code></a> does the DMRG calculation of Ising model through the <code>dmrg</code> function in ITensors.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/tutorial_ising_dmrg_easysweep.jl"><code>tutorial_ising_dmrg_easysweep.jl</code></a> does the DMRG calculation of Ising model through the <code>EasySweep</code> function which wraps ITensors.</li></ul><p>We offer a series of other examples that reproduces various achievements of fuzzy sphere. For a more detailed summary of the background, please visit <a href="https://www.fuzzified.world/fuzzified-world">« The fuzzified world »</a>. </p><ul><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/ising_spectrum.jl"><code>ising_spectrum.jl</code></a> calculates the spectrum of 3d Ising model on fuzzy sphere at <span>$N_m = 12$</span>. For each <span>$(P,Z,R)$</span> sector, 20 states are calculated. This example reproduces Table I and Figure 4 in <a href="https://doi.org/10.1103/PhysRevX.13.021009">Phys. Rev. X 13, 021009 (2023)</a>.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/ising_phase_diagram.jl"><code>ising_phase_diagram.jl</code></a> calculates the phase diagram of fuzzy sphere Ising modelby calculating the order parameter <span>$\langle M^2\rangle$</span>. This example reproduces Figure 3 in <a href="https://doi.org/10.1103/PhysRevX.13.021009">Phys. Rev. X 13, 021009 (2023)</a>.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/ising_ope.jl"><code>ising_ope.jl</code></a>c alculates various OPE coefficients at <span>$N_m = 12$</span> by taking overlaps between CFT states and density operators and composite. This example reproduces Figure 2 and Table I in <a href="https://doi.org/10.1103/PhysRevLett.131.031601">Phys. Rev. Lett 131, 031601 (2023)</a>. </li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/ising_correlator.jl"><code>ising_correlator.jl</code></a> calculates the <span>$σσ$</span> two-point function on sphere and the <span>$σσσσ$</span> four-point function on sphere, 0 and <span>$∞$</span>. This example reproduces Figures 1c and 2a in <a href="https://doi.org/10.1103/PhysRevB.108.235123">Phys. Rev. B 108, 235123 (2023)</a></li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/ising_optimisation.jl"><code>ising_optimisation.jl</code></a> defines a cost function as the square sum of the deviations of descendants and stress tensor to evaluate the conformal symmetry for Ising model and minimises this cost function to find the best parameter.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/ising_full_spectrum.jl"><code>ising_full_spectrum.jl</code></a> calculates the full spectrum of 3d Ising model on fuzzy sphere at <span>$N_m = 10$</span> for sector <span>$(P,Z,R) = (1,1,1)$</span>.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/ising_space_entangle.jl"><code>ising_space_entangle.jl</code></a> calculates the entanglement entropy of the Ising ground state along the real space cut of <span>$θ = 0.500π$</span> and <span>$0.499π$</span> respectively, and use these two data to extract finite size <span>$F$</span>-function without sustracting the IQHE contribution. This example reproduces Figures 3 in <a href="https://arxiv.org/abs/2401.17362">arXiv : 2401.17362</a>.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/ising_space_entangle.jl"><code>ising_orbital_entangle.jl</code></a> calculates the entanglement entropy of the Ising ground state along the orbital space cut at <span>$m = 0$</span>, and also the entanglement spectrum in the half-filled <span>$l_z = 0, 1$</span> and  both <span>$\mathbb{Z}_2$</span> sectors.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/defect_spectrum.jl"><code>defect_spectrum.jl</code></a> calculates the spectrum of magnetic line defect in 3d Ising model in <span>$l_z = 0, P = ±1$</span> and <span>$l_z = 1$</span> sectors, calibrated by bulk <span>$T$</span>. This example reproduces Table I in <a href="https://doi.org/10.1038/s41467-024-47978-y">Nat. Commun. 15, 3659 (2024)</a>.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/defect_correlator.jl"><code>defect_correlator.jl</code></a> calculates the 1-pt function <span>$σ$</span> and 2-pt function <span>$σϕ$</span> of magnetic line defect in 3d Ising model. The normalisation of the correlators require extra bulk data. This example reproduces Figure 4 in <a href="https://doi.org/10.1038/s41467-024-47978-y">Nat. Commun. 15, 3659 (2024)</a>.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/defect_changing.jl"><code>defect_changing.jl</code></a> calculates the spectrum of the defect creation and changing operators of the magnetic line defect in 3d Ising model. This example reproduces Table 2 and Figure 5 in <a href="https://arxiv.org/abs/2401.00039">arXiv : 2401.00039</a>.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/defect_overlap.jl"><code>defect_overlap.jl</code></a> calculates the <span>$g$</span>-function of magnetic line defect in 3d Ising model using the ovelaps between the bulk, defect ground state and the lowest defect-creation state. This example reproduces Figure 6 in <a href="https://arxiv.org/abs/2401.00039">arXiv : 2401.00039</a>.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/o3_wf_spectrum.jl"><code>o3_wf_spectrum.jl</code></a> calculates the spectrum of <span>$\mathrm{O}(3)$</span> Wilson-Fisher CFT using the bilayer Heisenberg model. This example reproduces Table I and Figure 2 in <a href="https://arxiv.org/abs/2312.04047">arXiv : 2312.04047</a>.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/o3_spectrum.jl"><code>so5_spectrum.jl</code></a> calculates the spectrum of SO(5) DQCP on fuzzy sphere. This example reproduces Table II in <a href="https://arxiv.org/abs/2306.16435">arXiv : 2306.16435</a>.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../core/">Core functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 12 June 2024 15:05">Wednesday 12 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
