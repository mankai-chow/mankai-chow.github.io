<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · FuzzifiED.jl</title><meta name="title" content="Reference · FuzzifiED.jl"/><meta property="og:title" content="Reference · FuzzifiED.jl"/><meta property="twitter:title" content="Reference · FuzzifiED.jl"/><meta name="description" content="Documentation for FuzzifiED.jl."/><meta property="og:description" content="Documentation for FuzzifiED.jl."/><meta property="twitter:description" content="Documentation for FuzzifiED.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FuzzifiED.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../example/">Example</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Core"><span>Core</span></a></li><li><a class="tocitem" href="#ITensors-support"><span>ITensors support</span></a></li><li><a class="tocitem" href="#Built-in-models"><span>Built-in models</span></a></li></ul></li><li><a class="tocitem" href="../releases/">Releases</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mankai-chow/fuzzifi_ed" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mankai-chow/fuzzifi_ed/blob/main/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Core"><a class="docs-heading-anchor" href="#Core">Core</a><a id="Core-1"></a><a class="docs-heading-anchor-permalink" href="#Core" title="Permalink"></a></h2><h3 id="Configurations"><a class="docs-heading-anchor" href="#Configurations">Configurations</a><a id="Configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Configurations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Confs" href="#Main.FuzzifiED.Confs"><code>Main.FuzzifiED.Confs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Confs</code></pre><p>This type stores all the configurations that respects the conserved quantities and also a table to inversely look up the index from the configuration. </p><p><strong>Fields</strong></p><ul><li><code>no :: Int64</code> is the number of orbitals</li><li><code>ncf :: Int64</code> is the number of configurations </li><li><code>conf :: Vector{Int64}</code> is an array of length <code>ncf</code> containing all the configurations. Each configuration is expressed in a binary number. If the <code>o-1</code>-th bit of <code>conf[i]</code> is 1, then the <code>o</code>-th orbital in the <code>i</code>-th configuration is occupied ; if the bit is 0, then the orbital is empty. </li><li><code>nor :: Int64</code>, <code>lid :: Vector{Int64}</code> and <code>rid :: Vector{Int64}</code> contain the information of Lin table that is used to inversely look up the index <code>i</code> from the configuration. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/confs.jl#L1-L12">source</a></section></article><p>It can be generated by the following method.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}" href="#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}"><code>Main.FuzzifiED.Confs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Vector{Int64}} ; nor :: Int64 = div(no, 2), modul :: Vector{Int64}) :: Confs</code></pre><p>generates the configurations that has the diagonal quantum numbers given by <code>qnu_s</code> of certain conserved quantities specified by <code>qnu_o :: Vector{Vector{Int64}}</code></p><p class="math-container">\[Q_i=\sum_{o=1}^{N_o}q_{io}n_o\]</p><p>or</p><p class="math-container">\[Q_i=\sum_{o=1}^{N_o}q_{io}n_o\ \mathrm{mod}\ p_i\]</p><p>where <span>$i=1,\dots,N_U$</span> is the index of conserved quantities, <span>$o$</span> is the index of orbital, <span>$n_o=c^\dagger_oc_o$</span>, and <span>$q_o$</span> is a set of coefficients that must be non negative integer valued. </p><p><strong>Arguments</strong></p><ul><li><code>no :: Int64</code> is the number of orbitals <span>$N_o$</span> ;</li><li><code>qnu_s :: Vector{Int64}</code> is the set of <span>$Q_i$</span> for the selected configurations ;</li><li><code>qnu_o :: Vector{Vector{Int64}}</code> is the set of <span>$q_{io}$</span> for each quantum number and for each orbital. It should contain <span>$N_U$</span> elements and each element should be a vector of length <span>$N_o$</span>. </li><li><code>nor :: Int64</code> is the number of less significant bits used to generate the Lin table. Facultive, <span>$N_o/2$</span> by default.</li><li><code>modul :: Vector{Int64}</code> is the modulus of each quantum number. Setting it to 1 means there is no modulus. Facultive, all 1 by default. </li></ul><p><strong>Output</strong></p><ul><li><code>cfs :: Confs</code> is a <a href="#Main.FuzzifiED.Confs"><code>Confs</code></a> object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/confs.jl#L23-L47">source</a></section></article><p>The inverse look-back for a configuration can be done by </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetConfId-Tuple{Confs, Int64}" href="#Main.FuzzifiED.GetConfId-Tuple{Confs, Int64}"><code>Main.FuzzifiED.GetConfId</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GetConfId(cfs :: Confs, cf :: Int64) :: Int64</code></pre><p>inversely look up the index from the configuration</p><p><strong>Arguments</strong></p><ul><li><code>cfs :: Confs</code> stores the configurations.</li><li><code>cf :: Int64</code> stores the configuration to be looked-up expressed in a binary number. If the <code>o-1</code>-th bit of <code>conf[i]</code> is 1, then the <code>o</code>-th orbital in the <code>i</code>-th configuration is occupied ; if the bit is 0, then the orbital is empty. </li></ul><p><strong>Output</strong></p><ul><li><code>id :: Int64</code> is the id of the configuration such that <code>cfs.conf[id] == cf</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/confs.jl#L62-L75">source</a></section></article><h3 id="Basis"><a class="docs-heading-anchor" href="#Basis">Basis</a><a id="Basis-1"></a><a class="docs-heading-anchor-permalink" href="#Basis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Basis" href="#Main.FuzzifiED.Basis"><code>Main.FuzzifiED.Basis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Basis</code></pre><p>This type stores the information of the basis that respects both the conserved quantities and the discrete symmetries. The states in the basis is in the form </p><p class="math-container">\[|I\rangle=\lambda_{i_{I1}}|i_{I1}\rangle+\lambda_{i_{I2}}|i_{I2}\rangle+\cdots+\lambda_{i_{Im_I}}|i_{Im_I}\rangle\]</p><p>where <span>$|i\rangle$</span> is a direct product state, <em>i.e.</em>, the configurations <span>$|i_{Ik}\rangle$</span> are grouped into a state <span>$|I\rangle$</span>. </p><p><strong>Fields</strong></p><ul><li><code>cfs :: Confs</code> stores the configurations that respect the conserved quantities ;</li><li><code>dim :: Int64</code> is the dimension of the basis ;</li><li><code>szz :: Int64</code> records the maximum size <span>$\max m_g$</span> of groups;</li><li><code>cfgr :: Vector{Int64}</code> is a vector of length <code>cfs.ncf</code> and records which group <span>$|I\rangle$</span> each configuration <span>$|i\rangle$</span> belong to ;</li><li><code>cffac :: Vector{ComplexF64}</code> is a vector of length <code>cfs.ncf</code> and records the coefficients <span>$\lambda_i$</span> of each configuration ;</li><li><code>grel :: Matrix{Int64}</code> is a <code>szz</code><code>\*</code><code>dim</code> matrix that records the configurations in each group <span>$|i_{Ik}\rangle (k = 1,\dots,m_I)$</span></li><li><code>grsz :: Vector{Int64}</code> is a vector of length <code>dim</code> that records the size <span>$m_I$</span> of each group.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/basis.jl#L1-L18">source</a></section></article><p>It can be generated by the following methods.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Basis-Tuple{Confs, Vector{ComplexF64}, Vector{Int64}, Vector{Any}, Vector{Any}, Vector{Any}}" href="#Main.FuzzifiED.Basis-Tuple{Confs, Vector{ComplexF64}, Vector{Int64}, Vector{Any}, Vector{Any}, Vector{Any}}"><code>Main.FuzzifiED.Basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Basis(cfs :: Confs, qnz_s :: Vector{ComplexF64}, cyc :: Vector{Int64}, perm_o :: Vector{Vector{Int64}}, ph_o :: Vector{Vector{Int64}}, fac_o :: Vector{Vector{ComplexF64}}) :: Basis</code></pre><p>generates the basis that respects the discrete symmetries from the configurations that respects the conserved quantities. The discrete <span>$\mathbb{Z}_n$</span> symmetries are in the form of </p><p class="math-container">\[\mathscr{Z}:\ c_o\to \alpha_o^* c^{(p_o)}_{\pi_o},\quad c_o^\dagger\to \alpha_o c^{(1-p_o)}_{\pi_o}\]</p><p>where we use a notation <span>$c^{(1)}=c^\dagger$</span> and <span>$c^{0}=c$</span> for convenience, where <span>$\pi_o$</span> is a permutation of <span>$1,\dots N_o$</span>, <span>$\alpha_o$</span> is a coefficient, and <span>$p_o$</span> specified whether or not particle-hole transformation is performed for the orbital. Note that one must guarentee that all these transformations commute with each other and also commute with the conserved quantities. </p><p><strong>Arguments</strong></p><ul><li><code>cfs :: Confs</code> is the set of configurations with only conserved quantities ;</li><li><code>qnz_s :: Vector{ComplexF64}</code> is a vector of length the same as the number of discrete symmetries that records the eigenvalue of each transformation ;</li><li><code>cyc :: Vector{Int64}</code> records the cycle of each transformation. For <span>$\mathbb{Z}_n$</span> symmetry, record <span>$n$</span> ;</li><li><code>perm_o :: Vector{Vector{Int64}}</code> records the permutation <span>$\pi_o$</span>. It has <span>$N_Z$</span> elements and each of its elements is a vector of length <span>$N_o$</span>. </li><li><code>ph_o :: Vector{Vector{Int64}}</code> records <span>$p_o$</span> to determine whether or not to perform a particle-hole transformation. It has <span>$N_Z$</span> elements and each of its elements is a vector of length <span>$N_o$</span>. </li><li><code>fac_o :: Vector{Vector{ComplexF64}}</code> records the factor <span>$p_o$</span> is determine whether or not to perform a particle-hole transformation. Each of its elements is a vector of length <span>$N_o$</span>. </li></ul><p><strong>Output</strong></p><ul><li><code>bs :: Basis</code> is the resulting <code>Basis</code> object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/basis.jl#L30-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Basis-Tuple{Confs}" href="#Main.FuzzifiED.Basis-Tuple{Confs}"><code>Main.FuzzifiED.Basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Basis(cfs :: Confs) :: Basis</code></pre><p>Generate a basis from the configurations without applying the <span>$\mathbb{Z}_2$</span> symmetries.</p><p><strong>Arguments</strong></p><ul><li><code>cfs :: Confs</code> is the set of configurations with only conserved quantities ;</li></ul><p><strong>Output</strong></p><ul><li><code>bs :: Basis</code> is the resulting <code>Basis</code> object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/basis.jl#L73-L85">source</a></section></article><p>The look-back of the weight of a configuration in a state can be done by </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetConfWeight-Tuple{Basis, Vector, Int64}" href="#Main.FuzzifiED.GetConfWeight-Tuple{Basis, Vector, Int64}"><code>Main.FuzzifiED.GetConfWeight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GetConfWeight(bs :: Basis, st :: Vector{ComplexF64}, cf :: Int64) :: ComplexF64
GetConfWeight(bs :: Basis, st :: Vector{Float}, cf :: Int64) :: ComplexF64</code></pre><p>looks up a the weight of a configuration in a state. </p><p><strong>Arguments</strong></p><ul><li><code>bs :: Basis</code> is the basis of the state ; </li><li><code>st :: Vector{ComplexF64}</code> or <code>st :: Vector{Float64}</code> is a vector of length <code>bs.dim</code> that stores the state ; </li><li><code>cf :: Int64</code> stores the configuration to be looked-up expressed in a binary number. If the <code>o-1</code>-th bit of <code>conf[i]</code> is 1, then the <code>o</code>-th orbital in the <code>i</code>-th configuration is occupied ; if the bit is 0, then the orbital is empty. </li></ul><p><strong>Output</strong></p><ul><li>The weight of the configuration in the state </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/basis.jl#L98-L114">source</a></section></article><h3 id="Term"><a class="docs-heading-anchor" href="#Term">Term</a><a id="Term-1"></a><a class="docs-heading-anchor-permalink" href="#Term" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Term" href="#Main.FuzzifiED.Term"><code>Main.FuzzifiED.Term</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Term</code></pre><p>A <code>Term</code> object records a term that looks like <span>$Uc^{(p_1)}_{o_1}c^{(p_2)}_{o_2}\dots c^{(p_l)}_{o_l}$</span> in an operator</p><p><strong>Fields</strong></p><ul><li><code>coeff :: ComplexF64</code> records the coefficient <span>$U$</span></li><li><code>cstr :: Vector{Int64}</code> is a length-<span>$2l$</span> vector <span>$(p_1,o_1,p_2,o_2,\dots p_l,o_l)$</span> recording the operator string</li></ul><p><strong>Method</strong></p><p>It can be generated by the function</p><pre><code class="nohighlight hljs">function Term(coeff :: ComplexF64, cstr :: Vector{Int64}) :: ComplexF64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/term.jl#L1-L15">source</a></section></article><p>The product of terms with a number, the sum and product of terms and the adjoint is defined</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{Number, Vector{Term}}" href="#Base.:*-Tuple{Number, Vector{Term}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function *(fac :: Number, tms :: Vector{Term}) :: Vector{Term}
function -(tms :: Vector{Term}) :: Vector{Term}
function *(tms :: Vector{Term}, fac :: Number) :: Vector{Term}
function /(tms :: Vector{Term}, fac :: Number) :: Vector{Term}</code></pre><p>Return the product of a collection of terms with a number. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/term.jl#L22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{Vector{Term}, Vector{Term}}" href="#Base.:+-Tuple{Vector{Term}, Vector{Term}}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function +(tms1 :: Vector{Term}, tms2 :: Vector{Term}) :: Vector{Term}
function -(tms1 :: Vector{Term}, tms2 :: Vector{Term}) :: Vector{Term}</code></pre><p>Return the naive sum of two series of terms by taking their union. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/term.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{Vector{Term}, Vector{Term}}" href="#Base.:*-Tuple{Vector{Term}, Vector{Term}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function *(tms1 :: Vector{Term}, tms2 :: Vector{Term}) :: Vector{Term}</code></pre><p>Return the naive product of two series of terms. The number of terms equals the product of the number of terms in <code>tms1</code> and <code>tms2</code>. For each term in <code>tms1</code> <span>$Uc^{(p_1)}_{o_1}\dots$</span> and <code>tms2</code> <span>$U&#39;c^{(p&#39;_1)}_{o&#39;_1}\dots$</span>, a new term is formed by taking <span>$UU&#39;c^{(p_1)}_{o_1}\dots c^{(p&#39;_1)}_{o&#39;_1}\dots$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/term.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint-Tuple{Vector{Term}}" href="#Base.adjoint-Tuple{Vector{Term}}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function adjoint(tm :: Term) :: Term
function adjoint(tms :: Vector{Term}) :: Vector{Term}</code></pre><p>Return the Hermitian conjugate of a series of terms. For each term <span>$Uc^{(p_1)}_{o_1}c^{(p_2)}_{o_2}\dots c^{(p_l)}_{o_l}$</span>, the adjoint is <span>$\bar{U}c^{(1-p_l)}_{o_l}\dots c^{(1-p_2)}_{o_2}c^{(1-p_1)}_{o_1}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/term.jl#L71-L76">source</a></section></article><p>The terms can be simplified by </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.NormalOrder-Tuple{Term}" href="#Main.FuzzifiED.NormalOrder-Tuple{Term}"><code>Main.FuzzifiED.NormalOrder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function NormalOrder(tm :: Term) :: Vector{Term}</code></pre><p>rearrange a term such that </p><ul><li>the creation operators must be commuted in front of the annihilation operator </li><li>the orbital index of the creation operators are in ascending order and the annihilation operators in descending order. </li></ul><p>return a list of terms whose result is equal to the original term. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/term.jl#L82-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.SimplifyTerms-Tuple{Vector{Term}}" href="#Main.FuzzifiED.SimplifyTerms-Tuple{Vector{Term}}"><code>Main.FuzzifiED.SimplifyTerms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function SimplifyTerms(tms :: Vector{Term}) :: Vector{Term}</code></pre><p>simplifies the sum of terms such that </p><ul><li>each term is normal ordered,</li><li>like terms are combined, and terms with zero coefficients are removed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/term.jl#L126-L132">source</a></section></article><h3 id="Operator"><a class="docs-heading-anchor" href="#Operator">Operator</a><a id="Operator-1"></a><a class="docs-heading-anchor-permalink" href="#Operator" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Operator" href="#Main.FuzzifiED.Operator"><code>Main.FuzzifiED.Operator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Operator</code></pre><p>An <code>Operator</code> object records the sum of terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.</p><p><strong>Fields</strong></p><ul><li><code>bsd :: Basis</code> is the basis of the initial state ;</li><li><code>bsf :: Basis</code> is the basis of the final state ;</li><li><code>red_q :: Int64</code> is a flag that records whether or not the conversion to a sparse martrix can be simplified : if <code>bsd</code> and <code>bsf</code> have exactly the same quantum numbers, and the operator fully respects the symmetries, and all the elements in <code>bsd.cffac</code> and <code>bsf.cffac</code> has the same absolute value, then <code>red_q = 1</code> ; otherwise <code>red_q = 0</code> ; </li><li><code>sym_q :: Int64</code> records the symmetry of the operator : if the matrix is Hermitian, then <code>sym_q = 1</code> ; if it is symmetric, then <code>sym_q = 2</code> ; otherwise <code>sym_q = 0</code> ;</li><li><code>ntm :: Int64</code> is the number of terms ;</li><li><code>nc :: Int64</code> is the maximum number of operators in an operator string</li><li><code>cstrs :: Matrix{Int64}</code> is a matrix recording the operator string of each term. Each column corresponds to a term and is padded to the maximum length with <code>-1</code>&#39;s.</li><li><code>coeffs :: Vector{ComplexF64}</code> corresponds to the coefficients in each term.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/operator.jl#L1-L15">source</a></section></article><p>It can be generated by the following methods.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Operator-Tuple{Basis, Basis, Vector{Term}}" href="#Main.FuzzifiED.Operator-Tuple{Basis, Basis, Vector{Term}}"><code>Main.FuzzifiED.Operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Operator(bsd :: Basis, bsf :: Basis, terms :: Vector{Term} ; red_q :: Int64, sym_q :: Int64) :: Operator</code></pre><p>generates an operator object from a series of terms. </p><p><strong>Arguments</strong></p><ul><li><code>bsd :: Basis</code> is the basis of the initial state ;</li><li><code>bsf :: Basis</code> is the basis of the final state ;</li><li><code>terms :: Vector{Term}</code> records the terms ; </li><li><code>red_q :: Int64</code> is a flag that records whether or not the conversion to a sparse martrix can be simplified : if <code>bsd</code> and <code>bsf</code> have exactly the same quantum numbers, and the operator fully respects the symmetries, and all the elements in <code>bsd.cffac</code> and <code>bsf.cffac</code> has the same absolute value, then <code>red_q = 1</code> ; otherwise <code>red_q = 0</code> ; </li><li><code>sym_q :: Int64</code> records the symmetry of the operator : if the matrix is Hermitian, then <code>sym_q = 1</code> ; if it is symmetric, then <code>sym_q = 2</code> ; otherwise <code>sym_q = 0</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/operator.jl#L28-L39">source</a></section></article><p>The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{Operator, Vector{ComplexF64}}" href="#Base.:*-Tuple{Operator, Vector{ComplexF64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function *(op :: Operator, st_d :: Vector{ComplexF64}) :: Vector{ComplexF64}
function *(op :: Operator, st_d :: Vector{Float64}) :: Vector{Float64}</code></pre><p>Measure the action of an operator on a state. <code>st_d</code> must be of length <code>op.bsd.dim</code>. Returns a vector of length <code>op.bsf.dim</code> that represents the final state. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/operator.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, Operator, Vector{ComplexF64}}" href="#Base.:*-Tuple{LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, Operator, Vector{ComplexF64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function *(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64}) :: ComplexF64
function *(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, op :: Operator, st_d :: Vector{Float64}) :: Float64</code></pre><p>Measuring the inner product between two states and an operator. <code>st_d</code> must be of length <code>op.bsd.dim</code> and <code>st_fp</code> must be of length <code>op.bsf.dim</code>, and <code>st_fp</code> must be an adjoint. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/operator.jl#L75-L80">source</a></section></article><h3 id="Sparse-matrix"><a class="docs-heading-anchor" href="#Sparse-matrix">Sparse matrix</a><a id="Sparse-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-matrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.OpMat" href="#Main.FuzzifiED.OpMat"><code>Main.FuzzifiED.OpMat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct OpMat{Complex64}
mutable struct OpMat{Float64}</code></pre><p>This type stores a sparse matrix in the same form as <code>SparseMatrixCSC</code> in <code>SparseArrays</code>. If the matrix is Hermitian or symmetric, only the lower triangle is stored. </p><p><strong>Fields</strong></p><ul><li><code>dimd :: Int64</code> and <code>dimf :: Int64</code> are the number of columns and rows of the matrix ;</li><li><code>symq :: Int64</code> records whether or not the matrix is Hermitian or symmetric ;</li><li><code>nel :: Int64</code> records the number of elements ;</li><li><code>colptr :: Vector{Int64}</code>, <code>rowid :: Vector{Int64}</code> and <code>elval :: Vector{ComplexF64}</code> records the elements of the sparse matrix as in the <code>SparseMatrixCSC</code> elements of Julia. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/opmat.jl#L1-L12">source</a></section></article><p>It can be generated by the following methods.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.OpMat-Tuple{Operator}" href="#Main.FuzzifiED.OpMat-Tuple{Operator}"><code>Main.FuzzifiED.OpMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function OpMat(op :: Operator ; type :: DataType = ComplexF64) :: OpMat{type}</code></pre><p>Generates the sparse matrix from the operator</p><p><strong>Arguments</strong></p><ul><li><code>op :: Operator</code> is the operator ;</li><li><code>type :: DataType</code> specifies the type of the matrix. It can either be <code>ComplexF64</code> or <code>Float64</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/opmat.jl#L23-L32">source</a></section></article><p>The lowest eigenstates of the sparse matrix can be calculated by </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetEigensystem-Tuple{OpMat{ComplexF64}, Int64}" href="#Main.FuzzifiED.GetEigensystem-Tuple{OpMat{ComplexF64}, Int64}"><code>Main.FuzzifiED.GetEigensystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64, ncv :: Int64) :: Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}
function GetEigensystem(mat :: OpMat{Float64}, nst :: Int64 ; tol :: Float64, ncv :: Int64) :: Tuple{Vector{Float64}, Matrix{Float64}}</code></pre><p>calls the Arpack package to calculate the lowest eigenstates of sparse matrix. </p><p><strong>Arguments</strong></p><ul><li><code>mat :: OpMat{ComplexF64}</code> is the matrix ;</li><li><code>nst :: Int64</code> is the number of eigenstates to be calculated ;</li><li><code>tol :: Float64</code> is the tolerence for the Arpack process. The default value is <code>1E-8</code> ;</li><li><code>ncv :: Int64</code> is an euxiliary parameter needed in the Arpack process. The default value is <code>max(2 * nst, nst + 10)</code></li></ul><p><strong>Output</strong></p><ul><li>A length-<code>nst</code> array that has the same type as <code>mat</code> recording the eigenvalues, and </li><li>A <code>dimd</code>*<code>nst</code> matrix that has the same type as <code>mat</code> where every column records an eigenstate. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/opmat.jl#L58-L75">source</a></section></article><p>The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{OpMat{ComplexF64}, Vector{ComplexF64}}" href="#Base.:*-Tuple{OpMat{ComplexF64}, Vector{ComplexF64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function *(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64}) :: Vector{ComplexF64}
function *(mat :: OpMat{Float64}, st_d :: Vector{Float64}) :: Vector{Float64}</code></pre><p>Measure the action of a sparse matrix on a state. <code>st_d</code> must be of length <code>mat.dimd</code>. Returns a vector of length <code>mat.dimf</code> that represents the final state. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/opmat.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, OpMat{ComplexF64}, Vector{ComplexF64}}" href="#Base.:*-Tuple{LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, OpMat{ComplexF64}, Vector{ComplexF64}}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function *(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64}) :: ComplexF64
function *(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, mat :: OpMat{Float64}, st_d :: Vector{Float64}) :: Float64</code></pre><p>Measuring the inner product between two states and a sparse matrix. <code>st_d</code> must be of length <code>mat.dimd</code> and <code>st_fp</code> must be of length <code>mat.dimf</code>, and <code>st_fp</code> must be an adjoint. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/opmat.jl#L107-L112">source</a></section></article><p>Note that sometimes it is needed to transform a state from one basis to another. This can be done by constructing an identity operator. </p><pre><code class="language-julia hljs">stf = Operator(bsd, bsf, [Term(1., [-1, -1])]) * std</code></pre><p>The <code>OpMat</code> object can be converted with the <code>SparseMatrixCSC</code> object in the <code>SparseArrays</code> package. This will allow, <em>e.g.</em>, full diagonalisation using the linear algebra package of julia. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.SparseMatrixCSCFromOpMat-Tuple{OpMat}" href="#Main.FuzzifiED.SparseMatrixCSCFromOpMat-Tuple{OpMat}"><code>Main.FuzzifiED.SparseMatrixCSCFromOpMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SparseMatrixCSCFromOpMat(mat :: OpMat{ComplexF64}) :: SparseMatrixCSC{Int64,ComplexF64}
SparseMatrixCSCFromOpMat(mat :: OpMat{Float64}) :: SparseMatrixCSC{Int64,Float64}</code></pre><p>converts the <code>OpMat</code> objects to a <code>SparseMatrixCSC</code> object in the <code>SparseArrays</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/opmat.jl#L125-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.OpMat-Tuple{SparseMatrixCSC}" href="#Main.FuzzifiED.OpMat-Tuple{SparseMatrixCSC}"><code>Main.FuzzifiED.OpMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OpMat(matcsc :: SparseMatrixCSC{Int64,ComplexF64}) :: OpMat{ComplexF64}
OpMat(matcsc :: SparseMatrixCSC{Int64,Float64}) :: OpMat{Float64}</code></pre><p>converts the <code>SparseMatrixCSC</code> object in the <code>SparseArrays</code> package to an <code>OpMat</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/core/opmat.jl#L143-L148">source</a></section></article><h2 id="ITensors-support"><a class="docs-heading-anchor" href="#ITensors-support">ITensors support</a><a id="ITensors-support-1"></a><a class="docs-heading-anchor-permalink" href="#ITensors-support" title="Permalink"></a></h2><p>This package also supports convertion with the <code>Site</code> and <code>OpSum</code> objects from <code>ITensors</code> library and management of DMRG sweeping process. To use these functions, include</p><pre><code class="language-julia hljs">using ITensors</code></pre><p>at the heading of the Julia script.</p><h3 id="Format-conversion"><a class="docs-heading-anchor" href="#Format-conversion">Format conversion</a><a id="Format-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Format-conversion" title="Permalink"></a></h3><p>The <code>Sites</code> objects in <code>ITensors</code> can be converted to a <code>Confs</code> object with the conserved quantities extracted. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}" href="#Main.FuzzifiED.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}"><code>Main.FuzzifiED.ConfsFromSites</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, qn_s :: QN) :: Confs</code></pre><p>Converts a <code>Sites</code> object in the <code>ITensors</code> package to the <code>Confs</code> object</p><p><strong>Arguments</strong></p><ul><li><code>sites :: Vector{Index{Vector{Pair{QN, Int64}}}}</code> is a <code>Sites</code> object. Only <code>Fermion</code> site type is supported, and the quantum numbers of the <code>0</code> state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4. </li><li><code>qn_s :: QN</code> is a <code>QN</code> object that specifies the the quantum number of the selected configuration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/itensors_support/itensors_format.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, Vector{Int64}}" href="#Main.FuzzifiED.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, Vector{Int64}}"><code>Main.FuzzifiED.ConfsFromSites</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, cf_ref :: Vector{Int64}) :: Confs</code></pre><ul><li><code>sites :: Vector{Index{Vector{Pair{QN, Int64}}}}</code> is a <code>Sites</code> object, where the modulus-<span>$\pm 1$</span> quantum numbers will be taken out, and QNs with other modulus will be discarded automatically. Also note that only <code>Fermion</code> site type is supported, and the quantum numbers of the <code>0</code> state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4. </li><li><code>cf_ref :: Vector{Int64})</code> is a reference configuration composed of <code>0</code> and <code>1</code> in <code>ITensors</code> format.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/itensors_support/itensors_format.jl#L36-L42">source</a></section></article><p>Conversely, the  <code>Sites</code> objects in <code>ITensors</code> can also be generated from a set of diagonal quantum numbers </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.SitesFromQnu-Tuple{}" href="#Main.FuzzifiED.SitesFromQnu-Tuple{}"><code>Main.FuzzifiED.SitesFromQnu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function SitesFromQnu(; qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64})</code></pre><p>returns the ITensors Sites object from the information of quantum numbers </p><p><strong>Arguments</strong></p><ul><li><code>qnu_o :: Vector{Vector{Int64}}</code> stores the charge of each orbital under each conserved quantity. See <a href="#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}"><code>Confs</code></a> for detail. </li><li><code>qnu_name :: Vector{String}</code> stores the name of each quantum number. Facultive, QN1, QN2, ... by default. </li><li><code>modul :: Vector{Int64}</code> stores the modulus of each quantum number. Store 1 if no modulus. Facultive, all 1 by default. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/itensors_support/itensors_format.jl#L108-L118">source</a></section></article><p>If the number of quantum numbers are too many, it can be truncated by </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.TruncateQnu-Tuple{}" href="#Main.FuzzifiED.TruncateQnu-Tuple{}"><code>Main.FuzzifiED.TruncateQnu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TruncateQnu(; qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, trunc_lth :: Int64, trunc_wt :: Vector{Int64})</code></pre><p>truncates the list of <span>$N_U$</span> QNU&#39;s from to a number <span>$N&#39;_U$</span> acceptable by ITensors. The new quantum numbers are </p><p class="math-container">\[    Q&#39;_1=Q_1,\ Q&#39;_2=Q_2,\ \dots,\ Q&#39;_{N&#39;_U-1}=Q_{N&#39;_U-1}\ Q&#39;_{N&#39;_U}=\lambda_{N&#39;_U}Q_{N&#39;_U}+\lambda_{N&#39;_U+1}Q_{N&#39;_U+1}+\dots+\lambda_{N_U}Q_{N_U}\]</p><p><strong>Arguments</strong></p><ul><li><code>qnu_o :: Vector{Vector{Int64}}</code> stores the charge of each orbital under each conserved quantity. See <a href="#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}"><code>Confs</code></a> for detail. </li><li><code>qnu_name :: Vector{String}</code> stores the name of each quantum number. Facultive, QN1, QN2, ... by default. </li><li><code>modul :: Vector{Int64}</code> stores the modulus of each quantum number. Store 1 if no modulus. Facultive, all 1 by default. </li><li><code>trunc_lth :: Int64</code> stores the truncated numbers of QNU. Facultive, 3 by default. </li><li><code>trunc_wt :: Vecotr{Int64}</code> stores the <span>$N_U-N&#39;_U+1$</span> coefficients <span>$\lambda$</span>. Facultive, <span>$1,2,4,8,\dots$</span> by default. </li></ul><p><strong>Output</strong></p><p>A named tuple with three elements that can be directly fed into <a href="#Main.FuzzifiED.SitesFromQnu-Tuple{}"><code>SitesFromQnu</code></a></p><ul><li><code>qnu_o :: Vector{Vector{Int64}}</code> stores the charge of each orbital under each conserved quantity. See <a href="#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}"><code>Confs</code></a> for detail.</li><li><code>qnu_name :: Vector{String}</code> stores the name of each quantum number.</li><li><code>modul :: Vector{Int64}</code> stores the modulus of each quantum number, 1 if no modulus. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/itensors_support/itensors_format.jl#L78-L102">source</a></section></article><p>The <code>OpSum</code> objects in <code>ITensors</code> can be converted with the collection of <code>Term</code>&#39;s</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.TermsFromOpSum-Tuple{Sum{Scaled{ComplexF64, Prod{Op}}}}" href="#Main.FuzzifiED.TermsFromOpSum-Tuple{Sum{Scaled{ComplexF64, Prod{Op}}}}"><code>Main.FuzzifiED.TermsFromOpSum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function TermsFromOpSum(opsum :: Sum{Scaled{ComplexF64, Prod{Op}}}) :: Vector{Term}</code></pre><p>Converts a <code>OpSum</code> object in <code>ITensors</code> to a series of terms. Note that the only operators supported are <code>&quot;C&quot;</code>, <code>&quot;Cdag&quot;</code> <code>&quot;N&quot;</code> and <code>&quot;I&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/itensors_support/itensors_format.jl#L124-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.OpSumFromTerms-Tuple{Vector{Term}}" href="#Main.FuzzifiED.OpSumFromTerms-Tuple{Vector{Term}}"><code>Main.FuzzifiED.OpSumFromTerms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function OpSumFromTerms(tms :: Vector{Term}) :: Sum{Scaled{ComplexF64, Prod{Op}}}</code></pre><p>Converts a series of terms to <code>OpSum</code> object in <code>ITensors</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/itensors_support/itensors_format.jl#L158-L163">source</a></section></article><h3 id="Easy-sweep"><a class="docs-heading-anchor" href="#Easy-sweep">Easy sweep</a><a id="Easy-sweep-1"></a><a class="docs-heading-anchor-permalink" href="#Easy-sweep" title="Permalink"></a></h3><p>This tool kit facilitates the management of DMRG process. It automatically records the intermediate results and recover these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. These functions require the package <a href="https://github.com/ITensor/ITensorMPOConstruction.jl"><code>ITensorMPOConstruction</code></a>, which can be installed by </p><pre><code class="language-julia hljs">julia&gt; using Pkg; Pkg.add(url=&quot;https://github.com/ITensor/ITensorMPOConstruction.jl.git&quot;)</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.EasySweep-Tuple{String, MPO, MPS}" href="#Main.FuzzifiED.EasySweep-Tuple{String, MPO, MPS}"><code>Main.FuzzifiED.EasySweep</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String, dim_list :: Vector{Int64}, proj :: Vector{String}, e_tol1 :: Float64, e_tol :: Float64, cutoff :: Vector{Float64}, maxdim0 :: Vector{Float64}, noise0 :: Vector{Float64}, noise :: Vector{Int64}, nsweeps :: Int64, weight :: Float64, observer :: AbstractObserver) :: Tuple{Float64, MPS}</code></pre><p><strong>Function</strong></p><p>This function automatically performs several rounds of DMRG sweeps with increasing bond dimensions. It first checks the file <code>st_$(id).h5</code> in a specified repository. If the key <code>st_fin</code> exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process. For each round, it will try to access the results from the key <code>st_d$(dim_i)</code> in <code>st_$(id).h5</code>, where <code>dim_i</code> is either <code>0</code> representing the initial round, or an element of array <code>dim_list</code>. If the key exist, it will read the result ; otherwise it will perform the sweeps using <a href="#Main.FuzzifiED.SweepOne-Tuple{String, MPO, MPS, Int64}"><code>SweepOne</code></a>. For the initial round, it will take the initial state from <code>st00</code>, the maximal bond dimensions from <code>maxdim0</code>, noise from <code>noise0</code> and record the results in the key <code>E_d0</code> and <code>st_d0</code> in <code>st_$(id).h5</code>. For each of the following round, it will take the result from the previous round as the initial state and perform <code>nsweeps</code> sweeps with the bond dimension <code>dim_list[i]</code>. Each round will be stopped if the energy difference is less than <code>e_tol1</code>. The entire process will be stopped if the energy difference between two rounds is less than <code>e_tol</code> or the bond dimension of the result is less than 0.9 times the maximal bond dimension. The projected states will be accessed from the files specified by <code>proj</code>. It will try to access first the states with the same bond dimension as the projected states. If such states do not exist, it will then access the final state. The resulting energy will be written into the key <code>E_fin</code> in the file <code>st_$(id).h5</code>, and the MPS written into <code>st_fin</code>. The function returns a tuple of energy and the final MPS. </p><p><strong>Arguments</strong></p><ul><li><code>id :: String</code> is a string identifying the file to which the results will be accessed and written.</li><li><code>hmt :: MPO</code> is an MPO specifying the Hamiltonian.</li><li><code>st00 :: MPS</code> is an MPS specifying the initial state. </li><li><code>path :: String</code> identifies the path where the results will be accessed and stored. Facultive, <code>./</code> by default. </li><li><code>dim_list :: Vector{Int64} :: Int64</code> is a list that specifies the maximal bond dimensions of each round of sweeps starting from the second round. Facultive, <code>[1000,2000,3000,4000,5000,6000]</code> by default</li><li><code>proj :: Vector{String}</code> specifies the name of the states that will be projected. Facultive, empty by default. </li><li><code>e_tol1 :: Float64</code> specifies the energy tolerence as a criteria to end the round of sweeps for each round of sweeps. Facultive, <code>1E-6</code> by default. </li><li><code>e_tol :: Float64</code> specifies the energy tolerence as a criteria to end the entire process. Facultive, <code>1E-7</code> by default. </li><li><code>cutoff :: Vector{Float64}</code> is the cutoff that will be sent into DMRG. Facultive, <code>[1.E-9]</code> by default. </li><li><code>maxdim0 :: Vector{Int64}</code> specifies the maximal bond dimensions of the first round of sweeps. Facultive, <code>[1E-4,3E-5,1E-5,3E-6,1E-6,3E-7]</code> by default. </li><li><code>noise0 :: Vector{Float64}</code> specifies the noise of each sweep in the initial round and will be sent into DMRG. Facultive, <code>[1E-4,3E-5,1E-5,3E-6,1E-6,3E-7]</code> by default. </li><li><code>noise :: Vector{Float64}</code> specifies the noise of each sweep from the second round and will be sent into DMRG. Facultive, <code>[1E-6,1E-7,0]</code> by default. </li><li><code>nsweeps :: Int64</code> specifies the number of sweeps in each round from the second rounds. Facultive, 10 by default. </li><li><code>weight :: Float64</code> specifies the weight of projected states and will be sent into DMRG. Facultive, 100.0 by default.</li><li><code>observer :: AbstractObserver</code> specifies the measurement and cutoff condition for each sweep starting from the second round. Facultive, by default the observer will print the energy and cutoff once the energy difference is less than <code>e_tol</code> at each sweep. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/itensors_support/easy_sweep.jl#L85-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.SweepOne-Tuple{String, MPO, MPS, Int64}" href="#Main.FuzzifiED.SweepOne-Tuple{String, MPO, MPS, Int64}"><code>Main.FuzzifiED.SweepOne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function SweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String, cutoff :: Vector{Float64}, maxdim :: Vector{Int64}, nsweeps :: Int64, noise :: Vector{Float64}, proj :: Vector{String}, e_tol :: Float64, weight :: Float64, observer :: AbstractObserver) :: Tuple{Float64, MPS}</code></pre><p><strong>Function</strong></p><p>This function performs one round of <code>nsweeps</code> sweeps. It first checks the file <code>st_$(id).h5</code> in a specified repository. If the key <code>st_d$(dim1)</code> exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process with the maximal bond dimension specified by <code>maxdim</code> if it exists, or <code>dim1</code>. The projected states will be read from the key <code>st_d$(dim1)</code> if it exists or <code>st_fin</code> in the file <code>st_$(fi).h5</code> in the same repository for each string <code>fi</code> in the array <code>proj</code>. The sweeps will be ended if the energy difference is less than <code>etol</code> or whatever criteria is given in <code>observer</code>. The resulting energy will be written into the key <code>E_d$(dim1)</code> in the file <code>st_$(id).h5</code>, and the MPS written into <code>st_d$(dim1)</code>. The function returns a tuple of energy and the final MPS. </p><p><strong>Arguments</strong></p><ul><li><code>id :: String</code> is a string identifying the file to which the results will be accessed and written.</li><li><code>hmt :: MPO</code> is an MPO specifying the Hamiltonian.</li><li><code>st0 :: MPS</code> is an MPS specifying the initial state. </li><li><code>dim1 :: Int64</code> is a bond dimension that will be used to identify the result. </li><li><code>path :: String</code> identifies the path where the results will be accessed and stored. Facultive, <code>./</code> by default. </li><li><code>cutoff :: Vector{Float64}</code> is the cutoff that will be sent into DMRG. Facultive, <code>[1.E-9]</code> by default. </li><li><code>maxdim :: Vector{Int64}</code> specifies the maximal bond dimension of each sweep. Facultive, <code>[dim1]</code> by default. </li><li><code>nsweeps :: Int64</code> specifies the number of sweeps in the round. Facultive, 10 by default. </li><li><code>noise :: Vector{Float64}</code> specifies the noise of each sweep and will be sent into DMRG. Facultive, <code>[1E-6,1E-7,0]</code> by default. </li><li><code>proj :: Vector{String}</code> specifies the name of the states that will be projected. Facultive, empty by default. </li><li><code>e_tol :: Float64</code> specifies the energy tolerence as a criteria to end the sweeps. Facultive, <code>1E-6</code> by default. </li><li><code>weight :: Float64</code> specifies the weight of projected states and will be sent into DMRG. Facultive, 100.0 by default.</li><li><code>observer :: AbstractObserver</code> specifies the measurement and cutoff condition for each sweep. Facultive, by default the observer will print the energy and cutoff once the energy difference is less than <code>e_tol</code> at each sweep. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/itensors_support/easy_sweep.jl#L20-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetMpoSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}}" href="#Main.FuzzifiED.GetMpoSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}}"><code>Main.FuzzifiED.GetMpoSites</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetMpoSites(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}} ; path :: String, qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, old = false) :: Tuple{MPO, Vector{&lt;:Index}}</code></pre><p><strong>Function</strong></p><p>This function returns the MPO and sites for a given operator and a Hilbert space with given quantum numbers. It first checks the file <code>op_$(id).h5</code> in a specified repository. If the file exists, it will try to read the fields <code>mpo</code> and <code>sites</code> and return the MPO and Sites. Otherwise it will first generates the sites with the quantum numbers given in <code>qnu_o</code>, <code>qnu_name</code> and <code>modul</code> (these objects are often results of a function named <code>Get*Qnu</code>). Then it will generate the MPO with the terms of the operator given in <code>tms</code>. The MPO and sites will be written into the file <code>op_$(id).h5</code> in the fields <code>mpo</code> and <code>sites</code>. </p><p><strong>Arguments</strong></p><ul><li><code>id :: String</code> is a string identifying the file to which the results will be accessed and written.</li><li><code>tms :: Vector{Term}</code> or <code>tms :: Sum{Scaled{ComplexF64, Prod{Op}}}</code> is either an array of terms or a <code>OpSum</code> objects that specifies the expression of the operator. </li><li><code>path :: String</code> identifies the path where the results will be accessed and stored. Facultive, <code>./</code> by default. </li><li><code>qnu_o :: Vector{Vector{Int64}}</code> is a list where each element specifies a quantum number. Each element is a list that specifies the charges of each orbital under the quantum number. Obligatory. </li><li><code>qnu_name :: Vector{String}</code> specifies the name of each quantum number. Facultive, QN1, QN2, ... by default. </li><li><code>module :: Vector{Int64}</code> specifies the modulus of each quantum number. Facultive, all 1 by default.</li><li><code>old :: Bool</code> specifies the method of MPO generation. If true, then the <code>MPO()</code> method in ITensors will be used ; if false, then <code>MPO_new()</code> method in <code>ITensorMPOConstruction</code> package will be used. Facultive, <code>false</code> by default. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/itensors_support/easy_sweep.jl#L144-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetMpo-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{&lt;:Index}}" href="#Main.FuzzifiED.GetMpo-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{&lt;:Index}}"><code>Main.FuzzifiED.GetMpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetMpo(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}} ; path :: String, qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, old = false) :: Tuple{MPO, Vector{&lt;:Index}}</code></pre><p><strong>Function</strong></p><p>This function returns the MPO for a given operator and a given set of sites. It first checks the file <code>op_$(id).h5</code> in a specified repository. If the file exists, it will try to read the fields <code>mpo</code> and return the MPO it has read. Otherwise it will generate the MPO with the terms of the operator given in <code>tms</code>. The MPO will be written into the file <code>op_$(id).h5</code> in the fields <code>mpo</code>. </p><p><strong>Arguments</strong></p><ul><li><code>id :: String</code> is a string identifying the file to which the results will be accessed and written.</li><li><code>tms :: Vector{Term}</code> or <code>tms :: Sum{Scaled{ComplexF64, Prod{Op}}}</code> is either an array of terms or a <code>OpSum</code> objects that specifies the expression of the operator. </li><li><code>sites :: Vector{&lt;:Index}</code> specifies the sites that the operator is acting on. </li><li><code>path :: String</code> identifies the path where the results will be accessed and stored. Facultive, <code>./</code> by default. </li><li><code>old :: Bool</code> specifies the method of MPO generation. If true, then the <code>MPO()</code> method in ITensors will be used ; if false, then <code>MPO_new()</code> method in <code>ITensorMPOConstruction</code> package will be used. Facultive, <code>false</code> by default. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/itensors_support/easy_sweep.jl#L191-L206">source</a></section></article><h2 id="Built-in-models"><a class="docs-heading-anchor" href="#Built-in-models">Built-in models</a><a id="Built-in-models-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetIntMatrix-Tuple{Int64, Vector{Number}}" href="#Main.FuzzifiED.GetIntMatrix-Tuple{Int64, Vector{Number}}"><code>Main.FuzzifiED.GetIntMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetIntMatrix(nm :: Int64, ps_pot :: Vector{Number}) :: Array{ComplexF64, 3}</code></pre><p><strong>Argument</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals</li><li><code>ps_pot :: Vector{Number}</code> is the vector of non-zero pseudopotentials </li></ul><p><strong>Output</strong></p><ul><li>A <code>nm</code>*<code>nm</code>*<code>nm</code> array giving the interaction matrix <span>$U_{m_1,m_2,m_3,-m_1-m_2-m_3}$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/threej.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetL2Terms-Tuple{Int64, Int64}" href="#Main.FuzzifiED.GetL2Terms-Tuple{Int64, Int64}"><code>Main.FuzzifiED.GetL2Terms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetL2Terms(nm :: Int64, nf :: Int64) :: Vector{Term}</code></pre><p>Return the terms for the total angular momentum.</p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals.</li><li><code>nf :: Int64</code> is the number of flavours.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/l2.jl#L1-L9">source</a></section></article><h3 id="Density-density-interaction-models"><a class="docs-heading-anchor" href="#Density-density-interaction-models">Density-density interaction models</a><a id="Density-density-interaction-models-1"></a><a class="docs-heading-anchor-permalink" href="#Density-density-interaction-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetDenIntTerms-Tuple{Int64, Int64}" href="#Main.FuzzifiED.GetDenIntTerms-Tuple{Int64, Int64}"><code>Main.FuzzifiED.GetDenIntTerms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GetDenIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{&lt;:Number}, mat_a :: Matrix{&lt;:Number}, mat_b :: Matrix{&lt;:Number}) :: Vector{Term}</code></pre><p>Return the normal-ordered density-density term in the Hamiltonian </p><p class="math-container">\[\sum_{\{m_i,f_i\}}U_{m_1m_2m_3m_4}M^A_{f_1f_4}M^B_{f_2f_3}c^{\dagger}_{m_1f_1}c^{\dagger}_{m_2f_2}c_{m_3f_3}c_{m_4f_4}\]</p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals.</li><li><code>nf :: Int64</code> is the number of flavours.</li><li><code>ps_pot :: Vector{&lt;:Number}</code> is a list of numbers specifying the pseudopotentials for the interacting matrix <span>$U_{m_1m_2m_3m_4}$</span>. Facultive, <code>[1.0]</code> by default.</li><li><code>mat_a :: Matrix{&lt;:Number}</code> is a <code>nf</code>*<code>nf</code> matrix specifying <span>$M^A_{ff&#39;}$</span>. Facultive, <span>$I_{N_f}$</span> by default. </li><li><code>mat_b :: Matrix{&lt;:Number}</code> is a <code>nf</code>*<code>nf</code> matrix specifying <span>$M^B_{ff&#39;}$</span>. Facultive, the Hermitian conjugate of <code>mat_a</code> by default. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/nn_int.jl#L58-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetPairIntTerms-Tuple{Int64, Int64}" href="#Main.FuzzifiED.GetPairIntTerms-Tuple{Int64, Int64}"><code>Main.FuzzifiED.GetPairIntTerms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GetPairIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{&lt;:Number}, mat_a :: Matrix{&lt;:Number}, mat_b :: Matrix{&lt;:Number}) :: Vector{Term}</code></pre><p>Return the normal-ordered pair-pair interaction term in the Hamiltonian </p><p class="math-container">\[\sum_{\{m_i,f_i\}}U_{m_1m_2m_3m_4}M^A_{f_1f_2}M^B_{f_4f_3}c^{\dagger}_{m_1f_1}c^{\dagger}_{m_2f_2}c_{m_3f_3}c_{m_4f_4}\]</p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals.</li><li><code>nf :: Int64</code> is the number of flavours.</li><li><code>ps_pot :: Vector{&lt;:Number}</code> is a list of numbers specifying the pseudopotentials for the interacting matrix <span>$U_{m_1m_2m_3m_4}$</span>. Facultive, <code>[1.0]</code> by default.</li><li><code>mat_a :: Matrix{&lt;:Number}</code> is a <code>nf</code>*<code>nf</code> matrix specifying <span>$M^A_{ff&#39;}$</span>. Facultive, <span>$I_{N_f}$</span> by default. </li><li><code>mat_b :: Matrix{&lt;:Number}</code> is a <code>nf</code>*<code>nf</code> matrix specifying <span>$M^B_{ff&#39;}$</span>. Facultive, the Hermitian conjugate of <code>mat_a</code> by default. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/nn_int.jl#L110-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetPolTerms-Tuple{Int64, Int64}" href="#Main.FuzzifiED.GetPolTerms-Tuple{Int64, Int64}"><code>Main.FuzzifiED.GetPolTerms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GetPolTerms(nm :: Int64, nf :: Int64 ; mat :: Matrix{&lt;:Number} = Matrix{Float64}(I, nf, nf)) :: Vector{Term}</code></pre><p>Return the polarisation term in the Hamiltonian </p><p class="math-container">\[\sum_{mff&#39;}c^{\dagger}_{mf}M_{ff&#39;}c_{mf&#39;}\]</p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals ;</li><li><code>nf :: Int64</code> is the number of flavours ; </li><li><code>mat :: Matrix{&lt;:Number}</code> is a <code>nf</code>*<code>nf</code> matrix specifying <span>$M_{ff&#39;}$</span>. Facultive, <span>$I_{N_f}$</span> by default. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/nn_int.jl#L161-L175">source</a></section></article><h3 id="SphereObs"><a class="docs-heading-anchor" href="#SphereObs">SphereObs</a><a id="SphereObs-1"></a><a class="docs-heading-anchor-permalink" href="#SphereObs" title="Permalink"></a></h3><p>Fuzzified supports local observables that can be decomposed into angular components <span>$\Phi(\Omega)=\sum_{lm}\Phi_{lm}Y^{(s)}_{lm}$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.SphereObs" href="#Main.FuzzifiED.SphereObs"><code>Main.FuzzifiED.SphereObs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct SphereObs</code></pre><p>stores the information of a local observable (or local operator) <span>$\Phi$</span> that can be decomposed into angular components.</p><p class="math-container">\[    \Phi(\Omega)=\sum_{lm}\Phi_{lm}Y^{(s)}_{lm}\]</p><p><strong>Fields</strong></p><ul><li><code>s2 :: Int64</code> is twice the spin <span>$2s$</span> of the observable.</li><li><code>l2m :: Int64</code> is twice the maximal angular momentum <span>$2l_{\max}$</span> of the components of the observable. </li><li><code>get_comp :: Function</code> is a function <code>get_comp(l2 :: Int64, m2 :: Int64) :: Vector{Term}</code> that sends the component specified by a tuple of integers <span>$(2l,2m)$</span> where <span>$|s|\leq s\leq l_{\max}, -l\leq m\leq l$</span> to a list of terms that specifies the expression of the component. </li><li><code>stored_q :: Bool</code> is a boolean that specifies whether or not each component of the observable is stored.</li><li><code>comps :: Dict{Tuple{Int64, Int64}, Vector{Term}}</code> stores each component of the observable in the format of a dictionary whose keys are the tuples of integers <span>$(2l,2m)$</span> and values are the lists of terms that specifies the expression of the component. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L1-L16">source</a></section></article><p>It can be initialised with the following methods </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.SphereObs-Tuple{Int64, Int64, Function}" href="#Main.FuzzifiED.SphereObs-Tuple{Int64, Int64, Function}"><code>Main.FuzzifiED.SphereObs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SphereObs</code></pre><p>initialises the observable from <span>$2s$</span>, <span>$2l_{\max}$</span> and the function <span>$(l,m)\mapsto\Phi_{lm}$</span></p><p><strong>Arguments</strong></p><ul><li><code>s2 :: Int64</code> is twice the spin <span>$2s$</span> of the observable.</li><li><code>l2m :: Int64</code> is twice the maximal angular momentum <span>$2l_{\max}$</span> of the components of the observable. </li><li><code>get_comp :: Function</code> is a function <code>get_comp(l2 :: Int64, m2 :: Int64) :: Vector{Term}</code> that sends the component specified by a tuple of integers <span>$(2l,2m)$</span> where <span>$|s|\leq s\leq l_{\max}, -l\leq m\leq l$</span> to a list of terms that specifies the expression of the component. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.SphereObs-Tuple{Int64, Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}" href="#Main.FuzzifiED.SphereObs-Tuple{Int64, Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}"><code>Main.FuzzifiED.SphereObs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SphereObs</code></pre><p>initialises the observable from <span>$2s$</span>, <span>$2l_{\max}$</span> and a list of <span>$\Phi_{lm}$</span> specified by a dictionary. </p><p><strong>Arguments</strong></p><ul><li><code>s2 :: Int64</code> is twice the spin <span>$2s$</span> of the observable.</li><li><code>l2m :: Int64</code> is twice the maximal angular momentum <span>$2l_{\max}$</span> of the components of the observable. </li><li><code>comps :: Dict{Tuple{Int64, Int64}, Vector{Term}}</code> stores each component of the observable in the format of a dictionary whose keys are the tuples of integers <span>$(2l,2m)$</span> and values are the lists of terms that specifies the expression of the component. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L41-L51">source</a></section></article><p>The following methods explicitly calculates and stores each component</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.StoreComps!-Tuple{SphereObs}" href="#Main.FuzzifiED.StoreComps!-Tuple{SphereObs}"><code>Main.FuzzifiED.StoreComps!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function StoreComps!(obs :: SphereObs) :: Nothing</code></pre><p>calculates and stores each component of the observable <code>obs</code> and replace the function in <code>obs</code> by the list of calculated components. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.StoreComps-Tuple{SphereObs}" href="#Main.FuzzifiED.StoreComps-Tuple{SphereObs}"><code>Main.FuzzifiED.StoreComps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function StoreComps(obs :: SphereObs) :: SphereObs</code></pre><p>calculates and stores each component of the observable <code>obs</code> and return a new observable with the list of calculated components. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L78-L82">source</a></section></article><p>The multiplication, addition, conjugate and Laplacian operation of an observable is supported </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{Number, SphereObs}" href="#Base.:*-Tuple{Number, SphereObs}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function *(fac :: Number, obs :: SphereObs) :: SphereObs
function *(obs :: SphereObs, fac :: Number) :: SphereObs
function /(obs :: SphereObs, fac :: Number) :: SphereObs
function -(obs :: SphereObs) :: SphereObs</code></pre><p>enables the multiplication of an observable with a number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L99-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{SphereObs, SphereObs}" href="#Base.:+-Tuple{SphereObs, SphereObs}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function +(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs
function -(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs</code></pre><p>enables the addition of two observables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L121-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint-Tuple{SphereObs}" href="#Base.adjoint-Tuple{SphereObs}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function adjoint(obs :: SphereObs) :: SphereObs</code></pre><p>enables the Hermitian conjugate of an observable.</p><p class="math-container">\[\begin{aligned}
    Φ^†(Ω)&amp;=∑_{lm}(Φ_{lm})^†̄Y^{(s)}_{lm}(Ω)=∑_{lm}(Φ_{lm})^†(-1)^{s+m)Y^{(-s)}_{l,-m}(Ω)\\
    (Φ^†)_{lm}&amp;=(-1)^{s-m}(Φ_{l,-m})^†
\begin{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L141-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:*-Tuple{SphereObs, SphereObs}" href="#Base.:*-Tuple{SphereObs, SphereObs}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function *(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs</code></pre><p>enables the multiplication of two observable by making use of the composition of two monopole harmonics into one. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Laplacian-Tuple{SphereObs}" href="#Main.FuzzifiED.Laplacian-Tuple{SphereObs}"><code>Main.FuzzifiED.Laplacian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Laplacian(obs :: SphereObs) :: SphereObs</code></pre><p>Takes the Laplacian of an observable</p><p class="math-container">\[    (∇^2Φ)_{lm}=-l(l+1)Φ_{lm}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L186-L193">source</a></section></article><p>The observables can be evaluated either at an angular component or at a real-space point.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetComponent-Tuple{SphereObs, Number, Number}" href="#Main.FuzzifiED.GetComponent-Tuple{SphereObs, Number, Number}"><code>Main.FuzzifiED.GetComponent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetComponent(obs :: SphereObs, l :: Number, m :: Number) :: Vector{Term}</code></pre><p>returns an angular component <span>$Φ_{lm}$</span> of an observable in the format of a list of terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetPointValue-Tuple{SphereObs, Float64, Float64}" href="#Main.FuzzifiED.GetPointValue-Tuple{SphereObs, Float64, Float64}"><code>Main.FuzzifiED.GetPointValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetPointValue(obs :: SphereObs, θ :: Float64, ϕ :: Float64) :: Vector{Term}</code></pre><p>evaluates an observable at one point <span>$Φ(θ,ϕ)$</span> in the format of a list of terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L209-L213">source</a></section></article><p>Two types of operators, <em>viz.</em> electrons and density operators are built-in.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Electron-Tuple{Int64, Int64, Int64}" href="#Main.FuzzifiED.Electron-Tuple{Int64, Int64, Int64}"><code>Main.FuzzifiED.Electron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Electron(nf :: Int64, nm :: Int64, f :: Int64) :: SphereObs</code></pre><p>returns the electron annihilation operator <span>$ψ_f$</span></p><p><strong>Arguments</strong></p><ul><li><span>$nf :: Int64$</span> is the number of flavours.</li><li><span>$nm :: Int64$</span> is the number of orbitals.</li><li><span>$f :: Int64$</span> is the index of the orbital to be taken.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L231-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.Density-Tuple{Int64, Int64}" href="#Main.FuzzifiED.Density-Tuple{Int64, Int64}"><code>Main.FuzzifiED.Density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Density(nf :: Int64, nm :: Int64 ; mat :: Matrix{&lt;:Number}) :: SphereObs</code></pre><p>returns the density operator <span>$n=∑_{ff&#39;}ψ^†_{f}M_{ff&#39;}ψ_{f&#39;}$</span></p><p><strong>Arguments</strong></p><ul><li><span>$nf :: Int64$</span> is the number of flavours.</li><li><span>$nm :: Int64$</span> is the number of orbitals.</li><li><span>$mat :: Int64$</span> is the matrix <span>$M_{ff&#39;}$</span>. Facultive, identity matrix <span>$\mathbb{I}$</span> by default.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/sphere_obs.jl#L249-L259">source</a></section></article><h3 id="Ising-model"><a class="docs-heading-anchor" href="#Ising-model">Ising model</a><a id="Ising-model-1"></a><a class="docs-heading-anchor-permalink" href="#Ising-model" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetLzQnu-Tuple{Int64, Int64}" href="#Main.FuzzifiED.GetLzQnu-Tuple{Int64, Int64}"><code>Main.FuzzifiED.GetLzQnu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetLzQnu(nm :: Int64, nf :: Int64) :: @NamedTuple{qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}}</code></pre><p>returns the diagonal quantum numbers, <em>i.e.</em>, particle number <span>$N_e$</span> and angular momentum <span>$L_z+sN_e$</span></p><p class="math-container">\[\begin{aligned}
    N_e&amp;=\sum_o n_o
    L_z+sN_e&amp;=\sum_{mf}(m+s)n_o
\end{aligned}\]</p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals ; </li><li><code>nf :: Int64</code> is the number of flavours ; </li></ul><p><strong>Output</strong></p><p>A named tuple with three elements that can be directly fed into <a href="#Main.FuzzifiED.SitesFromQnu-Tuple{}"><code>SitesFromQnu</code></a></p><ul><li><code>qnu_o :: Vector{Vector{Int64}}</code> stores the charge of each orbital under each conserved quantity. See <a href="#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}"><code>Confs</code></a> for detail.</li><li><code>qnu_name :: Vector{String}</code> stores the name of each quantum number.</li><li><code>modul :: Vector{Int64}</code> stores the modulus of each quantum number, 1 if no modulus. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/ising.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetLzConfs-Tuple{Int64, Int64, Int64}" href="#Main.FuzzifiED.GetLzConfs-Tuple{Int64, Int64, Int64}"><code>Main.FuzzifiED.GetLzConfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetLzConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64) :: Confs</code></pre><p>Return the configurations with conserved particle number <span>$N_e$</span> and angular momentum <span>$L_z$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals <span>$2s+1$</span>.</li><li><code>nf :: Int64</code> is the number of flavours ; </li><li><code>ne :: Int64</code> is the number of electrons.</li><li><code>lz :: Float64</code> is the angular momentum. Facultive, 0 by default. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/ising.jl#L74-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetIsingBasis-Tuple{Confs}" href="#Main.FuzzifiED.GetIsingBasis-Tuple{Confs}"><code>Main.FuzzifiED.GetIsingBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetIsingBasis(cfs :: Confs ; qn_p :: Int64 = 0, qn_z :: Int64 = 0, qn_r :: Int64 = 0) :: Basis</code></pre><p>Return the basis with conserved parity <span>$\mathscr{P}$</span>, flavour symmetry <span>$\mathscr{Z}$</span> and <span>$\pi$</span>-rotation along <span>$y$</span>-axis <span>$\mathscr{R}$</span> from the configurations already generated. Quantum numbers set to zero signify that they are not conserved. </p><p><strong>Arguments</strong></p><ul><li><code>cfs :: Confs</code> is the configurations generated by <a href="#Main.FuzzifiED.GetLzConfs-Tuple{Int64, Int64, Int64}"><code>GetLzConfs</code></a> or <a href="#Main.FuzzifiED.GetLzZnConfs-Tuple{Int64, Int64, Int64}"><code>GetLzZnConfs</code></a>.</li><li><code>qn_p :: Int64</code> is quantum number for parity transformation. Facultive, 0 by default.</li><li><code>qn_z :: Int64</code> is the particle quantum number for <span>$\mathbb{Z}_2$</span>-flavour transformation. Facultive, 0 by default.</li><li><code>qn_r :: Int64</code> is the quantum number for  <span>$\pi$</span> rotation along <span>$y$</span>-axis compared with the ground state. Facultive, 0 by default.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/ising.jl#L119-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetIsingIntTerms-Tuple{Int64}" href="#Main.FuzzifiED.GetIsingIntTerms-Tuple{Int64}"><code>Main.FuzzifiED.GetIsingIntTerms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetIsingIntTerms(nm :: Int64 ; ps_pot :: Vector) :: Vector{Term}</code></pre><p>Returns the terms for the ising interaction </p><p class="math-container">\[\sum_{m_1m_2m_3m_4}2U_{m_1m_2m_3m_4}c^{\dagger}_{m_1\uparrow}c^{\dagger}_{m_2\downarrow}c_{m_3\downarrow}c_{m_4\uparrow}\]</p><p>from the pseudopotentials. </p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals <span>$2s+1$</span>.</li><li><code>ps_pot :: Vector{Number}</code> is the pseudopotential of Ising interaction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/ising.jl#L165-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetXPolTerms-Tuple{Int64}" href="#Main.FuzzifiED.GetXPolTerms-Tuple{Int64}"><code>Main.FuzzifiED.GetXPolTerms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetXPolTerms(nm :: Int64)</code></pre><p>Returns the terms for the density operator <span>$n^x_{l=0,m=0}$</span></p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/ising.jl#L185-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetZPolTerms-Tuple{Int64}" href="#Main.FuzzifiED.GetZPolTerms-Tuple{Int64}"><code>Main.FuzzifiED.GetZPolTerms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetZPolTerms(nm :: Int64)</code></pre><p>Returns the terms for the density operator <span>$n^z_{l=0,m=0}$</span></p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/ising.jl#L198-L206">source</a></section></article><h4 id="Ising-model-in-the-X-basis"><a class="docs-heading-anchor" href="#Ising-model-in-the-X-basis">Ising model in the X basis</a><a id="Ising-model-in-the-X-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Ising-model-in-the-X-basis" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetLzZnQnu-Tuple{Int64, Int64}" href="#Main.FuzzifiED.GetLzZnQnu-Tuple{Int64, Int64}"><code>Main.FuzzifiED.GetLzZnQnu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetLzZnQnu(nm :: Int64, nf :: Int64) :: @NamedTuple{qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}}</code></pre><p>returns the diagonal quantum numbers, <em>i.e.</em>, particle number <span>$N_e$</span>, angular momentum <span>$L_z+sN_e$</span> and flavour charge <span>$Z_{N_f}$</span></p><p class="math-container">\[\begin{aligned}
    N_e&amp;=\sum_o n_o
    L_z+sN_e&amp;=\sum_{mf}(m+s)n_{mf}
    Z_{N_f}&amp;=\sum_{m,f=0}^{N_f-1}fn_{mf}\ \mathrm{mod}\ N_f
\end{aligned}\]</p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals ; </li><li><code>nf :: Int64</code> is the number of flavours ; </li></ul><p><strong>Output</strong></p><p>A named tuple with three elements that can be directly fed into <a href="#Main.FuzzifiED.SitesFromQnu-Tuple{}"><code>SitesFromQnu</code></a></p><ul><li><code>qnu_o :: Vector{Vector{Int64}}</code> stores the charge of each orbital under each conserved quantity. See <a href="#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}"><code>Confs</code></a> for detail.</li><li><code>qnu_name :: Vector{String}</code> stores the name of each quantum number.</li><li><code>modul :: Vector{Int64}</code> stores the modulus of each quantum number, 1 if no modulus. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/ising.jl#L36-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetLzZnConfs-Tuple{Int64, Int64, Int64}" href="#Main.FuzzifiED.GetLzZnConfs-Tuple{Int64, Int64, Int64}"><code>Main.FuzzifiED.GetLzZnConfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetLzZnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64, zn :: Int64 = 0) :: Confs</code></pre><p>Return the configurations with conserved particle number <span>$N_e$</span>, angular momentum <span>$L_z$</span> and flavour charge <span>$Z_{N_f}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals <span>$2s+1$</span>.</li><li><code>nf :: Int64</code> is the number of flavours ; </li><li><code>ne :: Int64</code> is the number of electrons.</li><li><code>lz :: Float64</code> is the angular momentum. Facultive, 0 by default. </li><li><code>zn :: Float64</code> is the flavour charge. Facultive, 0 by default. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/ising.jl#L96-L108">source</a></section></article><h3 id="\\mathrm{Sp}(N)-model"><a class="docs-heading-anchor" href="#\\mathrm{Sp}(N)-model"><span>$\mathrm{Sp}(N)$</span> model</a><a id="\\mathrm{Sp}(N)-model-1"></a><a class="docs-heading-anchor-permalink" href="#\\mathrm{Sp}(N)-model" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetSpnConfs-Tuple{Int64, Int64, Int64}" href="#Main.FuzzifiED.GetSpnConfs-Tuple{Int64, Int64, Int64}"><code>Main.FuzzifiED.GetSpnConfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetSpnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0, sz :: Vector{Int64}) :: Confs</code></pre><p>Return the configurations with conserved particle number <span>$N_e$</span>, angular momentum <span>$L_z$</span> and Cartans of the <span>$\mathrm{Sp}(N)$</span> symmetry </p><p class="math-container">\[\begin{aligned}
N_e&amp;=\sum_{mf}n_{mf}\\
L_z&amp;=\sum_{mf}mn_{mf}\\
S_{z,i}&amp;=\sum_m (n_{m,i}-n_{m,i+N_f/2})&amp;i&amp;=1,\dots,N_f/2
\end{aligned}\]</p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals.</li><li><code>nf :: Int64</code> is the number of flavours.</li><li><code>ne :: Int64</code> is the number of electrons.</li><li><code>lz :: Float64</code> is the angular momentum. Facultive, 0 by default. </li><li><code>sz :: Vector{Int64}</code> is <span>$N_f/2$</span> numbers that give <span>$\mathrm{Sp}(N)$</span> Cartan. Facultive, a vector of <span>$N_f/2$</span> zeros by default. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/spn.jl#L42-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetSpnBasis-Tuple{Confs, Int64}" href="#Main.FuzzifiED.GetSpnBasis-Tuple{Confs, Int64}"><code>Main.FuzzifiED.GetSpnBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetSpnBasis(cfs :: Confs, nf :: Int64 ; qn_p :: Int64 = 0, qn_r :: Int64 = 0, qn_z :: Vector{Int64}, qn_x :: Vector{Int64} :: Basis</code></pre><p>Return the basis with conserved parity <span>$\mathscr{P}$</span>, <span>$\pi$</span>-rotation along <span>$y$</span>-axis <span>$\mathscr{R}$</span>, and flavour symmetries <span>$\mathscr{Z}_i,\mathscr{X}_i$</span> from the configurations already generated. Quantum numbers set to zero signify that they are not conserved. </p><p class="math-container">\[\begin{aligned}
\mathscr{P}:c^{\dagger}_{mf}&amp;\mapsto c_{m,f+N_f/2},&amp;c^{\dagger}_{m,f+N_f/2}&amp;\mapsto-c_{m,f}\\
\mathscr{R}:c^{\dagger}_{mf}&amp;\mapsto c^{\dagger}_{-m,f}\\
\mathscr{Z}_i:c^{\dagger}_{mi}&amp;\mapsto c^{\dagger}_{m,i+N_f/2}&amp;c^{\dagger}_{m,i+N_f/2}&amp;\mapsto-c^{\dagger}_{m,i},&amp;i=1,2,\dots,N_f/2\\
\mathscr{X}_i:c^{\dagger}_{m,2i-1}&amp;\leftrightarrow c^{\dagger}_{m,2i}&amp;c^{\dagger}_{m,2i-1+N_f/2}&amp;\leftrightarrow c^{\dagger}_{m,2i+N_f/2},&amp;i=1,2,\dots,N_f/4\\
\end{aligned}\]</p><p>Note that sometimes some <span>$\mathscr{Z}_i$</span> and <span>$\mathscr{X}_i$</span> cannot be implemented at the same time. </p><p><strong>Arguments</strong></p><ul><li><code>cfs :: Confs</code> is the configurations generated by <a href="#Main.FuzzifiED.GetSpnConfs-Tuple{Int64, Int64, Int64}"><code>GetSpnConfs</code></a>.</li><li><code>nf :: Int64</code> is the number of flavours.</li><li><code>qn_p :: Int64</code> is quantum number for parity transformation. Facultive, 0 by default.</li><li><code>qn_r :: Int64</code> is the quantum number for  <span>$\pi$</span> rotation along <span>$y$</span>-axis compared with the ground state. Facultive, 0 by default.</li><li><code>qn_z :: Vector{Int64}</code> is <span>$N_f/2$</span> numbers that give <span>$\mathscr{Z}_i$</span> flavour symmetry. Facultive, all 0 by default.</li><li><code>qn_x :: Vector{Int64}</code> is <span>$N_f/4$</span> numbers that give <span>$\mathscr{X}_i$</span> flavour symmetry. Facultive, all 0 by default.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/spn.jl#L75-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetSpnPairIntTerms-Tuple{Int64, Int64}" href="#Main.FuzzifiED.GetSpnPairIntTerms-Tuple{Int64, Int64}"><code>Main.FuzzifiED.GetSpnPairIntTerms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetSpnPairIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector) :: Vector{Term}</code></pre><p>Returns the terms for the <span>$\mathrm{Sp}(N)$</span> pair-pair interaction </p><p class="math-container">\[\sum_{m_1m_2m_3m_4ff&#39;}2U_{m_1m_2m_3m_4}c^{\dagger}_{m_1f}c^{\dagger}_{m_2,f+N_f/2}c_{m_3 f&#39;+N_f/2}c_{m_4f&#39;}\]</p><p>from the pseudopotentials. </p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals.</li><li><code>nf :: Int64</code> is the number of flavours.</li><li><code>ps_pot :: Vector{Number}</code> is the pseudopotential of the hubbard interaction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/spn.jl#L148-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetSpnC2Terms-Tuple{Int64, Int64}" href="#Main.FuzzifiED.GetSpnC2Terms-Tuple{Int64, Int64}"><code>Main.FuzzifiED.GetSpnC2Terms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetSpnC2Terms(nm :: Int64, nf :: Int64) :: Vector{Term}</code></pre><p>Returns the quadratic Casimir <span>$C_2$</span> of the <span>$\mathrm{Sp}(N)$</span> symmetry.</p><p><strong>Arguments</strong></p><ul><li><code>nm :: Int64</code> is the number of orbitals.</li><li><code>nf :: Int64</code> is the number of flavours.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/spn.jl#L170-L179">source</a></section></article><h3 id="3-state-Potts-model"><a class="docs-heading-anchor" href="#3-state-Potts-model">3-state Potts model</a><a id="3-state-Potts-model-1"></a><a class="docs-heading-anchor-permalink" href="#3-state-Potts-model" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Main.FuzzifiED.GetSnBasis-Tuple{Confs, Int64}" href="#Main.FuzzifiED.GetSnBasis-Tuple{Confs, Int64}"><code>Main.FuzzifiED.GetSnBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function GetSnBasis(cfs :: Confs, nf :: Int64 ; qn_r :: Int64 = 0, perm :: Vector, qn_z :: Vector{&lt;:Number}) :: Basis</code></pre><p>Return the basis where the <span>$\pi$</span>-rotation along <span>$y$</span>-axis <span>$\mathscr{R}$</span> and certain permutationss of flavour are implemented. Quantum numbers set to zero signify that they are not conserved. </p><p><strong>Arguments</strong></p><ul><li><code>cfs :: Confs</code> is the configurations generated by <a href="#Main.FuzzifiED.GetLzConfs-Tuple{Int64, Int64, Int64}"><code>GetLzConfs</code></a> or <a href="#Main.FuzzifiED.GetLzZnConfs-Tuple{Int64, Int64, Int64}"><code>GetLzZnConfs</code></a>.</li><li><code>nf :: Int64</code> is the number of flavours</li><li><code>qn_r :: Int64</code> is the quantum number for  <span>$\pi$</span> rotation along <span>$y$</span>-axis compared with the ground state. Facultive, 0 by default.</li><li><code>perm :: Vector{Vector{Int64}}</code> is a list where each element specifies a permutation of flavour indices (from 1 to <span>$N_f$</span>) in the format of a cycle. Facultive, empty by default.</li><li><code>qn_z :: Vector{&lt;:Number}</code> is a list where each element specifies the quantum number under the flavour permutation. Facultive, empty by default. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mankai-chow/fuzzifi_ed/blob/9bc8a91d025ade6d9614b8f0b1795cab669af5e8/src/models/nn_int.jl#L1-L13">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example/">« Example</a><a class="docs-footer-nextpage" href="../releases/">Releases »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 30 May 2024 18:26">Thursday 30 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
