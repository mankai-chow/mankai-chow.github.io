<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example · FuzzifiED.jl</title><meta name="title" content="Example · FuzzifiED.jl"/><meta property="og:title" content="Example · FuzzifiED.jl"/><meta property="twitter:title" content="Example · FuzzifiED.jl"/><meta name="description" content="Documentation for FuzzifiED.jl."/><meta property="og:description" content="Documentation for FuzzifiED.jl."/><meta property="twitter:description" content="Documentation for FuzzifiED.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="FuzzifiED.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FuzzifiED.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Example</a><ul class="internal"><li><a class="tocitem" href="#Exact-diagonalisation-with-FuzzifiED"><span>Exact diagonalisation with FuzzifiED</span></a></li><li><a class="tocitem" href="#DMRG-calculations-with-FuzzifiED"><span>DMRG calculations with FuzzifiED</span></a></li><li><a class="tocitem" href="#List-of-examples"><span>List of examples</span></a></li></ul></li><li><a class="tocitem" href="../core/">Core functions</a></li><li><a class="tocitem" href="../itensors/">ITensors support</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../releases/">Releases</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mankai-chow/fuzzifi_ed" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mankai-chow/fuzzifi_ed/blob/main/docs/src/example.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="FuzzifiED-explained-in-an-example"><a class="docs-heading-anchor" href="#FuzzifiED-explained-in-an-example">FuzzifiED explained in an example</a><a id="FuzzifiED-explained-in-an-example-1"></a><a class="docs-heading-anchor-permalink" href="#FuzzifiED-explained-in-an-example" title="Permalink"></a></h1><p>In this example, we will illustrate how to use <code>FuzzifiED</code> to calculate the spectrum of Ising model on fuzzy sphere and how to calculate the OPE coefficient <span>$\lambda_{\sigma\sigma\epsilon}$</span> by measuring the expectation value of the density operator <span>$n^z$</span>. </p><p>The examples can be found in the directory <a href="https://github.com/mankai-chow/FuzzifiED.jl/tree/main/examples"><code>examples</code></a>. Three versions of this example is provided. The first does not use the built-in example and is stored in <a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising_primitive.jl"><code>ising_primitive.jl</code></a> ; the second uses the interfaces with ITensors and is stored in <a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising_itensors.jl"><code>example_ising_itensors.jl</code></a> ; the third uese the built-in example for the Ising model and is stored in <a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising.jl"><code>example_ising.jl</code></a>. The explanations following applied mainly to the primitive version. </p><p>In addition, an example of how <code>FuzzifiED</code> can facilitate DMRG calculation is given. Two versions of the DMRG example is provided. The first uses <code>MPO</code> and <code>dmrg</code> functions of the ITensors package and is stored in <a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising_dmrg.jl"><code>ising_dmrg.jl</code></a>. The second uses the <a href="../itensors/#Main.FuzzifiED.EasySweep-Tuple{String, MPO, MPS}"><code>EasySweep</code></a> function in the package which further wraps the <code>dmrg</code> function to facilitate the management of sweeps and is stored in <a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising_dmrg_easysweep.jl"><code>ising_dmrg_easysweep.jl</code></a>. </p><p>We also append in the end a list of </p><h2 id="Exact-diagonalisation-with-FuzzifiED"><a class="docs-heading-anchor" href="#Exact-diagonalisation-with-FuzzifiED">Exact diagonalisation with FuzzifiED</a><a id="Exact-diagonalisation-with-FuzzifiED-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-diagonalisation-with-FuzzifiED" title="Permalink"></a></h2><h3 id="Implement-the-diagonal-quantum-numbers-and-generate-the-configurations"><a class="docs-heading-anchor" href="#Implement-the-diagonal-quantum-numbers-and-generate-the-configurations">Implement the diagonal quantum numbers and generate the configurations</a><a id="Implement-the-diagonal-quantum-numbers-and-generate-the-configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Implement-the-diagonal-quantum-numbers-and-generate-the-configurations" title="Permalink"></a></h3><p><code>FuzzifiED</code> supports diagonal quantum numbers (QNU) in the form of </p><p class="math-container">\[Q_i=\sum_{o=1}^{N_o}q_{io}n_o\quad\mathrm{or}\quad Q_i=\sum_{o=1}^{N_o}q_{io}n_o\ \mathrm{mod}\ P_i\]</p><p>where <span>$i=1,\dots,N_U$</span> is the index of diagonal quantum numbers, <span>$o$</span> is the index of orbital, <span>$n_o=c^\dagger_oc_o$</span>, and <span>$q_o$</span> is a set of coefficients that must be non negative integer valued. (A list of <span>$q_o$</span> with both positive and negative entries can be adapted by shifting every elements by a same value)</p><p>The function used to implement the diagonal quantum numbers and generate all the configurations (<em>i.e.</em>, direct product states) is <a href="../core/#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}"><code>Confs</code></a>. There are two diagonal quantum numbers in the Ising model, <em>viz.</em> the particle number and the angular momentum</p><p class="math-container">\[\begin{aligned}
Q_1&amp;=N_e,&amp; q_{1,m\sigma}&amp;=1\\
Q_2&amp;=L_z+N_es,&amp;q_{2,m\sigma}&amp;=m+s
\end{aligned}\]</p><p>where the orbital index <span>$o$</span> contains both <span>$m$</span> and <span>$\sigma$</span>. In the code, we store the orbitals with the same <span>$m$</span> together, <em>viz.</em> we store the spin-up orbitals in odd <span>$o=1,3,\dots,2N_m-1$</span> and the spin-down orbitals in even <span>$o=2,4,\dots,2N_m$</span>. Thus, if we want to look at the <span>$L_z=0$</span> half-filled sector</p><pre><code class="language-julia hljs"># Inputing the basic setups
nf = 2
nm = 8
no = nf * nm
s = .5 * (nm - 1)
ne = div(no, 2)
# Initialise the arrays
qnu_s = Vector{Int64}(undef, 0)
qnu_o = []
# Record the number of electrons
push!(qnu_o, fill(1, no)) # qnu_o[1] = [1,1,...,1]
push!(qnu_s, ne) 
# Record the angular momentum
push!(qnu_o, [ div(o - 1, nf) for o = 1 : no ]) # qnu_o[2] = [0,0,1,1,...,7,7] to qnu_o
push!(qnu_s, ne * s) 
# Generate the configurations and print the number
@time &quot;Initialise configurations&quot; cfs = Confs(no, qnu_s, qnu_o)
@show cfs.ncf</code></pre><h4 id="ITensor-support"><a class="docs-heading-anchor" href="#ITensor-support">ITensor support</a><a id="ITensor-support-1"></a><a class="docs-heading-anchor-permalink" href="#ITensor-support" title="Permalink"></a></h4><p>The quantum numbers can also be imported from the <code>Sites</code> objects in <code>ITensors</code>. This can be done using the <a href="../itensors/#Main.FuzzifiED.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}"><code>ConfsFromSites</code></a> function.</p><pre><code class="language-julia hljs"># Overload the ITensors type &quot;Fermion&quot;
function ITensors.space( :: SiteType&quot;Fermion&quot; ; m1 :: Int = 0)
    return [
        QN((&quot;Nf&quot;, 0, -1), (&quot;Lz&quot;,  0)) =&gt; 1
        QN((&quot;Nf&quot;, 1, -1), (&quot;Lz&quot;, m1)) =&gt; 1
    ]
end
# Initialise the sites
sites = [ siteind(&quot;Fermion&quot;, m1 = div(o - 1, nf)) for o :: Int = 1 : no]
qn_s = QN((&quot;Nf&quot;, ne), (&quot;Lz&quot;, Int(ne * s)))
@time &quot;Initialise configurations&quot; cfs = ConfsFromSites(sites, qn_s)
# Alternatively, one can initialise the configuration quantum number
# cf_ref = [o &lt;= ne ? 1 : 0 for o = 1 : no]
# @time &quot;Initialise configurations&quot; cfs = ConfsFromSites(sites, cf_ref)
@show cfs.ncf</code></pre><h4 id="Built-in-model"><a class="docs-heading-anchor" href="#Built-in-model">Built-in model</a><a id="Built-in-model-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-model" title="Permalink"></a></h4><p>Using The built-in Ising model, the process above can be done in one line with the method <a href="../models/#Main.FuzzifiED.GetLzConfs-Tuple{Int64, Int64, Int64}"><code>GetLzConfs</code></a>.</p><pre><code class="language-julia hljs">cfs = GetLzConfs(nm, 2)</code></pre><h3 id="Implement-the-discrete-symmetries-and-initialise-the-basis"><a class="docs-heading-anchor" href="#Implement-the-discrete-symmetries-and-initialise-the-basis">Implement the discrete symmetries and initialise the basis</a><a id="Implement-the-discrete-symmetries-and-initialise-the-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Implement-the-discrete-symmetries-and-initialise-the-basis" title="Permalink"></a></h3><p><code>FuzzifiED</code> supports discrete <span>$\mathbb{Z}_n$</span> symmetries in the form of </p><p class="math-container">\[\mathscr{Z}:\ c_o\to \alpha_o^* c^{(p_o)}_{\pi_o},\quad c_o^\dagger\to \alpha_o c^{(1-p_o)}_{\pi_o}\]</p><p>where we use a notation <span>$c^{(1)}=c^\dagger$</span> and <span>$c^{0}=c$</span> for convenience, where <span>$\pi_o$</span> is a permutation of <span>$1,\dots N_o$</span>, <span>$\alpha_o$</span> is a coefficient, and <span>$p_o$</span> specified whether or not particle-hole transformation is performed for the orbital. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal quantum numbers. </p><p>After implementing these symmetries, a state in the new basis should look like </p><p class="math-container">\[|I\rangle=\lambda_{i_{I1}}|i_{I1}\rangle+\lambda_{i_{I2}}|i_{I2}\rangle+\cdots+\lambda_{i_{Im_I}}|i_{Im_I}\rangle\]</p><p>where the <span>$|i\rangle$</span>&#39;s are configurations in the <code>Confs</code> generated in the last section. The <span>$|I\rangle$</span> is a linear combination, and can be regarded as a grouping of <span>$m_I$</span> configurations.</p><p>The function used to implement the discrete symmetries is <a href="../core/#Basis"><code>Basis</code></a>. There are three <span>$\mathbb{Z}_2$</span> transformations in the Ising model, <em>viz.</em> the particle-hole transformation <span>$\mathscr{P}$</span>, the <span>$\pi$</span>-rotation along the <span>$y$</span>-axis <span>$\mathscr{R}_y$</span> and the flavour symmetry <span>$\mathscr{Z}$</span></p><p class="math-container">\[\begin{aligned}
    \mathscr{P}:c^\dagger_{\sigma m}&amp;\to\sigma c_{-\sigma,m}\\
    \mathscr{Z}:c^\dagger_{\sigma m}&amp;\to c^\dagger_{-\sigma,m}\\
    \mathscr{R}_y:c^\dagger_{\sigma m}&amp;\to c^\dagger_{\sigma,-m}\\
\end{aligned}\]</p><p>Thus, if we want to look at the all-positive sector</p><pre><code class="language-julia hljs">cyc = [ 2, 2, 2 ] # Input three Z_2 symmetries 
qnz_s = ComplexF64[ 1, 1, 1 ] # Quantum numbers are all positive 
# Initialise the vectors
perm_o = []
ph_o = []
fac_o = []
# Record the parity
push!(perm_o, [ isodd(o) ? o + 1 : o - 1 for o = 1 : no]) # perm_o[1] = [2,1,4,3,...,16,15]
push!(ph_o, fill(1, no)) # ph_o[1] = [1,1,...,1] meaning PH
push!(fac_o, [ isodd(o) ? -1 : 1 for o = 1 : no]) # fac_o[1] = [1,-1,1,-1,...,1,-1]
# Record the flavour symmetry
push!(perm_o, [ isodd(o) ? o + 1 : o - 1 for o = 1 : no]) # perm_o[3] = [2,1,4,3,...,16,15]
push!(ph_o, fill(0, no)) # ph_o[3] = [0,0,...,0] meaning no PH
push!(fac_o, fill(ComplexF64(1), no)) # fac_o[3] = [1,1,...,1]
# Record the pi-rotation
push!(perm_o, [ isodd(o) ? no - o : no + 2 - o for o = 1 : no]) # perm_o[2] = [15,16,13,14,...,1,2]
push!(ph_o, fill(0, no)) # ph_o[2] = [0,0,...,0] meaning no PH
push!(fac_o, fill(ComplexF64(1), no)) # fac_o[2] = [1,1,...,1]
# Generate the basis and print the dimension
@time &quot;Initialise basis&quot; bs = Basis(cfs, qnz_s, cyc, perm_o, ph_o, fac_o)
@show bs.dim </code></pre><p>Note that if no discrete symmetry is needed, one can simply put instead <code>bs = Basis(conf)</code></p><h4 id="Built-in-model-2"><a class="docs-heading-anchor" href="#Built-in-model-2">Built-in model</a><a class="docs-heading-anchor-permalink" href="#Built-in-model-2" title="Permalink"></a></h4><p>Using The built-in Ising model, the process above can be done in one line with the method <a href="../models/#Main.FuzzifiED.GetIsingBasis-Tuple{Confs}"><code>GetIsingBasis</code></a>.</p><pre><code class="language-julia hljs">bs = GetIsingBasis(cfs ; qn_p = 1, qn_r = 1, qn_z = 1)</code></pre><h3 id="Record-the-Hamiltonian-operator"><a class="docs-heading-anchor" href="#Record-the-Hamiltonian-operator">Record the Hamiltonian operator</a><a id="Record-the-Hamiltonian-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Record-the-Hamiltonian-operator" title="Permalink"></a></h3><p>The operator here refers to the sum of product of <span>$c$</span> and <span>$c^\dagger$</span>&#39;s in the form </p><p class="math-container">\[\Phi=\sum_{t=1}^{N_t}U_tc^{(p_{t1})}_{o_{t1}}c^{(p_{t2})}_{o_{t2}}\dots c^{(p_{tl})}_{o_{tl}}\]</p><p>where <span>$c^{(0)}=c$</span> and <span>$c^{(1)}=c^\dagger$</span>. Here the operator string sum is recorded together with the basis of the initial state and the basis of the final state. </p><p>This can be generated by the <a href="../core/#Operator"><code>Operator</code></a> function. The Hamiltonian for the fuzzy sphere Ising model</p><p class="math-container">\[H=\sum_{m_1m_2m_3m_4}U_{m_1m_2m_3m_4}\delta_{m_1+m_2,m_3+m_4}c^\dagger_{m_1\uparrow}c^\dagger_{m_2\downarrow}c_{m_3\downarrow}c_{m_4\uparrow}-h\sum_m(c^\dagger_{m\uparrow}c_{m\downarrow}+\mathrm{h.c.})\]</p><p>can be recorded with </p><pre><code class="language-julia hljs">using WignerSymbols
# Input the parameters of the Hamiltonian
ps_pot = [ 4.75, 1. ] * 2.
h = 3.16
tms_hmt = Vector{Term}(undef, 0)
# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3
for m1 = 0 : nm - 1
    f1 = 0
    o1 = m1 * nf + f1 + 1
    m1r = m1 - s
    for m2 = 0 : nm - 1
        f2 = 1
        o2 = m2 * nf + f2 + 1
        m2r = m2 - s
        for m3 = 0 : nm - 1
            f3 = 1
            o3 = m3 * nf + f3 + 1
            m3r = m3 - s
            m4 = m1 + m2 - m3 
            if (m4 &lt; 0 || m4 &gt;= nm) continue end
            f4 = 0
            o4 = m4 * nf + f4 + 1
            m4r = m4 - s
            # Calculate the matrix element val from pseudopotentials
            val = ComplexF64(0)
            for l in 1 : length(ps_pot)
                if (abs(m1r + m2r) &gt; nm - l || abs(m3r + m4r) &gt; nm - l) break end 
                val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, m1r, m2r, -m1r - m2r) * wigner3j(s, s, nm - l, m4r, m3r, -m3r - m4r)
            end 
            # Record the interaction term val, &quot;Cdag&quot;, o1, &quot;Cdag&quot;, o2, &quot;C&quot;, o3, &quot;C&quot;, o4
            push!(tms_hmt, Term(val, [1, o1, 1, o2, 0, o3, 0, o4]))
        end
    end
    o1x = o1 + 1
    # Record the transverse field term
    push!(tms_hmt, Term(-h, [1, o1, 0, o1x]))
    push!(tms_hmt, Term(-h, [1, o1x, 0, o1]))
end
# Generate the Hamiltonian operator
hmt = Operator(bs, bs, tms_hmt ; red_q = 1, sym_q = 1)</code></pre><h4 id="ITensor-support-2"><a class="docs-heading-anchor" href="#ITensor-support-2">ITensor support</a><a class="docs-heading-anchor-permalink" href="#ITensor-support-2" title="Permalink"></a></h4><p>Alternatively, one can generate the operator using an <code>OpSum</code> object instead of <code>cstr_vec</code> and <code>fac</code> using the function <a href="../itensors/#Main.FuzzifiED.TermsFromOpSum-Tuple{Sum{Scaled{ComplexF64, Prod{Op}}}}"><code>TermsFromOpSum</code></a>.</p><p>For the Hamiltonian of Ising model,</p><pre><code class="language-julia hljs">
using WignerSymbols
# Input the parameters of the Hamiltonian
ps_pot = [ 4.75, 1. ] * 2.
h = 3.16
global ops_hmt = OpSum()
# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3
for m1 = 0 : nm - 1
    f1 = 0
    o1 = m1 * nf + f1 + 1
    m1r = m1 - s
    for m2 = 0 : nm - 1
        f2 = 1
        o2 = m2 * nf + f2 + 1
        m2r = m2 - s
        for m3 = 0 : nm - 1
            f3 = 1
            o3 = m3 * nf + f3 + 1
            m3r = m3 - s
            m4 = m1 + m2 - m3 
            if (m4 &lt; 0 || m4 &gt;= nm) continue end
            f4 = 0
            o4 = m4 * nf + f4 + 1
            m4r = m4 - s
            # Calculate the matrix element val from pseudopotentials
            val = ComplexF64(0)
            for l in 1 : length(ps_pot)
                if (abs(m1r + m2r) &gt; nm - l || abs(m3r + m4r) &gt; nm - l) break end 
                val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, m1r, m2r, -m1r - m2r) * wigner3j(s, s, nm - l, m4r, m3r, -m3r - m4r)
            end 
            # Record the interaction term
            global ops_hmt += val, &quot;Cdag&quot;, o1, &quot;Cdag&quot;, o2, &quot;C&quot;, o3, &quot;C&quot;, o4
        end
    end
    o1x = o1 + 1
    # Record the transverse field term
    global ops_hmt += -h, &quot;Cdag&quot;, o1, &quot;C&quot;, o1x
    global ops_hmt += -h, &quot;Cdag&quot;, o1x, &quot;C&quot;, o1
end
# Generate the Hamiltonian operator
tms_hmt = TermsFromOpSum(ops_hmt)
hmt = Operator(bs, bs, tms_hmt ; red_q = 1, sym_q = 1)</code></pre><h4 id="Built-in-model-3"><a class="docs-heading-anchor" href="#Built-in-model-3">Built-in model</a><a class="docs-heading-anchor-permalink" href="#Built-in-model-3" title="Permalink"></a></h4><p>Using The built-in Ising model, the process above can be done in one line with the method <a href="../models/#Main.FuzzifiED.GetIsingIntTerms-Tuple{Int64}"><code>GetIsingIntTerms</code></a> and <a href="../models/#Main.FuzzifiED.GetXPolTerms-Tuple{Int64}"><code>GetXPolTerms</code></a></p><pre><code class="language-julia hljs">tms_hmt = GetIsingIntTerms(nm ; ps_pot = [4.75, 1.]) - 3.16 * GetXPolTerms(nm)</code></pre><h3 id="Generate-the-sparse-matrix-and-diagonalise"><a class="docs-heading-anchor" href="#Generate-the-sparse-matrix-and-diagonalise">Generate the sparse matrix and diagonalise</a><a id="Generate-the-sparse-matrix-and-diagonalise-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-the-sparse-matrix-and-diagonalise" title="Permalink"></a></h3><p>After specifying the Hamiltonian, we then use the <a href="../core/#Main.FuzzifiED.OpMat"><code>OpMat</code></a> to generate a sparse matrix from the operator. To get the 10 lowest eigenstates and their energies</p><pre><code class="language-julia hljs">@time &quot;Initialise the Hamiltonian matrix&quot; hmt_mat = OpMat(hmt)
@show hmt_mat.nel
@time &quot;Diagonalise Hamiltonian&quot; enrg, st = GetEigensystem(hmt_mat, 10)
@show real(enrg)</code></pre><p>We also note that matrices with real elements can be generated with the option <code>type = Float64</code> in the <code>OpMat</code> function. </p><h3 id="Measuring-the-angular-momentum"><a class="docs-heading-anchor" href="#Measuring-the-angular-momentum">Measuring the angular momentum</a><a id="Measuring-the-angular-momentum-1"></a><a class="docs-heading-anchor-permalink" href="#Measuring-the-angular-momentum" title="Permalink"></a></h3><p>We can measure the inner product of a final state, an operator or its matrix and an initial state or the action of an operator or its matrix on a state by directly using the <a href="../core/#Base.:*-Tuple{Number, Vector{Term}}"><code>*</code></a> operator. To measure the total angular momentum <span>$L^2$</span> by definition</p><p class="math-container">\[\begin{aligned}
L^2&amp;=L^+L^-+(L^z)^2-L^z\\
L^z&amp;=\sum_{\sigma m}mc^\dagger_mc_m\\
L^\pm&amp;=\sum_{\sigma m}\sqrt{(s\mp m)(s\pm m+1)}c^\dagger_{m\pm 1}c_m
\end{aligned}\]</p><p>The construction of the operator can be simplified by the <a href="../core/#Base.:+-Tuple{Vector{Term}, Vector{Term}}">addition</a>, <a href="../core/#Base.:*-Tuple{Vector{Term}, Vector{Term}}">multiplication</a>, <a href="../core/#Base.adjoint-Tuple{Vector{Term}}">Hermitian conjugate</a> and <a href="../core/#Main.FuzzifiED.SimplifyTerms-Tuple{Vector{Term}}">simplification</a> of terms. The following code measures the angular momentum of each eigenstate and verify whether <span>$|T\rangle$</span> is an eigenstate of <span>$L^2$</span> by measuring </p><p class="math-container">\[|L^2T\rangle=L^2|T\rangle,\quad\frac{|\langle T|L^2T\rangle|^2}{\langle T|T\rangle\langle L^2T|L^2T\rangle}\]</p><pre><code class="language-julia hljs">tms_lz = 
    [ begin m = div(o - 1, nf)
        Term(m - s, [1, o, 0, o])
    end for o = 1 : no ]
tms_lp = 
    [ begin m = div(o - 1, nf)
        Term(sqrt(m * (nm - m)), [1, o, 0, o - nf])
    end for o = nf + 1 : no ]
tms_lm = tms_lp&#39; 
tms_l2 = SimplifyTerms(tms_lz * tms_lz - tms_lz + tms_lp * tms_lm)
# Initialise the L2 operator
l2 = Operator(bs, bs, tms_l2 ; red_q = 1, sym_q = 1)
@time &quot;Initialise L2&quot; l2_mat = OpMat(l2)
# Calculate the inner product for each eigenstate
@time &quot;Measure L2&quot; l2_val = [ st[:, i]&#39; * l2_mat * st[:, i] for i = 1 : length(enrg)]
@show real(l2_val)
# Verify whether T is an eigenstate of L^2
st_T = st[:, 3]
st_L2T = l2_mat * st[:, 3]
@show abs(st_L2T&#39; * st_T) ^ 2 / ((st_T&#39; * st_T) * (st_L2T&#39; * st_L2T))</code></pre><h4 id="Built-in-model-4"><a class="docs-heading-anchor" href="#Built-in-model-4">Built-in model</a><a class="docs-heading-anchor-permalink" href="#Built-in-model-4" title="Permalink"></a></h4><p>Using The built-in Ising model, the generation of the terms in total angular momentum can be done in one line with the method <a href="../models/#Main.FuzzifiED.GetL2Terms-Tuple{Int64, Int64}"><code>GetL2Terms</code></a></p><pre><code class="language-julia hljs">tms_l2 = GetL2Terms(nm, 2)</code></pre><p>This method also applies to other models on fuzzy sphere. </p><h3 id="Measuring-the-density-operator"><a class="docs-heading-anchor" href="#Measuring-the-density-operator">Measuring the density operator</a><a id="Measuring-the-density-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Measuring-the-density-operator" title="Permalink"></a></h3><p>Similar process can be used to calculate the OPE coefficient by measuring the density operator, by definition </p><p class="math-container">\[\lambda_{\sigma\sigma\epsilon}=\frac{\langle\sigma|n^z_{00}|\epsilon\rangle}{\langle\sigma|n^z_{00}|\mathbb{I}\rangle},\quad n^z_{00}=\frac{1}{N_m}\sum_{\sigma m}\sigma c^\dagger_{\sigma m}c_{\sigma m}\]</p><p>To do that, we need to first repeat the calculation in the <span>$\mathbb{Z}_2$</span>-odd sector</p><pre><code class="language-julia hljs"># Repeat the calculation for the Z_2 odd sector (with subscript 1)
qnz_s1 = ComplexF64[ 1, -1, 1 ] # Change only the discrete quantum numbers and generate the basis
@time &quot;Initialise Basis Z&quot; bs1 = Basis(cfs, qnz_s1, cyc, perm_o, ph_o, fac_o) 
@show bs1.dim 
hmt = Operator(bs1, bs1, tms_hmt ; red_q = 1, sym_q = 1) # Generate and diagonalise Hamiltonian in the new basis
@time &quot;Initialise Hamiltonian&quot; hmt_mat = OpMat(hmt)
@show hmt_mat.nel
@time &quot;Diagonalise Hamiltonian&quot; enrg1, st1 = GetEigensystem(hmt_mat, 10)
@show real(enrg1)
# Record the identity, sigma and epsilon states 
st_I = st[:, 1] # ground state
st_e = st[:, 2] # epsilon state
st_s = st1[:, 1]</code></pre><p>and then generate and measure the density operator</p><pre><code class="language-julia hljs"># Record the density operator n^z
tms_nz = [ Term(isodd(o) ? 1 / nm : -1 / nm, [1, o, 0, o]) for o = 1 : no]
# The nz operator sends a state in bs (+) to bs1 (-)
nz = Operator(bs, bs1, tms_nz ; red_q = 1)
# Measuring the finite size OPE
@show abs((st_s&#39; * nz * st_e) / (st_s&#39; * nz * st_I))</code></pre><h4 id="Built-in-model-5"><a class="docs-heading-anchor" href="#Built-in-model-5">Built-in model</a><a class="docs-heading-anchor-permalink" href="#Built-in-model-5" title="Permalink"></a></h4><p>Using The built-in Ising model, the generation of the terms in density operator can be done in one line with the method <a href="../models/#Main.FuzzifiED.GetZPolTerms-Tuple{Int64}"><code>GetZPolTerms</code></a></p><pre><code class="language-julia hljs">tms_nz = GetZPolTerms(nm) </code></pre><p>This method also applies to other models on fuzzy sphere. </p><h2 id="DMRG-calculations-with-FuzzifiED"><a class="docs-heading-anchor" href="#DMRG-calculations-with-FuzzifiED">DMRG calculations with FuzzifiED</a><a id="DMRG-calculations-with-FuzzifiED-1"></a><a class="docs-heading-anchor-permalink" href="#DMRG-calculations-with-FuzzifiED" title="Permalink"></a></h2><p>In this example, we calculate the ground state MPS of the fuzzy sphere Ising model by DMRG in ITensors, and use the same objects to do ED calculation and compare the result. </p><p>We first set-up the calculation by</p><pre><code class="language-julia hljs">using FuzzifiED
using ITensors
nm = 12
nf = 2
no = nm * nf</code></pre><p>The first object we need is the sites. FuzzifiED overloads the fermion type and supports direct generation of the sites from the diagonal quantum numbers by the function <a href="../itensors/#Main.FuzzifiED.SitesFromQnu-Tuple{}"><code>SitesFromQnu</code></a>. The diagonal quantum numbers of the Ising model is built in and can be generated by the function <a href="../models/#Main.FuzzifiED.GetLzZnQnu-Tuple{Int64, Int64}"><code>GetLzZnQnu</code></a>. The Ising model is expressed in the basis of <span>$XX-Z$</span> so that the flavour symmetry is diagonal. </p><pre><code class="language-julia hljs">sites = SitesFromQnu(; GetLzZnQnu(nm, 2)...)</code></pre><p>We then generate the terms of the Hamiltonian using the built-in functions, convert it to <code>OpSum</code> type in by the <a href="../itensors/#Main.FuzzifiED.OpSumFromTerms-Tuple{Vector{Term}}"><code>OpSumFromTerms</code></a>, and convert it to MPO using the <code>MPO</code> function in ITensors</p><pre><code class="language-julia hljs">sigma_x = [ 0 1 ; 1 0 ]
tms_hmt = SimplifyTerms(GetDenIntTerms(nm ; ps_pot = [4.75, 1.]) - GetDenIntTerms(nm ; ps_pot = [4.75, 1.], mat_a = sigma_x) - 3.16 * GetZPolTerms(nm))
@time mpo_hmt = MPO(OpSumFromTerms(tms_hmt), sites)</code></pre><p>We then use the all-up state as the initial state. In FuzzifiED, the occupied and empty sites are expressed by 0 and 1, while they are expressed by <code>&quot;0&quot;</code> and <code>&quot;1&quot;</code> in ITensors, so a conversion to string is needed. </p><pre><code class="language-julia hljs">cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]
st0 = MPS(sites, string.(cf0))</code></pre><p>After that, the Hamiltonian MPO and the initial state MPS can be used for input for DMRG calculation. </p><pre><code class="language-julia hljs">Eg, stg = dmrg(mpo_hmt, st0 ; nsweeps = 10, maxdim = [10,20,50,100,200,500], noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], cutoff = [1E-8])
@show Eg</code></pre><p>We then convert these objects for the ED calculate. The configurations can be generated from Sites and a reference configuration by the function <a href="../itensors/#Main.FuzzifiED.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}"><code>ConfsFromSites</code></a>. </p><pre><code class="language-julia hljs">cfs = ConfsFromSites(sites, cf0)
bs = Basis(cfs)
hmt = Operator(bs, bs, tms_hmt ; red_q = 1, sym_q = 1)
hmt_mat = OpMat(hmt ; type = Float64)
enrg, st = GetEigensystem(hmt_mat, 10)
@show enrg</code></pre><h3 id="Use-EasySweep-to-manage-DMRG-sweeps"><a class="docs-heading-anchor" href="#Use-EasySweep-to-manage-DMRG-sweeps">Use EasySweep to manage DMRG sweeps</a><a id="Use-EasySweep-to-manage-DMRG-sweeps-1"></a><a class="docs-heading-anchor-permalink" href="#Use-EasySweep-to-manage-DMRG-sweeps" title="Permalink"></a></h3><p>EasySweep facilitates the management of DMRG process by automatically recording the intermediate results and recovering these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. Before the calculation, we need to define a method to generate MPO from OpSum and Sites. We suggest using <code>MPO_new</code> from package <code>ITensorMPOConstruction</code>, which can be installed through </p><pre><code class="language-julia hljs">julia&gt; Pkg.add(url=&quot;https://github.com/ITensor/ITensorMPOConstruction.jl.git&quot;); </code></pre><pre><code class="language-julia hljs">using ITensorMPOConstruction
function MyMPO(os, sites)
    operatorNames = [ &quot;I&quot;, &quot;C&quot;, &quot;Cdag&quot;, &quot;N&quot; ]
    opCacheVec = [ [OpInfo(ITensors.Op(name, n), sites[n]) for name in operatorNames] for n in eachindex(sites)  ]
    mpo = MPO_new(os, sites ; basisOpCacheVec = opCacheVec)
end</code></pre><p>We also need to specify a path where the results are stored. </p><pre><code class="language-julia hljs">path = &quot;nm_$(nm)/&quot;
mkpath(path)</code></pre><p>The Hamiltonian MPO and the sites can be either generated or read from file by the function <a href="../itensors/#Main.FuzzifiED.GetMpoSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}}"><code>GetMpoSites</code></a>. The input is the quantum numbers and the terms or OpSum ; the output is the MPO and the sites</p><pre><code class="language-julia hljs">sigma_x = [ 0 1 ; 1 0 ]
tms_hmt = SimplifyTerms(
    GetDenIntTerms(nm, 2 ; ps_pot = [4.75, 1.]) - 
    GetDenIntTerms(nm, 2 ; ps_pot = [4.75, 1.], mat_a = sigma_x) - 
    3.16 * GetZPolTerms(nm)
)
hmt, sites = GetMpoSites(&quot;hmt&quot;, tms_hmt ; path, GetLzZnQnu(nm, 2)..., mpo_method = MyMPO)</code></pre><p>After generating the initial state MPS, the DMRG calculation of the states <span>$\mathbb{I}$</span> and <span>$\epsilon$</span> can be done by the <a href="../itensors/#Main.FuzzifiED.EasySweep-Tuple{String, MPO, MPS}"><code>EasySweep</code></a> function.  </p><pre><code class="language-julia hljs">cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]
st0 = MPS(sites, string.(cf0))
Eg, stg = EasySweep(&quot;g&quot;, hmt, st0 ; path)
Ee, ste = EasySweep(&quot;e&quot;, hmt, st0 ; path, proj = [&quot;g&quot;])</code></pre><p>The total angular momentum can be measured by generating the MPO of <span>$L^2$</span> and measure the inner product </p><pre><code class="language-julia hljs">tms_l2 = GetL2Terms(nm, 2)
l2 = GetMpo(&quot;l2&quot;, tms_l2, sites ; path)
@show inner(stg&#39;, l2, stg)</code></pre><p>The <span>$\mathbb{Z}_2$</span>-odd <span>$\sigma$</span> state can be calculated similarly.</p><pre><code class="language-julia hljs">cf1 = cf0
cf1[1] = 0
cf1[2] = 1
st1 = MPS(sites, string.(cf1))
Es, sts = EasySweep(&quot;s&quot;, hmt, st1 ; path)</code></pre><h2 id="List-of-examples"><a class="docs-heading-anchor" href="#List-of-examples">List of examples</a><a id="List-of-examples-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-examples" title="Permalink"></a></h2><p>The following examples of FuzzifiED can be found in the repository <a href="https://github.com/mankai-chow/FuzzifiED.jl/tree/main/examples"><code>examples</code></a>.</p><ul><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising.jl"><code>example_ising.jl</code></a> does the ED calculation of Ising model through the built-in models. </li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising_primitive.jl"><code>example_ising_primitive.jl</code></a> does the ED calculation of Ising model through the primitive functions.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising_itensors.jl"><code>example_ising_itensors.jl</code></a> does the ED calculation of Ising model by the Sites and OpSum objects in ITensors.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising_dmrg.jl"><code>example_ising_dmrg.jl</code></a> does the DMRG calculation of Ising model through the <code>dmrg</code> function in ITensors.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising_dmrg_easysweep.jl"><code>example_ising_dmrg_easysweep.jl</code></a> does the DMRG calculation of Ising model through the <code>EasySweep</code> function which wraps ITensors.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising_def.jl"><code>example_ising_def.jl</code></a> does the ED calculation of Ising model with magnetic line defect or defect creation or changing operators.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_ising_def_dmrg.jl"><code>example_ising_def_dmrg.jl</code></a> does the DMRG calculation of Ising model with magnetic line defect or defect changing operators. </li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_sp2.jl"><code>example_sp2.jl</code></a> does the ED calculation of the <span>$\mathrm{SO}(5)$</span> DQCP model.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_potts.jl"><code>example_potts.jl</code></a> does the ED calculation of the three-states Potts model.</li><li><a href="https://github.com/mankai-chow/FuzzifiED.jl/blob/main/examples/example_potts_dmrg.jl"><code>example_potts_dmrg.jl</code></a> does the DMRG calculation of the three-states Potts model in the X basis.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../core/">Core functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 4 June 2024 09:58">Tuesday 4 June 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
