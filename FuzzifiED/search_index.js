var documenterSearchIndex = {"docs":
[{"location":"itensors/#ITensors-support","page":"ITensors support","title":"ITensors support","text":"","category":"section"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"This package also supports convertion with the Site and OpSum objects from ITensors library and management of DMRG sweeping process. To use these functions, include","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"using ITensors","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"at the heading of the Julia script.","category":"page"},{"location":"itensors/#Format-conversion","page":"ITensors support","title":"Format conversion","text":"","category":"section"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"The Sites objects in ITensors can be converted to a Confs object with the conserved quantities extracted. ","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, qn_s :: QN)\nConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, cf_ref :: Vector{Int64})","category":"page"},{"location":"itensors/#Main.FuzzifiED.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}","page":"ITensors support","title":"Main.FuzzifiED.ConfsFromSites","text":"function ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, qn_s :: QN) :: Confs\n\nConverts a Sites object in the ITensors package to the Confs object\n\nArguments\n\nsites :: Vector{Index{Vector{Pair{QN, Int64}}}} is a Sites object. Only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4. \nqn_s :: QN is a QN object that specifies the the quantum number of the selected configuration.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Main.FuzzifiED.ConfsFromSites-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, Vector{Int64}}","page":"ITensors support","title":"Main.FuzzifiED.ConfsFromSites","text":"function ConfsFromSites(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, cf_ref :: Vector{Int64}) :: Confs\n\nsites :: Vector{Index{Vector{Pair{QN, Int64}}}} is a Sites object, where the modulus-pm 1 quantum numbers will be taken out, and QNs with other modulus will be discarded automatically. Also note that only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4. \ncf_ref :: Vector{Int64}) is a reference configuration composed of 0 and 1 in ITensors format.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"Conversely, the  Sites objects in ITensors can also be generated from a set of diagonal quantum numbers ","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"SitesFromQnu(; qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ \"QN\" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)])","category":"page"},{"location":"itensors/#Main.FuzzifiED.SitesFromQnu-Tuple{}","page":"ITensors support","title":"Main.FuzzifiED.SitesFromQnu","text":"function SitesFromQnu(; qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64})\n\nreturns the ITensors Sites object from the information of quantum numbers \n\nArguments\n\nqnu_o :: Vector{Vector{Int64}} stores the charge of each orbital under each conserved quantity. See Confs for detail. \nqnu_name :: Vector{String} stores the name of each quantum number. Facultive, QN1, QN2, ... by default. \nmodul :: Vector{Int64} stores the modulus of each quantum number. Store 1 if no modulus. Facultive, all 1 by default. \n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"If the number of quantum numbers are too many, it can be truncated by ","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"TruncateQnu(; qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ \"QN\" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)], trunc_lth :: Int64 = 3, trunc_wt :: Vector{Int64} = [ 2 ^ (i - trunc_lth) for i = trunc_lth : length(qnu_o)]) ","category":"page"},{"location":"itensors/#Main.FuzzifiED.TruncateQnu-Tuple{}","page":"ITensors support","title":"Main.FuzzifiED.TruncateQnu","text":"TruncateQnu(; qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, trunc_lth :: Int64, trunc_wt :: Vector{Int64})\n\ntruncates the list of N_U QNU's from to a number N_U acceptable by ITensors. The new quantum numbers are \n\n    Q_1=Q_1 Q_2=Q_2 dots Q_N_U-1=Q_N_U-1 Q_N_U=lambda_N_UQ_N_U+lambda_N_U+1Q_N_U+1+dots+lambda_N_UQ_N_U\n\nArguments\n\nqnu_o :: Vector{Vector{Int64}} stores the charge of each orbital under each conserved quantity. See Confs for detail. \nqnu_name :: Vector{String} stores the name of each quantum number. Facultive, QN1, QN2, ... by default. \nmodul :: Vector{Int64} stores the modulus of each quantum number. Store 1 if no modulus. Facultive, all 1 by default. \ntrunc_lth :: Int64 stores the truncated numbers of QNU. Facultive, 3 by default. \ntrunc_wt :: Vecotr{Int64} stores the N_U-N_U+1 coefficients lambda. Facultive, 1248dots by default. \n\nOutput\n\nA named tuple with three elements that can be directly fed into SitesFromQnu\n\nqnu_o :: Vector{Vector{Int64}} stores the charge of each orbital under each conserved quantity. See Confs for detail.\nqnu_name :: Vector{String} stores the name of each quantum number.\nmodul :: Vector{Int64} stores the modulus of each quantum number, 1 if no modulus. \n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"The OpSum objects in ITensors can be converted with the collection of Term's","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"TermsFromOpSum(opsum :: Sum{Scaled{ComplexF64, Prod{Op}}})\nOpSumFromTerms(tms :: Vector{Term})","category":"page"},{"location":"itensors/#Main.FuzzifiED.TermsFromOpSum-Tuple{Sum{Scaled{ComplexF64, Prod{Op}}}}","page":"ITensors support","title":"Main.FuzzifiED.TermsFromOpSum","text":"function TermsFromOpSum(opsum :: Sum{Scaled{ComplexF64, Prod{Op}}}) :: Vector{Term}\n\nConverts a OpSum object in ITensors to a series of terms. Note that the only operators supported are \"C\", \"Cdag\" \"N\" and \"I\".\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Main.FuzzifiED.OpSumFromTerms-Tuple{Vector{Term}}","page":"ITensors support","title":"Main.FuzzifiED.OpSumFromTerms","text":"function OpSumFromTerms(tms :: Vector{Term}) :: Sum{Scaled{ComplexF64, Prod{Op}}}\n\nConverts a series of terms to OpSum object in ITensors.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Easy-sweep","page":"ITensors support","title":"Easy sweep","text":"","category":"section"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"This tool kit facilitates the management of DMRG process. It automatically records the intermediate results and recover these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. These functions require the package ITensorMPOConstruction, which can be installed by ","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"julia> using Pkg; Pkg.add(url=\"https://github.com/ITensor/ITensorMPOConstruction.jl.git\")","category":"page"},{"location":"itensors/","page":"ITensors support","title":"ITensors support","text":"EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String = \"./\", dim_list :: Vector{Int64} = [1000,2000,3000,4000,5000,6000], proj :: Vector{String} = String[], e_tol1 :: Float64 = 1E-6, e_tol :: Float64 = 1E-7, cutoff :: Vector{Float64} = [1E-9], maxdim0 :: Vector{Int64} = [10,20,50,100,200,500], noise0 :: Vector{Float64} = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], noise :: Vector{Float64} = [1E-6,2E-7,5E-8,1E-8,0], nsweeps :: Int64 = 10, weight :: Float64 = 100.0, observer :: AbstractObserver = EasySweepObserver(e_tol1))\nSweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String = \"./\", cutoff :: Vector{Float64} = [1E-9], maxdim :: Vector{Int64} = [dim1], nsweeps :: Int64 = 10, noise :: Vector{Float64} = [1E-6,1E-7,0], proj :: Vector{String} = String[], e_tol :: Float64 = 1E-6, weight :: Float64 = 100.0, observer :: AbstractObserver = EasySweepObserver(e_tol))\nGetMpoSites(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}} ; path :: String = \"./\", qnu_o :: Vector{Any}, qnu_name :: Vector{String} = [ \"QN\" * string(qn) for qn in eachindex(qnu_o)], modul :: Vector{Int64} = [1 for qn in eachindex(qnu_o)], mpo_method :: Function = MPO)\nGetMpo(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}}, sites :: Vector{<:Index} ; path :: String = \"./\", mpo_method :: Function = MPO)","category":"page"},{"location":"itensors/#Main.FuzzifiED.EasySweep-Tuple{String, MPO, MPS}","page":"ITensors support","title":"Main.FuzzifiED.EasySweep","text":"function EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String, dim_list :: Vector{Int64}, proj :: Vector{String}, e_tol1 :: Float64, e_tol :: Float64, cutoff :: Vector{Float64}, maxdim0 :: Vector{Float64}, noise0 :: Vector{Float64}, noise :: Vector{Int64}, nsweeps :: Int64, weight :: Float64, observer :: AbstractObserver) :: Tuple{Float64, MPS}\n\nFunction\n\nThis function automatically performs several rounds of DMRG sweeps with increasing bond dimensions. It first checks the file st_$(id).h5 in a specified repository. If the key st_fin exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process. For each round, it will try to access the results from the key st_d$(dim_i) in st_$(id).h5, where dim_i is either 0 representing the initial round, or an element of array dim_list. If the key exist, it will read the result ; otherwise it will perform the sweeps using SweepOne. For the initial round, it will take the initial state from st00, the maximal bond dimensions from maxdim0, noise from noise0 and record the results in the key E_d0 and st_d0 in st_$(id).h5. For each of the following round, it will take the result from the previous round as the initial state and perform nsweeps sweeps with the bond dimension dim_list[i]. Each round will be stopped if the energy difference is less than e_tol1. The entire process will be stopped if the energy difference between two rounds is less than e_tol or the bond dimension of the result is less than 0.9 times the maximal bond dimension. The projected states will be accessed from the files specified by proj. It will try to access first the states with the same bond dimension as the projected states. If such states do not exist, it will then access the final state. The resulting energy will be written into the key E_fin in the file st_$(id).h5, and the MPS written into st_fin. The function returns a tuple of energy and the final MPS. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\nhmt :: MPO is an MPO specifying the Hamiltonian.\nst00 :: MPS is an MPS specifying the initial state. \npath :: String identifies the path where the results will be accessed and stored. Facultive, ./ by default. \ndim_list :: Vector{Int64} :: Int64 is a list that specifies the maximal bond dimensions of each round of sweeps starting from the second round. Facultive, [1000,2000,3000,4000,5000,6000] by default\nproj :: Vector{String} specifies the name of the states that will be projected. Facultive, empty by default. \ne_tol1 :: Float64 specifies the energy tolerence as a criteria to end the round of sweeps for each round of sweeps. Facultive, 1E-6 by default. \ne_tol :: Float64 specifies the energy tolerence as a criteria to end the entire process. Facultive, 1E-7 by default. \ncutoff :: Vector{Float64} is the cutoff that will be sent into DMRG. Facultive, [1.E-9] by default. \nmaxdim0 :: Vector{Int64} specifies the maximal bond dimensions of the first round of sweeps. Facultive, [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7] by default. \nnoise0 :: Vector{Float64} specifies the noise of each sweep in the initial round and will be sent into DMRG. Facultive, [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7] by default. \nnoise :: Vector{Float64} specifies the noise of each sweep from the second round and will be sent into DMRG. Facultive, [1E-6,1E-7,0] by default. \nnsweeps :: Int64 specifies the number of sweeps in each round from the second rounds. Facultive, 10 by default. \nweight :: Float64 specifies the weight of projected states and will be sent into DMRG. Facultive, 100.0 by default.\nobserver :: AbstractObserver specifies the measurement and cutoff condition for each sweep starting from the second round. Facultive, by default the observer will print the energy and cutoff once the energy difference is less than e_tol at each sweep. \n\n\n\n\n\n","category":"method"},{"location":"itensors/#Main.FuzzifiED.SweepOne-Tuple{String, MPO, MPS, Int64}","page":"ITensors support","title":"Main.FuzzifiED.SweepOne","text":"function SweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String, cutoff :: Vector{Float64}, maxdim :: Vector{Int64}, nsweeps :: Int64, noise :: Vector{Float64}, proj :: Vector{String}, e_tol :: Float64, weight :: Float64, observer :: AbstractObserver) :: Tuple{Float64, MPS}\n\nFunction\n\nThis function performs one round of nsweeps sweeps. It first checks the file st_$(id).h5 in a specified repository. If the key st_d$(dim1) exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process with the maximal bond dimension specified by maxdim if it exists, or dim1. The projected states will be read from the key st_d$(dim1) if it exists or st_fin in the file st_$(fi).h5 in the same repository for each string fi in the array proj. The sweeps will be ended if the energy difference is less than etol or whatever criteria is given in observer. The resulting energy will be written into the key E_d$(dim1) in the file st_$(id).h5, and the MPS written into st_d$(dim1). The function returns a tuple of energy and the final MPS. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\nhmt :: MPO is an MPO specifying the Hamiltonian.\nst0 :: MPS is an MPS specifying the initial state. \ndim1 :: Int64 is a bond dimension that will be used to identify the result. \npath :: String identifies the path where the results will be accessed and stored. Facultive, ./ by default. \ncutoff :: Vector{Float64} is the cutoff that will be sent into DMRG. Facultive, [1.E-9] by default. \nmaxdim :: Vector{Int64} specifies the maximal bond dimension of each sweep. Facultive, [dim1] by default. \nnsweeps :: Int64 specifies the number of sweeps in the round. Facultive, 10 by default. \nnoise :: Vector{Float64} specifies the noise of each sweep and will be sent into DMRG. Facultive, [1E-6,1E-7,0] by default. \nproj :: Vector{String} specifies the name of the states that will be projected. Facultive, empty by default. \ne_tol :: Float64 specifies the energy tolerence as a criteria to end the sweeps. Facultive, 1E-6 by default. \nweight :: Float64 specifies the weight of projected states and will be sent into DMRG. Facultive, 100.0 by default.\nobserver :: AbstractObserver specifies the measurement and cutoff condition for each sweep. Facultive, by default the observer will print the energy and cutoff once the energy difference is less than e_tol at each sweep. \n\n\n\n\n\n","category":"method"},{"location":"itensors/#Main.FuzzifiED.GetMpoSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}}","page":"ITensors support","title":"Main.FuzzifiED.GetMpoSites","text":"function GetMpoSites(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}} ; path :: String, qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, mpo_method :: Function) :: Tuple{MPO, Vector{<:Index}}\n\nFunction\n\nThis function returns the MPO and sites for a given operator and a Hilbert space with given quantum numbers. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and sites and return the MPO and Sites. Otherwise it will first generates the sites with the quantum numbers given in qnu_o, qnu_name and modul (these objects are often results of a function named Get*Qnu). Then it will generate the MPO with the terms of the operator given in tms. The MPO and sites will be written into the file op_$(id).h5 in the fields mpo and sites. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Vector{Term} or tms :: Sum{Scaled{ComplexF64, Prod{Op}}} is either an array of terms or a OpSum objects that specifies the expression of the operator. \npath :: String identifies the path where the results will be accessed and stored. Facultive, ./ by default. \nqnu_o :: Vector{Vector{Int64}} is a list where each element specifies a quantum number. Each element is a list that specifies the charges of each orbital under the quantum number. Obligatory. \nqnu_name :: Vector{String} specifies the name of each quantum number. Facultive, QN1, QN2, ... by default. \nmodule :: Vector{Int64} specifies the modulus of each quantum number. Facultive, all 1 by default.\nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultive, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. \n\n\n\n\n\n","category":"method"},{"location":"itensors/#Main.FuzzifiED.GetMpo-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{<:Index}}","page":"ITensors support","title":"Main.FuzzifiED.GetMpo","text":"function GetMpo(id :: String, tms :: Union{Vector{Term}, Sum{Scaled{ComplexF64, Prod{Op}}}} ; path :: String, qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, mpo_method :: Function) :: Tuple{MPO, Vector{<:Index}}\n\nFunction\n\nThis function returns the MPO for a given operator and a given set of sites. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and return the MPO it has read. Otherwise it will generate the MPO with the terms of the operator given in tms. The MPO and Sites will be written into the file op_$(id).h5 in the fields mpo. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Vector{Term} or tms :: Sum{Scaled{ComplexF64, Prod{Op}}} is either an array of terms or a OpSum objects that specifies the expression of the operator. \nsites :: Vector{<:Index} specifies the sites that the operator is acting on. \npath :: String identifies the path where the results will be accessed and stored. Facultive, ./ by default. \nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultive, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. \n\n\n\n\n\n","category":"method"},{"location":"core/#Core-functions","page":"Core functions","title":"Core functions","text":"","category":"section"},{"location":"core/#Configurations","page":"Core functions","title":"Configurations","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Confs","category":"page"},{"location":"core/#Main.FuzzifiED.Confs","page":"Core functions","title":"Main.FuzzifiED.Confs","text":"mutable struct Confs\n\nThis type stores all the configurations that respects the conserved quantities and also a table to inversely look up the index from the configuration. \n\nFields\n\nno :: Int64 is the number of orbitals\nncf :: Int64 is the number of configurations \nconf :: Vector{Int64} is an array of length ncf containing all the configurations. Each configuration is expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th orbital in the i-th configuration is occupied ; if the bit is 0, then the orbital is empty. \nnor :: Int64, lid :: Vector{Int64} and rid :: Vector{Int64} contain the information of Lin table that is used to inversely look up the index i from the configuration. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following method.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Any} ; nor :: Int64 = div(no, 2))","category":"page"},{"location":"core/#Main.FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{Any}}","page":"Core functions","title":"Main.FuzzifiED.Confs","text":"function Confs(no :: Int64, qnu_s :: Vector{Int64}, qnu_o :: Vector{Vector{Int64}} ; nor :: Int64 = div(no, 2), modul :: Vector{Int64}) :: Confs\n\ngenerates the configurations that has the diagonal quantum numbers given by qnu_s of certain conserved quantities specified by qnu_o :: Vector{Vector{Int64}}\n\nQ_i=sum_o=1^N_oq_ion_o\n\nor\n\nQ_i=sum_o=1^N_oq_ion_o mathrmmod p_i\n\nwhere i=1dotsN_U is the index of conserved quantities, o is the index of orbital, n_o=c^dagger_oc_o, and q_o is a set of coefficients that must be non negative integer valued. (A list of q_o with both positive and negative entries can be adapted by shifting every elements by a same value)\n\nArguments\n\nno :: Int64 is the number of orbitals N_o ;\nqnu_s :: Vector{Int64} is the set of Q_i for the selected configurations ;\nqnu_o :: Vector{Vector{Int64}} is the set of q_io for each quantum number and for each orbital. It should contain N_U elements and each element should be a vector of length N_o. \nnor :: Int64 is the number of less significant bits used to generate the Lin table. Facultive, N_o2 by default.\nmodul :: Vector{Int64} is the modulus of each quantum number. Setting it to 1 means there is no modulus. Facultive, all 1 by default. \n\nOutput\n\ncfs :: Confs is a Confs object\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The inverse look-back for a configuration can be done by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetConfId(cfs :: Confs, cf :: Int64)","category":"page"},{"location":"core/#Main.FuzzifiED.GetConfId-Tuple{Confs, Int64}","page":"Core functions","title":"Main.FuzzifiED.GetConfId","text":"GetConfId(cfs :: Confs, cf :: Int64) :: Int64\n\ninversely look up the index from the configuration\n\nArguments\n\ncfs :: Confs stores the configurations.\ncf :: Int64 stores the configuration to be looked-up expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th orbital in the i-th configuration is occupied ; if the bit is 0, then the orbital is empty. \n\nOutput\n\nid :: Int64 is the id of the configuration such that cfs.conf[id] == cf\n\n\n\n\n\n","category":"method"},{"location":"core/#Basis","page":"Core functions","title":"Basis","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Basis","category":"page"},{"location":"core/#Main.FuzzifiED.Basis","page":"Core functions","title":"Main.FuzzifiED.Basis","text":"mutable struct Basis\n\nThis type stores the information of the basis that respects both the conserved quantities and the discrete symmetries. The states in the basis is in the form \n\nIrangle=lambda_i_I1i_I1rangle+lambda_i_I2i_I2rangle+cdots+lambda_i_Im_Ii_Im_Irangle\n\nwhere irangle is a direct product state, i.e., the configurations i_Ikrangle are grouped into a state Irangle. \n\nFields\n\ncfs :: Confs stores the configurations that respect the conserved quantities ;\ndim :: Int64 is the dimension of the basis ;\nszz :: Int64 records the maximum size max m_g of groups;\ncfgr :: Vector{Int64} is a vector of length cfs.ncf and records which group Irangle each configuration irangle belong to ;\ncffac :: Vector{ComplexF64} is a vector of length cfs.ncf and records the coefficients lambda_i of each configuration ;\ngrel :: Matrix{Int64} is a szz\\*dim matrix that records the configurations in each group i_Ikrangle (k = 1dotsm_I)\ngrsz :: Vector{Int64} is a vector of length dim that records the size m_I of each group.\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Basis(cfs :: Confs, qnz_s :: Vector{ComplexF64}, cyc :: Vector{Int64}, perm_o :: Vector{Any}, ph_o :: Vector{Any}, fac_o :: Vector{Any})\nBasis(cfs :: Confs)","category":"page"},{"location":"core/#Main.FuzzifiED.Basis-Tuple{Confs, Vector{ComplexF64}, Vector{Int64}, Vector{Any}, Vector{Any}, Vector{Any}}","page":"Core functions","title":"Main.FuzzifiED.Basis","text":"function Basis(cfs :: Confs, qnz_s :: Vector{ComplexF64}, cyc :: Vector{Int64}, perm_o :: Vector{Vector{Int64}}, ph_o :: Vector{Vector{Int64}}, fac_o :: Vector{Vector{ComplexF64}}) :: Basis\n\ngenerates the basis that respects the discrete symmetries from the configurations that respects the conserved quantities. The discrete mathbbZ_n symmetries are in the form of \n\nmathscrZ c_oto alpha_o^* c^(p_o)_pi_oquad c_o^daggerto alpha_o c^(1-p_o)_pi_o\n\nwhere we use a notation c^(1)=c^dagger and c^0=c for convenience, where pi_o is a permutation of 1dots N_o, alpha_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the orbital. Note that one must guarentee that all these transformations commute with each other and also commute with the conserved quantities. \n\nArguments\n\ncfs :: Confs is the set of configurations with only conserved quantities ;\nqnz_s :: Vector{ComplexF64} is a vector of length the same as the number of discrete symmetries that records the eigenvalue of each transformation ;\ncyc :: Vector{Int64} records the cycle of each transformation. For mathbbZ_n symmetry, record n ;\nperm_o :: Vector{Vector{Int64}} records the permutation pi_o. It has N_Z elements and each of its elements is a vector of length N_o. \nph_o :: Vector{Vector{Int64}} records p_o to determine whether or not to perform a particle-hole transformation. It has N_Z elements and each of its elements is a vector of length N_o. \nfac_o :: Vector{Vector{ComplexF64}} records the factor p_o is determine whether or not to perform a particle-hole transformation. Each of its elements is a vector of length N_o. \n\nOutput\n\nbs :: Basis is the resulting Basis object\n\n\n\n\n\n","category":"method"},{"location":"core/#Main.FuzzifiED.Basis-Tuple{Confs}","page":"Core functions","title":"Main.FuzzifiED.Basis","text":"function Basis(cfs :: Confs) :: Basis\n\nGenerate a basis from the configurations without applying the mathbbZ_2 symmetries.\n\nArguments\n\ncfs :: Confs is the set of configurations with only conserved quantities ;\n\nOutput\n\nbs :: Basis is the resulting Basis object\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The look-back of the weight of a configuration in a state can be done by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetConfWeight(bs :: Basis, st :: Vector, cf :: Int64)","category":"page"},{"location":"core/#Main.FuzzifiED.GetConfWeight-Tuple{Basis, Vector, Int64}","page":"Core functions","title":"Main.FuzzifiED.GetConfWeight","text":"GetConfWeight(bs :: Basis, st :: Vector{ComplexF64}, cf :: Int64) :: ComplexF64\nGetConfWeight(bs :: Basis, st :: Vector{Float}, cf :: Int64) :: ComplexF64\n\nlooks up a the weight of a configuration in a state. \n\nArguments\n\nbs :: Basis is the basis of the state ; \nst :: Vector{ComplexF64} or st :: Vector{Float64} is a vector of length bs.dim that stores the state ; \ncf :: Int64 stores the configuration to be looked-up expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th orbital in the i-th configuration is occupied ; if the bit is 0, then the orbital is empty. \n\nOutput\n\nThe weight of the configuration in the state \n\n\n\n\n\n","category":"method"},{"location":"core/#Term","page":"Core functions","title":"Term","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Term","category":"page"},{"location":"core/#Main.FuzzifiED.Term","page":"Core functions","title":"Main.FuzzifiED.Term","text":"mutable struct Term\n\nA Term object records a term that looks like Uc^(p_1)_o_1c^(p_2)_o_2dots c^(p_l)_o_l in an operator\n\nFields\n\ncoeff :: ComplexF64 records the coefficient U\ncstr :: Vector{Int64} is a length-2l vector (p_1o_1p_2o_2dots p_lo_l) recording the operator string\n\nMethod\n\nIt can be generated by the function\n\nfunction Term(coeff :: ComplexF64, cstr :: Vector{Int64}) :: ComplexF64\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of terms with a number, the sum and product of terms and the adjoint is defined","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(fac :: Number, tms :: Vector{Term})\n+(tms1 :: Vector{Term}, tms2 :: Vector{Term})\n*(tms1 :: Vector{Term}, tms2 :: Vector{Term})\nadjoint(tms :: Vector{Term})","category":"page"},{"location":"core/#Base.:*-Tuple{Number, Vector{Term}}","page":"Core functions","title":"Base.:*","text":"function *(fac :: Number, tms :: Vector{Term}) :: Vector{Term}\nfunction -(tms :: Vector{Term}) :: Vector{Term}\nfunction *(tms :: Vector{Term}, fac :: Number) :: Vector{Term}\nfunction /(tms :: Vector{Term}, fac :: Number) :: Vector{Term}\n\nReturn the product of a collection of terms with a number. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:+-Tuple{Vector{Term}, Vector{Term}}","page":"Core functions","title":"Base.:+","text":"function +(tms1 :: Vector{Term}, tms2 :: Vector{Term}) :: Vector{Term}\nfunction -(tms1 :: Vector{Term}, tms2 :: Vector{Term}) :: Vector{Term}\n\nReturn the naive sum of two series of terms by taking their union. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Vector{Term}, Vector{Term}}","page":"Core functions","title":"Base.:*","text":"function *(tms1 :: Vector{Term}, tms2 :: Vector{Term}) :: Vector{Term}\n\nReturn the naive product of two series of terms. The number of terms equals the product of the number of terms in tms1 and tms2. For each term in tms1 Uc^(p_1)_o_1dots and tms2 Uc^(p_1)_o_1dots, a new term is formed by taking UUc^(p_1)_o_1dots c^(p_1)_o_1dots\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.adjoint-Tuple{Vector{Term}}","page":"Core functions","title":"Base.adjoint","text":"function adjoint(tm :: Term) :: Term\nfunction adjoint(tms :: Vector{Term}) :: Vector{Term}\n\nReturn the Hermitian conjugate of a series of terms. For each term Uc^(p_1)_o_1c^(p_2)_o_2dots c^(p_l)_o_l, the adjoint is barUc^(1-p_l)_o_ldots c^(1-p_2)_o_2c^(1-p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The terms can be simplified by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"NormalOrder(tm :: Term)\nSimplifyTerms(tms :: Vector{Term})","category":"page"},{"location":"core/#Main.FuzzifiED.NormalOrder-Tuple{Term}","page":"Core functions","title":"Main.FuzzifiED.NormalOrder","text":"function NormalOrder(tm :: Term) :: Vector{Term}\n\nrearrange a term such that \n\nthe creation operators must be commuted in front of the annihilation operator \nthe orbital index of the creation operators are in ascending order and the annihilation operators in descending order. \n\nreturn a list of terms whose result is equal to the original term. \n\n\n\n\n\n","category":"method"},{"location":"core/#Main.FuzzifiED.SimplifyTerms-Tuple{Vector{Term}}","page":"Core functions","title":"Main.FuzzifiED.SimplifyTerms","text":"function SimplifyTerms(tms :: Vector{Term}) :: Vector{Term}\n\nsimplifies the sum of terms such that \n\neach term is normal ordered,\nlike terms are combined, and terms with zero coefficients are removed.\n\n\n\n\n\n","category":"method"},{"location":"core/#Operator","page":"Core functions","title":"Operator","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Operator","category":"page"},{"location":"core/#Main.FuzzifiED.Operator","page":"Core functions","title":"Main.FuzzifiED.Operator","text":"mutable struct Operator\n\nAn Operator object records the sum of terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: Basis is the basis of the initial state ;\nbsf :: Basis is the basis of the final state ;\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; \nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0 ;\nntm :: Int64 is the number of terms ;\nnc :: Int64 is the maximum number of operators in an operator string\ncstrs :: Matrix{Int64} is a matrix recording the operator string of each term. Each column corresponds to a term and is padded to the maximum length with -1's.\ncoeffs :: Vector{ComplexF64} corresponds to the coefficients in each term.\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Operator(bsd :: Basis, bsf :: Basis, terms :: Vector{Term} ; red_q :: Int64 = 0, sym_q :: Int64 = 0)","category":"page"},{"location":"core/#Main.FuzzifiED.Operator-Tuple{Basis, Basis, Vector{Term}}","page":"Core functions","title":"Main.FuzzifiED.Operator","text":"function Operator(bsd :: Basis, bsf :: Basis, terms :: Vector{Term} ; red_q :: Int64, sym_q :: Int64) :: Operator\n\ngenerates an operator object from a series of terms. \n\nArguments\n\nbsd :: Basis is the basis of the initial state ;\nbsf :: Basis is the basis of the final state ;\nterms :: Vector{Term} records the terms ; \nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; \nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(op :: Operator, st_d :: Vector{ComplexF64})\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64})","category":"page"},{"location":"core/#Base.:*-Tuple{Operator, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"function *(op :: Operator, st_d :: Vector{ComplexF64}) :: Vector{ComplexF64}\nfunction *(op :: Operator, st_d :: Vector{Float64}) :: Vector{Float64}\n\nMeasure the action of an operator on a state. st_d must be of length op.bsd.dim. Returns a vector of length op.bsf.dim that represents the final state. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, Operator, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"function *(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64}) :: ComplexF64\nfunction *(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, op :: Operator, st_d :: Vector{Float64}) :: Float64\n\nMeasuring the inner product between two states and an operator. st_d must be of length op.bsd.dim and st_fp must be of length op.bsf.dim, and st_fp must be an adjoint. \n\n\n\n\n\n","category":"method"},{"location":"core/#Sparse-matrix","page":"Core functions","title":"Sparse matrix","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"OpMat{T}","category":"page"},{"location":"core/#Main.FuzzifiED.OpMat","page":"Core functions","title":"Main.FuzzifiED.OpMat","text":"mutable struct OpMat{Complex64}\nmutable struct OpMat{Float64}\n\nThis type stores a sparse matrix in the same form as SparseMatrixCSC in SparseArrays. If the matrix is Hermitian or symmetric, only the lower triangle is stored. \n\nFields\n\ndimd :: Int64 and dimf :: Int64 are the number of columns and rows of the matrix ;\nsymq :: Int64 records whether or not the matrix is Hermitian or symmetric ;\nnel :: Int64 records the number of elements ;\ncolptr :: Vector{Int64}, rowid :: Vector{Int64} and elval :: Vector{ComplexF64} records the elements of the sparse matrix as in the SparseMatrixCSC elements of Julia. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"OpMat(op :: Operator ; type :: DataType = ComplexF64)","category":"page"},{"location":"core/#Main.FuzzifiED.OpMat-Tuple{Operator}","page":"Core functions","title":"Main.FuzzifiED.OpMat","text":"function OpMat(op :: Operator ; type :: DataType = ComplexF64) :: OpMat{type}\n\nGenerates the sparse matrix from the operator\n\nArguments\n\nop :: Operator is the operator ;\ntype :: DataType specifies the type of the matrix. It can either be ComplexF64 or Float64. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The lowest eigenstates of the sparse matrix can be calculated by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64 = 1E-8, ncv :: Int64 = max(2 * nst, nst + 10))","category":"page"},{"location":"core/#Main.FuzzifiED.GetEigensystem-Tuple{OpMat{ComplexF64}, Int64}","page":"Core functions","title":"Main.FuzzifiED.GetEigensystem","text":"function GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64, ncv :: Int64) :: Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}\nfunction GetEigensystem(mat :: OpMat{Float64}, nst :: Int64 ; tol :: Float64, ncv :: Int64) :: Tuple{Vector{Float64}, Matrix{Float64}}\n\ncalls the Arpack package to calculate the lowest eigenstates of sparse matrix. \n\nArguments\n\nmat :: OpMat{ComplexF64} is the matrix ;\nnst :: Int64 is the number of eigenstates to be calculated ;\ntol :: Float64 is the tolerence for the Arpack process. The default value is 1E-8 ;\nncv :: Int64 is an euxiliary parameter needed in the Arpack process. The default value is max(2 * nst, nst + 10)\n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimd*nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})","category":"page"},{"location":"core/#Base.:*-Tuple{OpMat{ComplexF64}, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"function *(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64}) :: Vector{ComplexF64}\nfunction *(mat :: OpMat{Float64}, st_d :: Vector{Float64}) :: Vector{Float64}\n\nMeasure the action of a sparse matrix on a state. st_d must be of length mat.dimd. Returns a vector of length mat.dimf that represents the final state. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, OpMat{ComplexF64}, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"function *(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64}) :: ComplexF64\nfunction *(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, mat :: OpMat{Float64}, st_d :: Vector{Float64}) :: Float64\n\nMeasuring the inner product between two states and a sparse matrix. st_d must be of length mat.dimd and st_fp must be of length mat.dimf, and st_fp must be an adjoint. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Note that sometimes it is needed to transform a state from one basis to another. This can be done by constructing an identity operator. ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"stf = Operator(bsd, bsf, [Term(1., [-1, -1])]) * std","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The OpMat object can be converted with the SparseMatrixCSC object in the SparseArrays package. This will allow, e.g., full diagonalisation using the linear algebra package of julia. ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"SparseMatrixCSCFromOpMat(mat :: OpMat)\nOpMat(matcsc :: SparseMatrixCSC)","category":"page"},{"location":"core/#Main.FuzzifiED.SparseMatrixCSCFromOpMat-Tuple{OpMat}","page":"Core functions","title":"Main.FuzzifiED.SparseMatrixCSCFromOpMat","text":"SparseMatrixCSCFromOpMat(mat :: OpMat{ComplexF64}) :: SparseMatrixCSC{Int64,ComplexF64}\nSparseMatrixCSCFromOpMat(mat :: OpMat{Float64}) :: SparseMatrixCSC{Int64,Float64}\n\nconverts the OpMat objects to a SparseMatrixCSC object in the SparseArrays package.\n\n\n\n\n\n","category":"method"},{"location":"core/#Main.FuzzifiED.OpMat-Tuple{SparseMatrixCSC}","page":"Core functions","title":"Main.FuzzifiED.OpMat","text":"OpMat(matcsc :: SparseMatrixCSC{Int64,ComplexF64}) :: OpMat{ComplexF64}\nOpMat(matcsc :: SparseMatrixCSC{Int64,Float64}) :: OpMat{Float64}\n\nconverts the SparseMatrixCSC object in the SparseArrays package to an OpMat objects.\n\n\n\n\n\n","category":"method"},{"location":"models/#Built-in-models","page":"Models","title":"Built-in models","text":"","category":"section"},{"location":"models/#General-models-on-fuzzy-sphere","page":"Models","title":"General models on fuzzy sphere","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"GetIntMatrix(nm :: Int64, ps_pot :: Vector{Number})\nGetL2Terms(nm :: Int64, nf :: Int64)\nGetDenIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{<:Number} = [1.0], mat_a :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf), mat_b :: Matrix{<:Number} = Matrix(mat_a'))\nGetPairIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{<:Number} = [1.0], mat_a :: Matrix{<:Number}, mat_b :: Matrix{<:Number} = Matrix(mat_a'))\nGetPolTerms(nm :: Int64, nf :: Int64 ; mat :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf))","category":"page"},{"location":"models/#Main.FuzzifiED.GetIntMatrix-Tuple{Int64, Vector{Number}}","page":"Models","title":"Main.FuzzifiED.GetIntMatrix","text":"function GetIntMatrix(nm :: Int64, ps_pot :: Vector{Number}) :: Array{ComplexF64, 3}\n\nArgument\n\nnm :: Int64 is the number of orbitals\nps_pot :: Vector{Number} is the vector of non-zero pseudopotentials \n\nOutput\n\nA nm*nm*nm array giving the interaction matrix U_m_1m_2m_3-m_1-m_2-m_3\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetL2Terms-Tuple{Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetL2Terms","text":"function GetL2Terms(nm :: Int64, nf :: Int64) :: Vector{Term}\n\nReturn the terms for the total angular momentum.\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetDenIntTerms-Tuple{Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetDenIntTerms","text":"GetDenIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}, mat_b :: Matrix{<:Number}) :: Vector{Term}\n\nReturn the normal-ordered density-density term in the Hamiltonian \n\nsum_m_if_iU_m_1m_2m_3m_4M^A_f_1f_4M^B_f_2f_3c^dagger_m_1f_1c^dagger_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultive, [1.0] by default.\nmat_a :: Matrix{<:Number} is a nf*nf matrix specifying M^A_ff. Facultive, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nf*nf matrix specifying M^B_ff. Facultive, the Hermitian conjugate of mat_a by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetPairIntTerms-Tuple{Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetPairIntTerms","text":"GetPairIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}, mat_b :: Matrix{<:Number}) :: Vector{Term}\n\nReturn the normal-ordered pair-pair interaction term in the Hamiltonian \n\nsum_m_if_iU_m_1m_2m_3m_4M^A_f_1f_2M^B_f_4f_3c^dagger_m_1f_1c^dagger_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultive, [1.0] by default.\nmat_a :: Matrix{<:Number} is a nf*nf matrix specifying M^A_ff. Facultive, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nf*nf matrix specifying M^B_ff. Facultive, the Hermitian conjugate of mat_a by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetPolTerms-Tuple{Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetPolTerms","text":"GetPolTerms(nm :: Int64, nf :: Int64 ; mat :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf)) :: Vector{Term}\n\nReturn the polarisation term in the Hamiltonian \n\nsum_mffc^dagger_mfM_ffc_mf\n\nArguments\n\nnm :: Int64 is the number of orbitals ;\nnf :: Int64 is the number of flavours ; \nmat :: Matrix{<:Number} is a nf*nf matrix specifying M_ff. Facultive, I_N_f by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#Spherical-observables","page":"Models","title":"Spherical observables","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"FuzzifiED supports local observables on sphere that can be decomposed into angular components Phi(Omega)=sum_lmPhi_lmY^(s)_lm","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"SphereObs","category":"page"},{"location":"models/#Main.FuzzifiED.SphereObs","page":"Models","title":"Main.FuzzifiED.SphereObs","text":"mutable struct SphereObs\n\nstores the information of a local observable (or local operator) Phi that can be decomposed into angular components.\n\n    Phi(Omega)=sum_lmPhi_lmY^(s)_lm\n\nFields\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Vector{Term} that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the observable is stored.\ncomps :: Dict{Tuple{Int64, Int64}, Vector{Term}} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"type"},{"location":"models/","page":"Models","title":"Models","text":"It can be initialised with the following methods ","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function)\nSphereObs(s2 :: Int64, l2m :: Int64, cmps :: Dict{Tuple{Int64, Int64}, Vector{Term}})","category":"page"},{"location":"models/#Main.FuzzifiED.SphereObs-Tuple{Int64, Int64, Function}","page":"Models","title":"Main.FuzzifiED.SphereObs","text":"function SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SphereObs\n\ninitialises the observable from 2s, 2l_max and the function (lm)mapstoPhi_lm\n\nArguments\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Vector{Term} that sends the component specified by a tuple of integers (2l2m) where sleq sleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.SphereObs-Tuple{Int64, Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}","page":"Models","title":"Main.FuzzifiED.SphereObs","text":"function SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SphereObs\n\ninitialises the observable from 2s, 2l_max and a list of Phi_lm specified by a dictionary. \n\nArguments\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \ncomps :: Dict{Tuple{Int64, Int64}, Vector{Term}} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Models","title":"Models","text":"The following methods explicitly calculates and stores each component","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"StoreComps!(obs :: SphereObs)\nStoreComps(obs :: SphereObs)","category":"page"},{"location":"models/#Main.FuzzifiED.StoreComps!-Tuple{SphereObs}","page":"Models","title":"Main.FuzzifiED.StoreComps!","text":"function StoreComps!(obs :: SphereObs) :: Nothing\n\ncalculates and stores each component of the observable obs and replace the function in obs by the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.StoreComps-Tuple{SphereObs}","page":"Models","title":"Main.FuzzifiED.StoreComps","text":"function StoreComps(obs :: SphereObs) :: SphereObs\n\ncalculates and stores each component of the observable obs and return a new observable with the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Models","title":"Models","text":"The multiplication, addition, conjugate and Laplacian operation of an observable is supported ","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"*(fac :: Number, obs :: SphereObs) \n+(obs1 :: SphereObs, obs2 :: SphereObs) \nadjoint(obs :: SphereObs)\n*(obs1 :: SphereObs, obs2 :: SphereObs)\nLaplacian(obs :: SphereObs)","category":"page"},{"location":"models/#Base.:*-Tuple{Number, SphereObs}","page":"Models","title":"Base.:*","text":"function *(fac :: Number, obs :: SphereObs) :: SphereObs\nfunction *(obs :: SphereObs, fac :: Number) :: SphereObs\nfunction /(obs :: SphereObs, fac :: Number) :: SphereObs\nfunction -(obs :: SphereObs) :: SphereObs\n\nenables the multiplication of an observable with a number.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:+-Tuple{SphereObs, SphereObs}","page":"Models","title":"Base.:+","text":"function +(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\nfunction -(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n\nenables the addition of two observables.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.adjoint-Tuple{SphereObs}","page":"Models","title":"Base.adjoint","text":"function adjoint(obs :: SphereObs) :: SphereObs\n\nenables the Hermitian conjugate of an observable.\n\nbeginaligned\n    Φ^(Ω)=_lm(Φ_lm)^barY^(s)_lm(Ω)=_lm(Φ_lm)^(-1)^s+m)Y^(-s)_l-m(Ω)\n    (Φ^)_lm=(-1)^s-m(Φ_l-m)^\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:*-Tuple{SphereObs, SphereObs}","page":"Models","title":"Base.:*","text":"function *(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n\nenables the multiplication of two observable by making use of the composition of two monopole harmonics into one. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.Laplacian-Tuple{SphereObs}","page":"Models","title":"Main.FuzzifiED.Laplacian","text":"function Laplacian(obs :: SphereObs) :: SphereObs\n\nTakes the Laplacian of an observable\n\n    (^2Φ)_lm=-l(l+1)Φ_lm\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Models","title":"Models","text":"The observables can be evaluated either at an angular component or at a real-space point.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"GetComponent(obs :: SphereObs, l :: Number, m :: Number)\nGetPointValue(obs :: SphereObs, θ :: Float64, ϕ :: Float64)","category":"page"},{"location":"models/#Main.FuzzifiED.GetComponent-Tuple{SphereObs, Number, Number}","page":"Models","title":"Main.FuzzifiED.GetComponent","text":"function GetComponent(obs :: SphereObs, l :: Number, m :: Number) :: Vector{Term}\n\nreturns an angular component Φ_lm of an observable in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetPointValue-Tuple{SphereObs, Float64, Float64}","page":"Models","title":"Main.FuzzifiED.GetPointValue","text":"function GetPointValue(obs :: SphereObs, θ :: Float64, ϕ :: Float64) :: Vector{Term}\n\nevaluates an observable at one point Φ(θϕ) in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Models","title":"Models","text":"Two types of operators, viz. electrons and density operators are built-in.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Electron(nm :: Int64, nf :: Int64, f :: Int64)\nDensity(nm :: Int64, nf :: Int64 ; mat :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf))","category":"page"},{"location":"models/#Main.FuzzifiED.Electron-Tuple{Int64, Int64, Int64}","page":"Models","title":"Main.FuzzifiED.Electron","text":"function Electron(nm :: Int64, nf :: Int64, f :: Int64) :: SphereObs\n\nreturns the electron annihilation operator ψ_f\n\nArguments\n\nnf  Int64 is the number of flavours.\nnm  Int64 is the number of orbitals.\nf  Int64 is the index of the orbital to be taken.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.Density-Tuple{Int64, Int64}","page":"Models","title":"Main.FuzzifiED.Density","text":"function Density(nm :: Int64, nf :: Int64 ; mat :: Matrix{<:Number}) :: SphereObs\n\nreturns the density operator n=_ffψ^_fM_ffψ_f\n\nArguments\n\nnf  Int64 is the number of flavours.\nnm  Int64 is the number of orbitals.\nmat  Int64 is the matrix M_ff. Facultive, identity matrix mathbbI by default.\n\n\n\n\n\n","category":"method"},{"location":"models/#Ising-model-and-Potts-model","page":"Models","title":"Ising model and Potts model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The following methods is especially helpful for Ising model and Potts model.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"GetLzQnu(nm :: Int64, nf :: Int64)\nGetLzConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0)\nGetLzZnQnu(nm :: Int64, nf :: Int64)\nGetLzZnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0, zn :: Int64 = 0)\nGetIsingBasis(cfs :: Confs ; qn_p :: Int64 = 0, qn_z :: Int64 = 0, qn_r :: Int64 = 0)\nGetSnBasis(cfs :: Confs, nf :: Int64 ; qn_r :: Int64 = 0, perm :: Vector = [], qn_z :: Vector{<:Number} = Number[]) \nGetIsingIntTerms(nm :: Int64 ; ps_pot :: Vector = [1.])\nGetXPolTerms(nm :: Int64)\nGetZPolTerms(nm :: Int64)","category":"page"},{"location":"models/#Main.FuzzifiED.GetLzQnu-Tuple{Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetLzQnu","text":"function GetLzQnu(nm :: Int64, nf :: Int64) :: @NamedTuple{qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}}\n\nreturns the diagonal quantum numbers, i.e., particle number N_e and angular momentum L_z+sN_e\n\nbeginaligned\n    N_e=sum_o n_o\n    L_z+sN_e=sum_mf(m+s)n_o\nendaligned\n\nArguments\n\nnm :: Int64 is the number of orbitals ; \nnf :: Int64 is the number of flavours ; \n\nOutput\n\nA named tuple with three elements that can be directly fed into SitesFromQnu\n\nqnu_o :: Vector{Vector{Int64}} stores the charge of each orbital under each conserved quantity. See Confs for detail.\nqnu_name :: Vector{String} stores the name of each quantum number.\nmodul :: Vector{Int64} stores the modulus of each quantum number, 1 if no modulus. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetLzConfs-Tuple{Int64, Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetLzConfs","text":"function GetLzConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64) :: Confs\n\nReturn the configurations with conserved particle number N_e and angular momentum L_z.\n\nArguments\n\nnm :: Int64 is the number of orbitals 2s+1.\nnf :: Int64 is the number of flavours ; \nne :: Int64 is the number of electrons.\nlz :: Float64 is the angular momentum. Facultive, 0 by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetLzZnQnu-Tuple{Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetLzZnQnu","text":"function GetLzZnQnu(nm :: Int64, nf :: Int64) :: @NamedTuple{qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}}\n\nreturns the diagonal quantum numbers, i.e., particle number N_e, angular momentum L_z+sN_e and flavour charge Z_N_f\n\nbeginaligned\n    N_e=sum_o n_o\n    L_z+sN_e=sum_mf(m+s)n_mf\n    Z_N_f=sum_mf=0^N_f-1fn_mf mathrmmod N_f\nendaligned\n\nArguments\n\nnm :: Int64 is the number of orbitals ; \nnf :: Int64 is the number of flavours ; \n\nOutput\n\nA named tuple with three elements that can be directly fed into SitesFromQnu\n\nqnu_o :: Vector{Vector{Int64}} stores the charge of each orbital under each conserved quantity. See Confs for detail.\nqnu_name :: Vector{String} stores the name of each quantum number.\nmodul :: Vector{Int64} stores the modulus of each quantum number, 1 if no modulus. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetLzZnConfs-Tuple{Int64, Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetLzZnConfs","text":"function GetLzZnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64, zn :: Int64 = 0) :: Confs\n\nReturn the configurations with conserved particle number N_e, angular momentum L_z and flavour charge Z_N_f.\n\nArguments\n\nnm :: Int64 is the number of orbitals 2s+1.\nnf :: Int64 is the number of flavours ; \nne :: Int64 is the number of electrons.\nlz :: Float64 is the angular momentum. Facultive, 0 by default. \nzn :: Float64 is the flavour charge. Facultive, 0 by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetIsingBasis-Tuple{Confs}","page":"Models","title":"Main.FuzzifiED.GetIsingBasis","text":"function GetIsingBasis(cfs :: Confs ; qn_p :: Int64 = 0, qn_z :: Int64 = 0, qn_r :: Int64 = 0) :: Basis\n\nReturn the basis with conserved parity mathscrP, flavour symmetry mathscrZ and pi-rotation along y-axis mathscrR from the configurations already generated. Quantum numbers set to zero signify that they are not conserved. \n\nArguments\n\ncfs :: Confs is the configurations generated by GetLzConfs or GetLzZnConfs.\nqn_p :: Int64 is quantum number for parity transformation. Facultive, 0 by default.\nqn_z :: Int64 is the particle quantum number for mathbbZ_2-flavour transformation. Facultive, 0 by default.\nqn_r :: Int64 is the quantum number for  pi rotation along y-axis compared with the ground state. Facultive, 0 by default.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetSnBasis-Tuple{Confs, Int64}","page":"Models","title":"Main.FuzzifiED.GetSnBasis","text":"function GetSnBasis(cfs :: Confs, nf :: Int64 ; qn_r :: Int64 = 0, perm :: Vector, qn_z :: Vector{<:Number}) :: Basis\n\nReturn the basis where the pi-rotation along y-axis mathscrR and certain permutationss of flavour are implemented. Quantum numbers set to zero signify that they are not conserved. \n\nArguments\n\ncfs :: Confs is the configurations generated by GetLzConfs or GetLzZnConfs.\nnf :: Int64 is the number of flavours\nqn_r :: Int64 is the quantum number for  pi rotation along y-axis compared with the ground state. Facultive, 0 by default.\nperm :: Vector{Vector{Int64}} is a list where each element specifies a permutation of flavour indices (from 1 to N_f) in the format of a cycle. Facultive, empty by default.\nqn_z :: Vector{<:Number} is a list where each element specifies the quantum number under the flavour permutation. Facultive, empty by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetIsingIntTerms-Tuple{Int64}","page":"Models","title":"Main.FuzzifiED.GetIsingIntTerms","text":"function GetIsingIntTerms(nm :: Int64 ; ps_pot :: Vector) :: Vector{Term}\n\nReturns the terms for the ising interaction \n\nsum_m_1m_2m_3m_42U_m_1m_2m_3m_4c^dagger_m_1uparrowc^dagger_m_2downarrowc_m_3downarrowc_m_4uparrow\n\nfrom the pseudopotentials. \n\nArguments\n\nnm :: Int64 is the number of orbitals 2s+1.\nps_pot :: Vector{Number} is the pseudopotential of Ising interaction.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetXPolTerms-Tuple{Int64}","page":"Models","title":"Main.FuzzifiED.GetXPolTerms","text":"function GetXPolTerms(nm :: Int64)\n\nReturns the terms for the density operator n^x_l=0m=0\n\nArguments\n\nnm :: Int64 is the number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetZPolTerms-Tuple{Int64}","page":"Models","title":"Main.FuzzifiED.GetZPolTerms","text":"function GetZPolTerms(nm :: Int64)\n\nReturns the terms for the density operator n^z_l=0m=0\n\nArguments\n\nnm :: Int64 is the number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"models/#\\mathrm{Sp}(N)-model","page":"Models","title":"mathrmSp(N) model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The following methods is especially helpful for mathrmSp(N) model and Potts model.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"GetSpnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0, sz :: Vector{Int64} = fill(0, div(nf, 2)))\nGetSpnBasis(cfs :: Confs, nf :: Int64 ; qn_p :: Int64 = 0, qn_r :: Int64 = 0, qn_z :: Vector{Int64} = fill(0, div(nf, 2)), qn_x :: Vector{Int64} = fill(0, div(nf, 4)))\nGetSpnPairIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector{<:Number} = [1.])\nGetSpnC2Terms(nm :: Int64, nf :: Int64) ","category":"page"},{"location":"models/#Main.FuzzifiED.GetSpnConfs-Tuple{Int64, Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetSpnConfs","text":"function GetSpnConfs(nm :: Int64, nf :: Int64, ne :: Int64 ; lz :: Float64 = 0.0, sz :: Vector{Int64}) :: Confs\n\nReturn the configurations with conserved particle number N_e, angular momentum L_z and Cartans of the mathrmSp(N) symmetry \n\nbeginaligned\nN_e=sum_mfn_mf\nL_z=sum_mfmn_mf\nS_zi=sum_m (n_mi-n_mi+N_f2)i=1dotsN_f2\nendaligned\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nne :: Int64 is the number of electrons.\nlz :: Float64 is the angular momentum. Facultive, 0 by default. \nsz :: Vector{Int64} is N_f2 numbers that give mathrmSp(N) Cartan. Facultive, a vector of N_f2 zeros by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetSpnBasis-Tuple{Confs, Int64}","page":"Models","title":"Main.FuzzifiED.GetSpnBasis","text":"function GetSpnBasis(cfs :: Confs, nf :: Int64 ; qn_p :: Int64 = 0, qn_r :: Int64 = 0, qn_z :: Vector{Int64}, qn_x :: Vector{Int64} :: Basis\n\nReturn the basis with conserved parity mathscrP, pi-rotation along y-axis mathscrR, and flavour symmetries mathscrZ_imathscrX_i from the configurations already generated. Quantum numbers set to zero signify that they are not conserved. \n\nbeginaligned\nmathscrPc^dagger_mfmapsto c_mf+N_f2c^dagger_mf+N_f2mapsto-c_mf\nmathscrRc^dagger_mfmapsto c^dagger_-mf\nmathscrZ_ic^dagger_mimapsto c^dagger_mi+N_f2c^dagger_mi+N_f2mapsto-c^dagger_mii=12dotsN_f2\nmathscrX_ic^dagger_m2i-1leftrightarrow c^dagger_m2ic^dagger_m2i-1+N_f2leftrightarrow c^dagger_m2i+N_f2i=12dotsN_f4\nendaligned\n\nNote that sometimes some mathscrZ_i and mathscrX_i cannot be implemented at the same time. \n\nArguments\n\ncfs :: Confs is the configurations generated by GetSpnConfs.\nnf :: Int64 is the number of flavours.\nqn_p :: Int64 is quantum number for parity transformation. Facultive, 0 by default.\nqn_r :: Int64 is the quantum number for  pi rotation along y-axis compared with the ground state. Facultive, 0 by default.\nqn_z :: Vector{Int64} is N_f2 numbers that give mathscrZ_i flavour symmetry. Facultive, all 0 by default.\nqn_x :: Vector{Int64} is N_f4 numbers that give mathscrX_i flavour symmetry. Facultive, all 0 by default.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetSpnPairIntTerms-Tuple{Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetSpnPairIntTerms","text":"function GetSpnPairIntTerms(nm :: Int64, nf :: Int64 ; ps_pot :: Vector) :: Vector{Term}\n\nReturns the terms for the mathrmSp(N) pair-pair interaction \n\nsum_m_1m_2m_3m_4ff2U_m_1m_2m_3m_4c^dagger_m_1fc^dagger_m_2f+N_f2c_m_3 f+N_f2c_m_4f\n\nfrom the pseudopotentials. \n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{Number} is the pseudopotential of the hubbard interaction.\n\n\n\n\n\n","category":"method"},{"location":"models/#Main.FuzzifiED.GetSpnC2Terms-Tuple{Int64, Int64}","page":"Models","title":"Main.FuzzifiED.GetSpnC2Terms","text":"function GetSpnC2Terms(nm :: Int64, nf :: Int64) :: Vector{Term}\n\nReturns the quadratic Casimir C_2 of the mathrmSp(N) symmetry.\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\n\n\n\n\n\n","category":"method"},{"location":"releases/#Release-notes","page":"Releases","title":"Release notes","text":"","category":"section"},{"location":"releases/#On-going-constructions","page":"Releases","title":"On-going constructions","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for mathrmO(3) model. \nAdd calculation for entanglement. ","category":"page"},{"location":"releases/#June-2024","page":"Releases","title":"June 2024","text":"","category":"section"},{"location":"releases/#3-June,-2024-(Version-0.5.8)","page":"Releases","title":"3 June, 2024 (Version 0.5.8)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Change the binary dependence to Julia Binary Builder. ","category":"page"},{"location":"releases/#May-2024","page":"Releases","title":"May 2024","text":"","category":"section"},{"location":"releases/#30-May,-2024-(Version-0.5.0)","page":"Releases","title":"30 May, 2024 (Version 0.5.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Enable simplification of terms.\nAdd general observables and built-in electrons and density operators. \nReorganise the realisations of built-in models.\nCancel ITensorMPOConstruction dependence. ","category":"page"},{"location":"releases/#29-May,-2024-(Version-0.4.3)","page":"Releases","title":"29 May, 2024 (Version 0.4.3)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add QNU truncation for ITensors use.\nChange the Fortran code to be robust against QNU breaking terms\nAdd built-in density-density interaction. \nAdd built-in 3-state Potts model.\nAdd built-in Ising model with magnetic line defect. ","category":"page"},{"location":"releases/#28-May,-2024-(Version-0.4.0)","page":"Releases","title":"28 May, 2024 (Version 0.4.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for DMRG.\nAdd convertion from diagonal QNs to sites. \nAdd the support of mathbbZ_n diagonal quantum numbers in Confs.\nMerge the submodules to the main package. \nAdd Ising model in X basis.  \nAdd functions in built-in models to export diagonal QNs. ","category":"page"},{"location":"releases/#27-May,-2024-(Version-0.3.0)","page":"Releases","title":"27 May, 2024 (Version 0.3.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add the support for Hamiltonians with real elements. \nAdd conversion with SparseMatrixCSC. \nAdd the conversion from terms to OpSum.\nAdd the look-up of configurations. \nFor the built-in Ising model, add density operator.\nAdd built-in mathrmSp(N) model. ","category":"page"},{"location":"releases/#26-May,-2024-(Version-0.2.0)","page":"Releases","title":"26 May, 2024 (Version 0.2.0)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add operations of terms.\nAdd built-in Ising model. ","category":"page"},{"location":"#FuzzifiED.jl","page":"Home","title":"FuzzifiED.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package FuzzifiED is designed to do exact diagonalisation (ED) calculation on the fuzzy sphere, and also facilitates the DMRG calculations by ITensors. It can also be used for generic fermion models. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"If this package is helpful in your research, we would appreciate it if you mention in the acknowledgement. If you have any questions, please Zheng Zhou (周正) contact at zzhou@pitp.ca.","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To Apple Silicon (Mac M1, M2, etc.) users: you may want to use Julia (https://julialang.org/downloads/) for x86 (Intel or Rosetta) instead of macOS (Apple Silicon).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the package, please first enter Julia by entering in the command line julia, and then enter the commands","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; \njulia> Pkg.add(url=\"https://github.com/mankai-chow/FuzzifiED_jll.jl.git\")\njulia> Pkg.add(url=\"https://github.com/mankai-chow/FuzzifiED.jl.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Include at the start of your Julia script","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FuzzifiED","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"example.md\",\n    \"core.md\",\n    \"itensors.md\",\n    \"models.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"core.md\",\n    \"itensors.md\",\n    \"models.md\"\n]","category":"page"},{"location":"example/#FuzzifiED-explained-in-an-example","page":"Example","title":"FuzzifiED explained in an example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"In this example, we will illustrate how to use FuzzifiED to calculate the spectrum of Ising model on fuzzy sphere and how to calculate the OPE coefficient lambda_sigmasigmaepsilon by measuring the expectation value of the density operator n^z. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The examples can be found in the directory examples. Three versions of this example is provided. The first does not use the built-in example and is stored in ising_primitive.jl ; the second uses the interfaces with ITensors and is stored in example_ising_itensors.jl ; the third uese the built-in example for the Ising model and is stored in example_ising.jl. The explanations following applied mainly to the primitive version. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"In addition, an example of how FuzzifiED can facilitate DMRG calculation is given. Two versions of the DMRG example is provided. The first uses MPO and dmrg functions of the ITensors package and is stored in ising_dmrg.jl. The second uses the EasySweep function in the package which further wraps the dmrg function to facilitate the management of sweeps and is stored in ising_dmrg_easysweep.jl. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We also append in the end a list of ","category":"page"},{"location":"example/#Exact-diagonalisation-with-FuzzifiED","page":"Example","title":"Exact diagonalisation with FuzzifiED","text":"","category":"section"},{"location":"example/#Implement-the-diagonal-quantum-numbers-and-generate-the-configurations","page":"Example","title":"Implement the diagonal quantum numbers and generate the configurations","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"FuzzifiED supports diagonal quantum numbers (QNU) in the form of ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Q_i=sum_o=1^N_oq_ion_oquadmathrmorquad Q_i=sum_o=1^N_oq_ion_o mathrmmod P_i","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where i=1dotsN_U is the index of diagonal quantum numbers, o is the index of orbital, n_o=c^dagger_oc_o, and q_o is a set of coefficients that must be non negative integer valued. (A list of q_o with both positive and negative entries can be adapted by shifting every elements by a same value)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The function used to implement the diagonal quantum numbers and generate all the configurations (i.e., direct product states) is Confs. There are two diagonal quantum numbers in the Ising model, viz. the particle number and the angular momentum","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"beginaligned\nQ_1=N_e q_1msigma=1\nQ_2=L_z+N_esq_2msigma=m+s\nendaligned","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where the orbital index o contains both m and sigma. In the code, we store the orbitals with the same m together, viz. we store the spin-up orbitals in odd o=13dots2N_m-1 and the spin-down orbitals in even o=24dots2N_m. Thus, if we want to look at the L_z=0 half-filled sector","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Inputing the basic setups\nnf = 2\nnm = 8\nno = nf * nm\ns = .5 * (nm - 1)\nne = div(no, 2)\n# Initialise the arrays\nqnu_s = Vector{Int64}(undef, 0)\nqnu_o = []\n# Record the number of electrons\npush!(qnu_o, fill(1, no)) # qnu_o[1] = [1,1,...,1]\npush!(qnu_s, ne) \n# Record the angular momentum\npush!(qnu_o, [ div(o - 1, nf) for o = 1 : no ]) # qnu_o[2] = [0,0,1,1,...,7,7] to qnu_o\npush!(qnu_s, ne * s) \n# Generate the configurations and print the number\n@time \"Initialise configurations\" cfs = Confs(no, qnu_s, qnu_o)\n@show cfs.ncf","category":"page"},{"location":"example/#ITensor-support","page":"Example","title":"ITensor support","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The quantum numbers can also be imported from the Sites objects in ITensors. This can be done using the ConfsFromSites function.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Overload the ITensors type \"Fermion\"\nfunction ITensors.space( :: SiteType\"Fermion\" ; m1 :: Int = 0)\n    return [\n        QN((\"Nf\", 0, -1), (\"Lz\",  0)) => 1\n        QN((\"Nf\", 1, -1), (\"Lz\", m1)) => 1\n    ]\nend\n# Initialise the sites\nsites = [ siteind(\"Fermion\", m1 = div(o - 1, nf)) for o :: Int = 1 : no]\nqn_s = QN((\"Nf\", ne), (\"Lz\", Int(ne * s)))\n@time \"Initialise configurations\" cfs = ConfsFromSites(sites, qn_s)\n# Alternatively, one can initialise the configuration quantum number\n# cf_ref = [o <= ne ? 1 : 0 for o = 1 : no]\n# @time \"Initialise configurations\" cfs = ConfsFromSites(sites, cf_ref)\n@show cfs.ncf","category":"page"},{"location":"example/#Built-in-model","page":"Example","title":"Built-in model","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Using The built-in Ising model, the process above can be done in one line with the method GetLzConfs.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cfs = GetLzConfs(nm, 2)","category":"page"},{"location":"example/#Implement-the-discrete-symmetries-and-initialise-the-basis","page":"Example","title":"Implement the discrete symmetries and initialise the basis","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"FuzzifiED supports discrete mathbbZ_n symmetries in the form of ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"mathscrZ c_oto alpha_o^* c^(p_o)_pi_oquad c_o^daggerto alpha_o c^(1-p_o)_pi_o","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where we use a notation c^(1)=c^dagger and c^0=c for convenience, where pi_o is a permutation of 1dots N_o, alpha_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the orbital. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal quantum numbers. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"After implementing these symmetries, a state in the new basis should look like ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Irangle=lambda_i_I1i_I1rangle+lambda_i_I2i_I2rangle+cdots+lambda_i_Im_Ii_Im_Irangle","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where the irangle's are configurations in the Confs generated in the last section. The Irangle is a linear combination, and can be regarded as a grouping of m_I configurations.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The function used to implement the discrete symmetries is Basis. There are three mathbbZ_2 transformations in the Ising model, viz. the particle-hole transformation mathscrP, the pi-rotation along the y-axis mathscrR_y and the flavour symmetry mathscrZ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"beginaligned\n    mathscrPc^dagger_sigma mtosigma c_-sigmam\n    mathscrZc^dagger_sigma mto c^dagger_-sigmam\n    mathscrR_yc^dagger_sigma mto c^dagger_sigma-m\nendaligned","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Thus, if we want to look at the all-positive sector","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cyc = [ 2, 2, 2 ] # Input three Z_2 symmetries \nqnz_s = ComplexF64[ 1, 1, 1 ] # Quantum numbers are all positive \n# Initialise the vectors\nperm_o = []\nph_o = []\nfac_o = []\n# Record the parity\npush!(perm_o, [ isodd(o) ? o + 1 : o - 1 for o = 1 : no]) # perm_o[1] = [2,1,4,3,...,16,15]\npush!(ph_o, fill(1, no)) # ph_o[1] = [1,1,...,1] meaning PH\npush!(fac_o, [ isodd(o) ? -1 : 1 for o = 1 : no]) # fac_o[1] = [1,-1,1,-1,...,1,-1]\n# Record the flavour symmetry\npush!(perm_o, [ isodd(o) ? o + 1 : o - 1 for o = 1 : no]) # perm_o[3] = [2,1,4,3,...,16,15]\npush!(ph_o, fill(0, no)) # ph_o[3] = [0,0,...,0] meaning no PH\npush!(fac_o, fill(ComplexF64(1), no)) # fac_o[3] = [1,1,...,1]\n# Record the pi-rotation\npush!(perm_o, [ isodd(o) ? no - o : no + 2 - o for o = 1 : no]) # perm_o[2] = [15,16,13,14,...,1,2]\npush!(ph_o, fill(0, no)) # ph_o[2] = [0,0,...,0] meaning no PH\npush!(fac_o, fill(ComplexF64(1), no)) # fac_o[2] = [1,1,...,1]\n# Generate the basis and print the dimension\n@time \"Initialise basis\" bs = Basis(cfs, qnz_s, cyc, perm_o, ph_o, fac_o)\n@show bs.dim ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Note that if no discrete symmetry is needed, one can simply put instead bs = Basis(conf)","category":"page"},{"location":"example/#Built-in-model-2","page":"Example","title":"Built-in model","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Using The built-in Ising model, the process above can be done in one line with the method GetIsingBasis.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"bs = GetIsingBasis(cfs ; qn_p = 1, qn_r = 1, qn_z = 1)","category":"page"},{"location":"example/#Record-the-Hamiltonian-operator","page":"Example","title":"Record the Hamiltonian operator","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The operator here refers to the sum of product of c and c^dagger's in the form ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Phi=sum_t=1^N_tU_tc^(p_t1)_o_t1c^(p_t2)_o_t2dots c^(p_tl)_o_tl","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"where c^(0)=c and c^(1)=c^dagger. Here the operator string sum is recorded together with the basis of the initial state and the basis of the final state. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This can be generated by the Operator function. The Hamiltonian for the fuzzy sphere Ising model","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"H=sum_m_1m_2m_3m_4U_m_1m_2m_3m_4delta_m_1+m_2m_3+m_4c^dagger_m_1uparrowc^dagger_m_2downarrowc_m_3downarrowc_m_4uparrow-hsum_m(c^dagger_muparrowc_mdownarrow+mathrmhc)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"can be recorded with ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using WignerSymbols\n# Input the parameters of the Hamiltonian\nps_pot = [ 4.75, 1. ] * 2.\nh = 3.16\ntms_hmt = Vector{Term}(undef, 0)\n# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3\nfor m1 = 0 : nm - 1\n    f1 = 0\n    o1 = m1 * nf + f1 + 1\n    m1r = m1 - s\n    for m2 = 0 : nm - 1\n        f2 = 1\n        o2 = m2 * nf + f2 + 1\n        m2r = m2 - s\n        for m3 = 0 : nm - 1\n            f3 = 1\n            o3 = m3 * nf + f3 + 1\n            m3r = m3 - s\n            m4 = m1 + m2 - m3 \n            if (m4 < 0 || m4 >= nm) continue end\n            f4 = 0\n            o4 = m4 * nf + f4 + 1\n            m4r = m4 - s\n            # Calculate the matrix element val from pseudopotentials\n            val = ComplexF64(0)\n            for l in 1 : length(ps_pot)\n                if (abs(m1r + m2r) > nm - l || abs(m3r + m4r) > nm - l) break end \n                val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, m1r, m2r, -m1r - m2r) * wigner3j(s, s, nm - l, m4r, m3r, -m3r - m4r)\n            end \n            # Record the interaction term val, \"Cdag\", o1, \"Cdag\", o2, \"C\", o3, \"C\", o4\n            push!(tms_hmt, Term(val, [1, o1, 1, o2, 0, o3, 0, o4]))\n        end\n    end\n    o1x = o1 + 1\n    # Record the transverse field term\n    push!(tms_hmt, Term(-h, [1, o1, 0, o1x]))\n    push!(tms_hmt, Term(-h, [1, o1x, 0, o1]))\nend\n# Generate the Hamiltonian operator\nhmt = Operator(bs, bs, tms_hmt ; red_q = 1, sym_q = 1)","category":"page"},{"location":"example/#ITensor-support-2","page":"Example","title":"ITensor support","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Alternatively, one can generate the operator using an OpSum object instead of cstr_vec and fac using the function TermsFromOpSum.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"For the Hamiltonian of Ising model,","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"\nusing WignerSymbols\n# Input the parameters of the Hamiltonian\nps_pot = [ 4.75, 1. ] * 2.\nh = 3.16\nglobal ops_hmt = OpSum()\n# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m3\nfor m1 = 0 : nm - 1\n    f1 = 0\n    o1 = m1 * nf + f1 + 1\n    m1r = m1 - s\n    for m2 = 0 : nm - 1\n        f2 = 1\n        o2 = m2 * nf + f2 + 1\n        m2r = m2 - s\n        for m3 = 0 : nm - 1\n            f3 = 1\n            o3 = m3 * nf + f3 + 1\n            m3r = m3 - s\n            m4 = m1 + m2 - m3 \n            if (m4 < 0 || m4 >= nm) continue end\n            f4 = 0\n            o4 = m4 * nf + f4 + 1\n            m4r = m4 - s\n            # Calculate the matrix element val from pseudopotentials\n            val = ComplexF64(0)\n            for l in 1 : length(ps_pot)\n                if (abs(m1r + m2r) > nm - l || abs(m3r + m4r) > nm - l) break end \n                val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, m1r, m2r, -m1r - m2r) * wigner3j(s, s, nm - l, m4r, m3r, -m3r - m4r)\n            end \n            # Record the interaction term\n            global ops_hmt += val, \"Cdag\", o1, \"Cdag\", o2, \"C\", o3, \"C\", o4\n        end\n    end\n    o1x = o1 + 1\n    # Record the transverse field term\n    global ops_hmt += -h, \"Cdag\", o1, \"C\", o1x\n    global ops_hmt += -h, \"Cdag\", o1x, \"C\", o1\nend\n# Generate the Hamiltonian operator\ntms_hmt = TermsFromOpSum(ops_hmt)\nhmt = Operator(bs, bs, tms_hmt ; red_q = 1, sym_q = 1)","category":"page"},{"location":"example/#Built-in-model-3","page":"Example","title":"Built-in model","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Using The built-in Ising model, the process above can be done in one line with the method GetIsingIntTerms and GetXPolTerms","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"tms_hmt = GetIsingIntTerms(nm ; ps_pot = [4.75, 1.]) - 3.16 * GetXPolTerms(nm)","category":"page"},{"location":"example/#Generate-the-sparse-matrix-and-diagonalise","page":"Example","title":"Generate the sparse matrix and diagonalise","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"After specifying the Hamiltonian, we then use the OpMat to generate a sparse matrix from the operator. To get the 10 lowest eigenstates and their energies","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"@time \"Initialise the Hamiltonian matrix\" hmt_mat = OpMat(hmt)\n@show hmt_mat.nel\n@time \"Diagonalise Hamiltonian\" enrg, st = GetEigensystem(hmt_mat, 10)\n@show real(enrg)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We also note that matrices with real elements can be generated with the option type = Float64 in the OpMat function. ","category":"page"},{"location":"example/#Measuring-the-angular-momentum","page":"Example","title":"Measuring the angular momentum","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"We can measure the inner product of a final state, an operator or its matrix and an initial state or the action of an operator or its matrix on a state by directly using the * operator. To measure the total angular momentum L^2 by definition","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"beginaligned\nL^2=L^+L^-+(L^z)^2-L^z\nL^z=sum_sigma mmc^dagger_mc_m\nL^pm=sum_sigma msqrt(smp m)(spm m+1)c^dagger_mpm 1c_m\nendaligned","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The construction of the operator can be simplified by the addition, multiplication, Hermitian conjugate and simplification of terms. The following code measures the angular momentum of each eigenstate and verify whether Trangle is an eigenstate of L^2 by measuring ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"L^2Trangle=L^2Tranglequadfraclangle TL^2Trangle^2langle TTranglelangle L^2TL^2Trangle","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"tms_lz = \n    [ begin m = div(o - 1, nf)\n        Term(m - s, [1, o, 0, o])\n    end for o = 1 : no ]\ntms_lp = \n    [ begin m = div(o - 1, nf)\n        Term(sqrt(m * (nm - m)), [1, o, 0, o - nf])\n    end for o = nf + 1 : no ]\ntms_lm = tms_lp' \ntms_l2 = SimplifyTerms(tms_lz * tms_lz - tms_lz + tms_lp * tms_lm)\n# Initialise the L2 operator\nl2 = Operator(bs, bs, tms_l2 ; red_q = 1, sym_q = 1)\n@time \"Initialise L2\" l2_mat = OpMat(l2)\n# Calculate the inner product for each eigenstate\n@time \"Measure L2\" l2_val = [ st[:, i]' * l2_mat * st[:, i] for i = 1 : length(enrg)]\n@show real(l2_val)\n# Verify whether T is an eigenstate of L^2\nst_T = st[:, 3]\nst_L2T = l2_mat * st[:, 3]\n@show abs(st_L2T' * st_T) ^ 2 / ((st_T' * st_T) * (st_L2T' * st_L2T))","category":"page"},{"location":"example/#Built-in-model-4","page":"Example","title":"Built-in model","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Using The built-in Ising model, the generation of the terms in total angular momentum can be done in one line with the method GetL2Terms","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"tms_l2 = GetL2Terms(nm, 2)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This method also applies to other models on fuzzy sphere. ","category":"page"},{"location":"example/#Measuring-the-density-operator","page":"Example","title":"Measuring the density operator","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Similar process can be used to calculate the OPE coefficient by measuring the density operator, by definition ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"lambda_sigmasigmaepsilon=fraclanglesigman^z_00epsilonranglelanglesigman^z_00mathbbIranglequad n^z_00=frac1N_msum_sigma msigma c^dagger_sigma mc_sigma m","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"To do that, we need to first repeat the calculation in the mathbbZ_2-odd sector","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Repeat the calculation for the Z_2 odd sector (with subscript 1)\nqnz_s1 = ComplexF64[ 1, -1, 1 ] # Change only the discrete quantum numbers and generate the basis\n@time \"Initialise Basis Z\" bs1 = Basis(cfs, qnz_s1, cyc, perm_o, ph_o, fac_o) \n@show bs1.dim \nhmt = Operator(bs1, bs1, tms_hmt ; red_q = 1, sym_q = 1) # Generate and diagonalise Hamiltonian in the new basis\n@time \"Initialise Hamiltonian\" hmt_mat = OpMat(hmt)\n@show hmt_mat.nel\n@time \"Diagonalise Hamiltonian\" enrg1, st1 = GetEigensystem(hmt_mat, 10)\n@show real(enrg1)\n# Record the identity, sigma and epsilon states \nst_I = st[:, 1] # ground state\nst_e = st[:, 2] # epsilon state\nst_s = st1[:, 1]","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"and then generate and measure the density operator","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"# Record the density operator n^z\ntms_nz = [ Term(isodd(o) ? 1 / nm : -1 / nm, [1, o, 0, o]) for o = 1 : no]\n# The nz operator sends a state in bs (+) to bs1 (-)\nnz = Operator(bs, bs1, tms_nz ; red_q = 1)\n# Measuring the finite size OPE\n@show abs((st_s' * nz * st_e) / (st_s' * nz * st_I))","category":"page"},{"location":"example/#Built-in-model-5","page":"Example","title":"Built-in model","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Using The built-in Ising model, the generation of the terms in density operator can be done in one line with the method GetZPolTerms","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"tms_nz = GetZPolTerms(nm) ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"This method also applies to other models on fuzzy sphere. ","category":"page"},{"location":"example/#DMRG-calculations-with-FuzzifiED","page":"Example","title":"DMRG calculations with FuzzifiED","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"In this example, we calculate the ground state MPS of the fuzzy sphere Ising model by DMRG in ITensors, and use the same objects to do ED calculation and compare the result. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We first set-up the calculation by","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using FuzzifiED\nusing ITensors\nnm = 12\nnf = 2\nno = nm * nf","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The first object we need is the sites. FuzzifiED overloads the fermion type and supports direct generation of the sites from the diagonal quantum numbers by the function SitesFromQnu. The diagonal quantum numbers of the Ising model is built in and can be generated by the function GetLzZnQnu. The Ising model is expressed in the basis of XX-Z so that the flavour symmetry is diagonal. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"sites = SitesFromQnu(; GetLzZnQnu(nm, 2)...)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We then generate the terms of the Hamiltonian using the built-in functions, convert it to OpSum type in by the OpSumFromTerms, and convert it to MPO using the MPO function in ITensors","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"sigma_x = [ 0 1 ; 1 0 ]\ntms_hmt = SimplifyTerms(GetDenIntTerms(nm ; ps_pot = [4.75, 1.]) - GetDenIntTerms(nm ; ps_pot = [4.75, 1.], mat_a = sigma_x) - 3.16 * GetZPolTerms(nm))\n@time mpo_hmt = MPO(OpSumFromTerms(tms_hmt), sites)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We then use the all-up state as the initial state. In FuzzifiED, the occupied and empty sites are expressed by 0 and 1, while they are expressed by \"0\" and \"1\" in ITensors, so a conversion to string is needed. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]\nst0 = MPS(sites, string.(cf0))","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"After that, the Hamiltonian MPO and the initial state MPS can be used for input for DMRG calculation. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Eg, stg = dmrg(mpo_hmt, st0 ; nsweeps = 10, maxdim = [10,20,50,100,200,500], noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], cutoff = [1E-8])\n@show Eg","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We then convert these objects for the ED calculate. The configurations can be generated from Sites and a reference configuration by the function ConfsFromSites. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cfs = ConfsFromSites(sites, cf0)\nbs = Basis(cfs)\nhmt = Operator(bs, bs, tms_hmt ; red_q = 1, sym_q = 1)\nhmt_mat = OpMat(hmt ; type = Float64)\nenrg, st = GetEigensystem(hmt_mat, 10)\n@show enrg","category":"page"},{"location":"example/#Use-EasySweep-to-manage-DMRG-sweeps","page":"Example","title":"Use EasySweep to manage DMRG sweeps","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"EasySweep facilitates the management of DMRG process by automatically recording the intermediate results and recovering these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. Before the calculation, we need to define a method to generate MPO from OpSum and Sites. We suggest using MPO_new from package ITensorMPOConstruction, which can be installed through ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"julia> Pkg.add(url=\"https://github.com/ITensor/ITensorMPOConstruction.jl.git\"); ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using ITensorMPOConstruction\nfunction MyMPO(os, sites)\n    operatorNames = [ \"I\", \"C\", \"Cdag\", \"N\" ]\n    opCacheVec = [ [OpInfo(ITensors.Op(name, n), sites[n]) for name in operatorNames] for n in eachindex(sites)  ]\n    mpo = MPO_new(os, sites ; basisOpCacheVec = opCacheVec)\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We also need to specify a path where the results are stored. ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"path = \"nm_$(nm)/\"\nmkpath(path)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The Hamiltonian MPO and the sites can be either generated or read from file by the function GetMpoSites. The input is the quantum numbers and the terms or OpSum ; the output is the MPO and the sites","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"sigma_x = [ 0 1 ; 1 0 ]\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2 ; ps_pot = [4.75, 1.]) - \n    GetDenIntTerms(nm, 2 ; ps_pot = [4.75, 1.], mat_a = sigma_x) - \n    3.16 * GetZPolTerms(nm)\n)\nhmt, sites = GetMpoSites(\"hmt\", tms_hmt ; path, GetLzZnQnu(nm, 2)..., mpo_method = MyMPO)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"After generating the initial state MPS, the DMRG calculation of the states mathbbI and epsilon can be done by the EasySweep function.  ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]\nst0 = MPS(sites, string.(cf0))\nEg, stg = EasySweep(\"g\", hmt, st0 ; path)\nEe, ste = EasySweep(\"e\", hmt, st0 ; path, proj = [\"g\"])","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The total angular momentum can be measured by generating the MPO of L^2 and measure the inner product ","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = GetMpo(\"l2\", tms_l2, sites ; path)\n@show inner(stg', l2, stg)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The mathbbZ_2-odd sigma state can be calculated similarly.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"cf1 = cf0\ncf1[1] = 0\ncf1[2] = 1\nst1 = MPS(sites, string.(cf1))\nEs, sts = EasySweep(\"s\", hmt, st1 ; path)","category":"page"},{"location":"example/#List-of-examples","page":"Example","title":"List of examples","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"The following examples of FuzzifiED can be found in the repository examples.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"example_ising.jl does the ED calculation of Ising model through the built-in models. \nexample_ising_primitive.jl does the ED calculation of Ising model through the primitive functions.\nexample_ising_itensors.jl does the ED calculation of Ising model by the Sites and OpSum objects in ITensors.\nexample_ising_dmrg.jl does the DMRG calculation of Ising model through the dmrg function in ITensors.\nexample_ising_dmrg_easysweep.jl does the DMRG calculation of Ising model through the EasySweep function which wraps ITensors.\nexample_ising_def.jl does the ED calculation of Ising model with magnetic line defect or defect creation or changing operators.\nexample_ising_def_dmrg.jl does the DMRG calculation of Ising model with magnetic line defect or defect changing operators. \nexample_sp2.jl does the ED calculation of the mathrmSO(5) DQCP model.\nexample_potts.jl does the ED calculation of the three-states Potts model.\nexample_potts_dmrg.jl does the DMRG calculation of the three-states Potts model in the X basis.","category":"page"}]
}
